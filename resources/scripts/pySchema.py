#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Fri Dec 28 15:35:35 2018 by generateDS.py version 2.30.11.
# Python 2.7.15rc1 (default, Nov 12 2018, 14:31:15)  [GCC 7.3.0]
#
# Command line options:
#   ('-o', '../pySchema.py')
#   ('-s', '../stub.py')
#
# Command line arguments:
#   ../../PL_009_V4_2016_002_v160b/nfe_v4.00.xsd
#
# Command line:
#   generateDS.py -o "../pySchema.py" -s "../stub.py" ../../PL_009_V4_2016_002_v160b/nfe_v4.00.xsd
#
# Current working directory (os.getcwd()):
#   generateDS-2.30.11
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class CRTType(object):
    _1='1'
    _2='2'
    _3='3'


class CSOSNType(object):
    _1_01='101'


class CSOSNType32(object):
    _1_02='102'
    _1_03='103'
    _3_00='300'
    _4_00='400'


class CSOSNType33(object):
    _2_01='201'


class CSOSNType35(object):
    _2_02='202'
    _2_03='203'


class CSOSNType37(object):
    _5_00='500'


class CSOSNType38(object):
    _9_00='900'


class CSTType(object):
    _0_0='00'


class CSTType10(object):
    _2_0='20'


class CSTType12(object):
    _3_0='30'


class CSTType15(object):
    _4_0='40'
    _4_1='41'
    _5_0='50'


class CSTType17(object):
    _5_1='51'


class CSTType19(object):
    _6_0='60'


class CSTType20(object):
    _7_0='70'


class CSTType24(object):
    _9_0='90'


class CSTType28(object):
    _1_0='10'
    _9_0='90'


class CSTType31(object):
    _4_1='41'
    _6_0='60'


class CSTType41(object):
    _0_1='01'
    _0_2='02'


class CSTType42(object):
    _0_3='03'


class CSTType43(object):
    _0_4='04'
    _0_5='05'
    _0_6='06'
    _0_7='07'
    _0_8='08'
    _0_9='09'


class CSTType44(object):
    _4_9='49'
    _5_0='50'
    _5_1='51'
    _5_2='52'
    _5_3='53'
    _5_4='54'
    _5_5='55'
    _5_6='56'
    _6_0='60'
    _6_1='61'
    _6_2='62'
    _6_3='63'
    _6_4='64'
    _6_5='65'
    _6_6='66'
    _6_7='67'
    _7_0='70'
    _7_1='71'
    _7_2='72'
    _7_3='73'
    _7_4='74'
    _7_5='75'
    _9_8='98'
    _9_9='99'


class CSTType45(object):
    _0_1='01'
    _0_2='02'


class CSTType46(object):
    _0_3='03'


class CSTType47(object):
    _0_4='04'
    _0_5='05'
    _0_6='06'
    _0_7='07'
    _0_8='08'
    _0_9='09'


class CSTType48(object):
    _4_9='49'
    _5_0='50'
    _5_1='51'
    _5_2='52'
    _5_3='53'
    _5_4='54'
    _5_5='55'
    _5_6='56'
    _6_0='60'
    _6_1='61'
    _6_2='62'
    _6_3='63'
    _6_4='64'
    _6_5='65'
    _6_6='66'
    _6_7='67'
    _7_0='70'
    _7_1='71'
    _7_2='72'
    _7_3='73'
    _7_4='74'
    _7_5='75'
    _9_8='98'
    _9_9='99'


class CSTType70(object):
    _0_0='00'
    _4_9='49'
    _5_0='50'
    _9_9='99'


class CSTType71(object):
    _0_1='01'
    _0_2='02'
    _0_3='03'
    _0_4='04'
    _0_5='05'
    _5_1='51'
    _5_2='52'
    _5_3='53'
    _5_4='54'
    _5_5='55'


class CSTType8(object):
    _1_0='10'


class TAmb(object):
    _1='1'
    _2='2'


class TCListServ(object):
    _0_1_01='01.01'
    _0_1_02='01.02'
    _0_1_03='01.03'
    _0_1_04='01.04'
    _0_1_05='01.05'
    _0_1_06='01.06'
    _0_1_07='01.07'
    _0_1_08='01.08'
    _0_2_01='02.01'
    _0_3_02='03.02'
    _0_3_03='03.03'
    _0_3_04='03.04'
    _0_3_05='03.05'
    _0_4_01='04.01'
    _0_4_02='04.02'
    _0_4_03='04.03'
    _0_4_04='04.04'
    _0_4_05='04.05'
    _0_4_06='04.06'
    _0_4_07='04.07'
    _0_4_08='04.08'
    _0_4_09='04.09'
    _0_4_10='04.10'
    _0_4_11='04.11'
    _0_4_12='04.12'
    _0_4_13='04.13'
    _0_4_14='04.14'
    _0_4_15='04.15'
    _0_4_16='04.16'
    _0_4_17='04.17'
    _0_4_18='04.18'
    _0_4_19='04.19'
    _0_4_20='04.20'
    _0_4_21='04.21'
    _0_4_22='04.22'
    _0_4_23='04.23'
    _0_5_01='05.01'
    _0_5_02='05.02'
    _0_5_03='05.03'
    _0_5_04='05.04'
    _0_5_05='05.05'
    _0_5_06='05.06'
    _0_5_07='05.07'
    _0_5_08='05.08'
    _0_5_09='05.09'
    _0_6_01='06.01'
    _0_6_02='06.02'
    _0_6_03='06.03'
    _0_6_04='06.04'
    _0_6_05='06.05'
    _0_7_01='07.01'
    _0_7_02='07.02'
    _0_7_03='07.03'
    _0_7_04='07.04'
    _0_7_05='07.05'
    _0_7_06='07.06'
    _0_7_07='07.07'
    _0_7_08='07.08'
    _0_7_09='07.09'
    _0_7_10='07.10'
    _0_7_11='07.11'
    _0_7_12='07.12'
    _0_7_13='07.13'
    _0_7_16='07.16'
    _0_7_17='07.17'
    _0_7_18='07.18'
    _0_7_19='07.19'
    _0_7_20='07.20'
    _0_7_21='07.21'
    _0_7_22='07.22'
    _0_8_01='08.01'
    _0_8_02='08.02'
    _0_9_01='09.01'
    _0_9_02='09.02'
    _0_9_03='09.03'
    _1_0_01='10.01'
    _1_0_02='10.02'
    _1_0_03='10.03'
    _1_0_04='10.04'
    _1_0_05='10.05'
    _1_0_06='10.06'
    _1_0_07='10.07'
    _1_0_08='10.08'
    _1_0_09='10.09'
    _1_0_10='10.10'
    _1_1_01='11.01'
    _1_1_02='11.02'
    _1_1_03='11.03'
    _1_1_04='11.04'
    _1_2_01='12.01'
    _1_2_02='12.02'
    _1_2_03='12.03'
    _1_2_04='12.04'
    _1_2_05='12.05'
    _1_2_06='12.06'
    _1_2_07='12.07'
    _1_2_08='12.08'
    _1_2_09='12.09'
    _1_2_10='12.10'
    _1_2_11='12.11'
    _1_2_12='12.12'
    _1_2_13='12.13'
    _1_2_14='12.14'
    _1_2_15='12.15'
    _1_2_16='12.16'
    _1_2_17='12.17'
    _1_3_02='13.02'
    _1_3_03='13.03'
    _1_3_04='13.04'
    _1_3_05='13.05'
    _1_4_01='14.01'
    _1_4_02='14.02'
    _1_4_03='14.03'
    _1_4_04='14.04'
    _1_4_05='14.05'
    _1_4_06='14.06'
    _1_4_07='14.07'
    _1_4_08='14.08'
    _1_4_09='14.09'
    _1_4_10='14.10'
    _1_4_11='14.11'
    _1_4_12='14.12'
    _1_4_13='14.13'
    _1_5_01='15.01'
    _1_5_02='15.02'
    _1_5_03='15.03'
    _1_5_04='15.04'
    _1_5_05='15.05'
    _1_5_06='15.06'
    _1_5_07='15.07'
    _1_5_08='15.08'
    _1_5_09='15.09'
    _1_5_10='15.10'
    _1_5_11='15.11'
    _1_5_12='15.12'
    _1_5_13='15.13'
    _1_5_14='15.14'
    _1_5_15='15.15'
    _1_5_16='15.16'
    _1_5_17='15.17'
    _1_5_18='15.18'
    _1_6_01='16.01'
    _1_7_01='17.01'
    _1_7_02='17.02'
    _1_7_03='17.03'
    _1_7_04='17.04'
    _1_7_05='17.05'
    _1_7_06='17.06'
    _1_7_08='17.08'
    _1_7_09='17.09'
    _1_7_10='17.10'
    _1_7_11='17.11'
    _1_7_12='17.12'
    _1_7_13='17.13'
    _1_7_14='17.14'
    _1_7_15='17.15'
    _1_7_16='17.16'
    _1_7_17='17.17'
    _1_7_18='17.18'
    _1_7_19='17.19'
    _1_7_20='17.20'
    _1_7_21='17.21'
    _1_7_22='17.22'
    _1_7_23='17.23'
    _1_7_24='17.24'
    _1_7_25='17.25'
    _1_8_01='18.01'
    _1_9_01='19.01'
    _2_0_01='20.01'
    _2_0_02='20.02'
    _2_0_03='20.03'
    _2_1_01='21.01'
    _2_2_01='22.01'
    _2_3_01='23.01'
    _2_4_01='24.01'
    _2_5_01='25.01'
    _2_5_02='25.02'
    _2_5_03='25.03'
    _2_5_04='25.04'
    _2_6_01='26.01'
    _2_7_01='27.01'
    _2_8_01='28.01'
    _2_9_01='29.01'
    _3_0_01='30.01'
    _3_1_01='31.01'
    _3_2_01='32.01'
    _3_3_01='33.01'
    _3_4_01='34.01'
    _3_5_01='35.01'
    _3_6_01='36.01'
    _3_7_01='37.01'
    _3_8_01='38.01'
    _3_9_01='39.01'
    _4_0_01='40.01'


class TCOrgaoIBGE(object):
    _1_1='11'
    _1_2='12'
    _1_3='13'
    _1_4='14'
    _1_5='15'
    _1_6='16'
    _1_7='17'
    _2_1='21'
    _2_2='22'
    _2_3='23'
    _2_4='24'
    _2_5='25'
    _2_6='26'
    _2_7='27'
    _2_8='28'
    _2_9='29'
    _3_1='31'
    _3_2='32'
    _3_3='33'
    _3_5='35'
    _4_1='41'
    _4_2='42'
    _4_3='43'
    _5_0='50'
    _5_1='51'
    _5_2='52'
    _5_3='53'
    _9_0='90'
    _9_1='91'
    _9_2='92'


class TCodUfIBGE(object):
    _1_1='11'
    _1_2='12'
    _1_3='13'
    _1_4='14'
    _1_5='15'
    _1_6='16'
    _1_7='17'
    _2_1='21'
    _2_2='22'
    _2_3='23'
    _2_4='24'
    _2_5='25'
    _2_6='26'
    _2_7='27'
    _2_8='28'
    _2_9='29'
    _3_1='31'
    _3_2='32'
    _3_3='33'
    _3_5='35'
    _4_1='41'
    _4_2='42'
    _4_3='43'
    _5_0='50'
    _5_1='51'
    _5_2='52'
    _5_3='53'


class TFinNFe(object):
    _1='1'
    _2='2'
    _3='3'
    _4='4'


class TMod(object):
    _5_5='55'
    _6_5='65'


class TProcEmi(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'


class TTransformURI(object):
    HTTPWWWW_3ORG_2000_09XMLDSIGENVELOPEDSIGNATURE='http://www.w3.org/2000/09/xmldsig#enveloped-signature'
    HTTPWWWW_3ORGTR_2001RECXMLC_14_N_20010315='http://www.w3.org/TR/2001/REC-xml-c14n-20010315'


class TUf(object):
    AC='AC'
    AL='AL'
    AM='AM'
    AP='AP'
    BA='BA'
    CE='CE'
    DF='DF'
    ES='ES'
    GO='GO'
    MA='MA'
    MG='MG'
    MS='MS'
    MT='MT'
    PA='PA'
    PB='PB'
    PE='PE'
    PI='PI'
    PR='PR'
    RJ='RJ'
    RN='RN'
    RO='RO'
    RR='RR'
    RS='RS'
    SC='SC'
    SE='SE'
    SP='SP'
    TO='TO'
    EX='EX'


class TUfEmi(object):
    AC='AC'
    AL='AL'
    AM='AM'
    AP='AP'
    BA='BA'
    CE='CE'
    DF='DF'
    ES='ES'
    GO='GO'
    MA='MA'
    MG='MG'
    MS='MS'
    MT='MT'
    PA='PA'
    PB='PB'
    PE='PE'
    PI='PI'
    PR='PR'
    RJ='RJ'
    RN='RN'
    RO='RO'
    RR='RR'
    RS='RS'
    SC='SC'
    SE='SE'
    SP='SP'
    TO='TO'


class Torig(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'
    _6='6'
    _7='7'
    _8='8'


class VINType(object):
    R='R'
    N='N'


class cPaisType62(object):
    _1_058='1058'


class cRegTribType(object):
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'
    _6='6'


class condVeicType(object):
    _1='1'
    _2='2'
    _3='3'


class idDestType(object):
    _1='1'
    _2='2'
    _3='3'


class indEscalaType(object):
    S='S'
    N='N'


class indFinalType(object):
    _0='0'
    _1='1'


class indIEDestType(object):
    _1='1'
    _2='2'
    _9='9'


class indISSType(object):
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'
    _6='6'
    _7='7'


class indIncentivoType(object):
    _1='1'
    _2='2'


class indPagType(object):
    _0='0'
    _1='1'


class indPresType(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'
    _9='9'


class indProcType(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'
    _9='9'


class indSincType(object):
    _0='0'
    _1='1'


class indTotType(object):
    _0='0'
    _1='1'


class modBCSTType(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'


class modBCSTType13(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'


class modBCSTType22(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'


class modBCSTType26(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'


class modBCSTType30(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'


class modBCSTType34(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'


class modBCSTType36(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'


class modBCSTType40(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'


class modBCType(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'


class modBCType11(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'


class modBCType18(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'


class modBCType21(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'


class modBCType25(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'


class modBCType29(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'


class modBCType39(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'


class modBCType9(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'


class modFreteType(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _9='9'


class modType(object):
    _0_1='01'
    _0_2='02'


class modType2(object):
    _0_1='01'
    _0_4='04'


class modType3(object):
    _2_B='2B'
    _2_C='2C'
    _2_D='2D'


class motDesICMSType(object):
    _3='3'
    _9='9'
    _1_2='12'


class motDesICMSType14(object):
    _6='6'
    _7='7'
    _9='9'


class motDesICMSType16(object):
    _1='1'
    _3='3'
    _4='4'
    _5='5'
    _6='6'
    _7='7'
    _8='8'
    _9='9'
    _1_0='10'
    _1_1='11'
    _1_6='16'
    _9_0='90'


class motDesICMSType23(object):
    _3='3'
    _9='9'
    _1_2='12'


class motDesICMSType27(object):
    _3='3'
    _9='9'
    _1_2='12'


class pICMSInterType(object):
    _4_00='4.00'
    _7_00='7.00'
    _1_2_00='12.00'


class tBandType(object):
    _0_1='01'
    _0_2='02'
    _0_3='03'
    _0_4='04'
    _0_5='05'
    _0_6='06'
    _0_7='07'
    _0_8='08'
    _0_9='09'
    _9_9='99'


class tPagType(object):
    _0_1='01'
    _0_2='02'
    _0_3='03'
    _0_4='04'
    _0_5='05'
    _1_0='10'
    _1_1='11'
    _1_2='12'
    _1_3='13'
    _1_4='14'
    _1_5='15'
    _9_0='90'
    _9_9='99'


class tpArmaType(object):
    _0='0'
    _1='1'


class tpEmisType(object):
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'
    _6='6'
    _7='7'
    _9='9'


class tpImpType(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'


class tpIntegraType(object):
    _1='1'
    _2='2'


class tpIntermedioType(object):
    _1='1'
    _2='2'
    _3='3'


class tpNFType(object):
    _0='0'
    _1='1'


class tpOpType(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'


class tpRestType(object):
    _0='0'
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _9='9'


class tpViaTranspType(object):
    _1='1'
    _2='2'
    _3='3'
    _4='4'
    _5='5'
    _6='6'
    _7='7'
    _8='8'
    _9='9'
    _1_0='10'
    _1_1='11'
    _1_2='12'


class xPaisType63(object):
    BRASIL='Brasil'
    BRASIL='BRASIL'


class TNFe(GeneratedsSuper):
    """Tipo Nota Fiscal Eletrônica"""
    subclass = None
    superclass = None
    def __init__(self, infNFe=None, infNFeSupl=None, Signature=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.infNFe = infNFe
        self.infNFeSupl = infNFeSupl
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TNFe.subclass:
            return TNFe.subclass(*args_, **kwargs_)
        else:
            return TNFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infNFe(self):
        return self.infNFe
    def set_infNFe(self, infNFe):
        self.infNFe = infNFe
    def get_infNFeSupl(self):
        return self.infNFeSupl
    def set_infNFeSupl(self, infNFeSupl):
        self.infNFeSupl = infNFeSupl
    def get_Signature(self):
        return self.Signature
    def set_Signature(self, Signature):
        self.Signature = Signature
    def hasContent_(self):
        if (
            self.infNFe is not None or
            self.infNFeSupl is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='editix:', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#"  xmlns:editix="http://www.portalfiscal.inf.br/nfe"', name_='TNFe', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TNFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='editix:', name_='TNFe'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='editix:', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#"  xmlns:editix="http://www.portalfiscal.inf.br/nfe"', name_='TNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infNFe is not None:
            self.infNFe.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infNFe', pretty_print=pretty_print)
        if self.infNFeSupl is not None:
            self.infNFeSupl.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infNFeSupl', pretty_print=pretty_print)
        if self.Signature is not None:
            self.Signature.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Signature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infNFe':
            obj_ = infNFeType.factory(parent_object_=self)
            obj_.build(child_)
            self.infNFe = obj_
            obj_.original_tagname_ = 'infNFe'
        elif nodeName_ == 'infNFeSupl':
            obj_ = infNFeSuplType.factory(parent_object_=self)
            obj_.build(child_)
            self.infNFeSupl = obj_
            obj_.original_tagname_ = 'infNFeSupl'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory(parent_object_=self)
            obj_.build(child_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class TNFe


class TProtNFe(GeneratedsSuper):
    """Tipo Protocolo de status resultado do processamento da NF-e"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, infProt=None, Signature=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.versao = _cast(None, versao)
        self.infProt = infProt
        self.Signature = Signature
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TProtNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TProtNFe.subclass:
            return TProtNFe.subclass(*args_, **kwargs_)
        else:
            return TProtNFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infProt(self):
        return self.infProt
    def set_infProt(self, infProt):
        self.infProt = infProt
    def get_Signature(self):
        return self.Signature
    def set_Signature(self, Signature):
        self.Signature = Signature
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [[u'^4\\.00$']]
    def hasContent_(self):
        if (
            self.infProt is not None or
            self.Signature is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='editix:', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#"  xmlns:editix="http://www.portalfiscal.inf.br/nfe"', name_='TProtNFe', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TProtNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TProtNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TProtNFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='editix:', name_='TProtNFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespaceprefix_='editix:', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#"  xmlns:editix="http://www.portalfiscal.inf.br/nfe"', name_='TProtNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infProt is not None:
            self.infProt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infProt', pretty_print=pretty_print)
        if self.Signature is not None:
            self.Signature.export(outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='Signature', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infProt':
            obj_ = infProtType.factory(parent_object_=self)
            obj_.build(child_)
            self.infProt = obj_
            obj_.original_tagname_ = 'infProt'
        elif nodeName_ == 'Signature':
            obj_ = SignatureType.factory(parent_object_=self)
            obj_.build(child_)
            self.Signature = obj_
            obj_.original_tagname_ = 'Signature'
# end class TProtNFe


class TEnviNFe(GeneratedsSuper):
    """Tipo Pedido de Concessão de Autorização da Nota Fiscal Eletrônica"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, idLote=None, indSinc=None, NFe=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.versao = _cast(None, versao)
        self.idLote = idLote
        self.validate_TIdLote(self.idLote)
        self.indSinc = indSinc
        self.validate_indSincType(self.indSinc)
        if NFe is None:
            self.NFe = []
        else:
            self.NFe = NFe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEnviNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEnviNFe.subclass:
            return TEnviNFe.subclass(*args_, **kwargs_)
        else:
            return TEnviNFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_idLote(self):
        return self.idLote
    def set_idLote(self, idLote):
        self.idLote = idLote
    def get_indSinc(self):
        return self.indSinc
    def set_indSinc(self, indSinc):
        self.indSinc = indSinc
    def get_NFe(self):
        return self.NFe
    def set_NFe(self, NFe):
        self.NFe = NFe
    def add_NFe(self, value):
        self.NFe.append(value)
    def add_NFe(self, value):
        self.NFe.append(value)
    def insert_NFe_at(self, index, value):
        self.NFe.insert(index, value)
    def replace_NFe_at(self, index, value):
        self.NFe[index] = value
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def validate_TIdLote(self, value):
        # Validate type TIdLote, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TIdLote_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TIdLote_patterns_, ))
    validate_TIdLote_patterns_ = [[u'^[0-9]{1,15}$']]
    def validate_indSincType(self, value):
        # Validate type indSincType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indSincType' % {"value" : value.encode("utf-8")} )
    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [[u'^4\\.00$']]
    def hasContent_(self):
        if (
            self.idLote is not None or
            self.indSinc is not None or
            self.NFe
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TEnviNFe', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEnviNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEnviNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEnviNFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='editix:', name_='TEnviNFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TEnviNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.idLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidLote>%s</%sidLote>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.idLote), input_name='idLote')), namespaceprefix_ , eol_))
        if self.indSinc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindSinc>%s</%sindSinc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indSinc), input_name='indSinc')), namespaceprefix_ , eol_))
        for NFe_ in self.NFe:
            NFe_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NFe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'idLote':
            idLote_ = child_.text
            idLote_ = self.gds_validate_string(idLote_, node, 'idLote')
            self.idLote = idLote_
            # validate type TIdLote
            self.validate_TIdLote(self.idLote)
        elif nodeName_ == 'indSinc':
            indSinc_ = child_.text
            indSinc_ = self.gds_validate_string(indSinc_, node, 'indSinc')
            self.indSinc = indSinc_
            # validate type indSincType
            self.validate_indSincType(self.indSinc)
        elif nodeName_ == 'NFe':
            obj_ = TNFe.factory(parent_object_=self)
            obj_.build(child_)
            self.NFe.append(obj_)
            obj_.original_tagname_ = 'NFe'
# end class TEnviNFe


class TRetEnviNFe(GeneratedsSuper):
    """Tipo Retorno do Pedido de Autorização da Nota Fiscal Eletrônica"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, tpAmb=None, verAplic=None, cStat=None, xMotivo=None, cUF=None, dhRecbto=None, infRec=None, protNFe=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.versao = _cast(None, versao)
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.cStat = cStat
        self.validate_TStat(self.cStat)
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.dhRecbto = dhRecbto
        self.validate_TDateTimeUTC(self.dhRecbto)
        self.infRec = infRec
        self.protNFe = protNFe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRetEnviNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRetEnviNFe.subclass:
            return TRetEnviNFe.subclass(*args_, **kwargs_)
        else:
            return TRetEnviNFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpAmb(self):
        return self.tpAmb
    def set_tpAmb(self, tpAmb):
        self.tpAmb = tpAmb
    def get_verAplic(self):
        return self.verAplic
    def set_verAplic(self, verAplic):
        self.verAplic = verAplic
    def get_cStat(self):
        return self.cStat
    def set_cStat(self, cStat):
        self.cStat = cStat
    def get_xMotivo(self):
        return self.xMotivo
    def set_xMotivo(self, xMotivo):
        self.xMotivo = xMotivo
    def get_cUF(self):
        return self.cUF
    def set_cUF(self, cUF):
        self.cUF = cUF
    def get_dhRecbto(self):
        return self.dhRecbto
    def set_dhRecbto(self, dhRecbto):
        self.dhRecbto = dhRecbto
    def get_infRec(self):
        return self.infRec
    def set_infRec(self, infRec):
        self.infRec = infRec
    def get_protNFe(self):
        return self.protNFe
    def set_protNFe(self, protNFe):
        self.protNFe = protNFe
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def validate_TAmb(self, value):
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TAmb' % {"value" : value.encode("utf-8")} )
    def validate_TVerAplic(self, value):
        # Validate type TVerAplic, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TVerAplic' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TVerAplic' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerAplic_patterns_, ))
    validate_TVerAplic_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TStat(self, value):
        # Validate type TStat, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TStat' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TStat_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TStat_patterns_, ))
    validate_TStat_patterns_ = [[u'^[0-9]{3}$']]
    def validate_TMotivo(self, value):
        # Validate type TMotivo, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TMotivo' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TMotivo' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TMotivo_patterns_, ))
    validate_TMotivo_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : value.encode("utf-8")} )
    def validate_TDateTimeUTC(self, value):
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDateTimeUTC_patterns_, ))
    validate_TDateTimeUTC_patterns_ = [[u'^(((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))T(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]|10|11):00|([\\+](12):00))$']]
    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [[u'^4\\.00$']]
    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.verAplic is not None or
            self.cStat is not None or
            self.xMotivo is not None or
            self.cUF is not None or
            self.dhRecbto is not None or
            self.infRec is not None or
            self.protNFe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TRetEnviNFe', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRetEnviNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TRetEnviNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TRetEnviNFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='editix:', name_='TRetEnviNFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TRetEnviNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespaceprefix_ , eol_))
        if self.verAplic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverAplic>%s</%sverAplic>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), namespaceprefix_ , eol_))
        if self.cStat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scStat>%s</%scStat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), namespaceprefix_ , eol_))
        if self.xMotivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMotivo>%s</%sxMotivo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), namespaceprefix_ , eol_))
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespaceprefix_ , eol_))
        if self.dhRecbto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhRecbto>%s</%sdhRecbto>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhRecbto), input_name='dhRecbto')), namespaceprefix_ , eol_))
        if self.infRec is not None:
            self.infRec.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infRec', pretty_print=pretty_print)
        if self.protNFe is not None:
            self.protNFe.export(outfile, level, namespaceprefix_, namespacedef_='', name_='protNFe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'verAplic':
            verAplic_ = child_.text
            verAplic_ = self.gds_validate_string(verAplic_, node, 'verAplic')
            self.verAplic = verAplic_
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'cStat':
            cStat_ = child_.text
            cStat_ = self.gds_validate_string(cStat_, node, 'cStat')
            self.cStat = cStat_
            # validate type TStat
            self.validate_TStat(self.cStat)
        elif nodeName_ == 'xMotivo':
            xMotivo_ = child_.text
            xMotivo_ = self.gds_validate_string(xMotivo_, node, 'xMotivo')
            self.xMotivo = xMotivo_
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
        elif nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'dhRecbto':
            dhRecbto_ = child_.text
            dhRecbto_ = self.gds_validate_string(dhRecbto_, node, 'dhRecbto')
            self.dhRecbto = dhRecbto_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhRecbto)
        elif nodeName_ == 'infRec':
            obj_ = infRecType.factory(parent_object_=self)
            obj_.build(child_)
            self.infRec = obj_
            obj_.original_tagname_ = 'infRec'
        elif nodeName_ == 'protNFe':
            obj_ = TProtNFe.factory(parent_object_=self)
            obj_.build(child_)
            self.protNFe = obj_
            obj_.original_tagname_ = 'protNFe'
# end class TRetEnviNFe


class TConsReciNFe(GeneratedsSuper):
    """Tipo Pedido de Consulta do Recido do Lote de Notas Fiscais
    Eletrônicas"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, tpAmb=None, nRec=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.versao = _cast(None, versao)
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.nRec = nRec
        self.validate_TRec(self.nRec)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TConsReciNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TConsReciNFe.subclass:
            return TConsReciNFe.subclass(*args_, **kwargs_)
        else:
            return TConsReciNFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpAmb(self):
        return self.tpAmb
    def set_tpAmb(self, tpAmb):
        self.tpAmb = tpAmb
    def get_nRec(self):
        return self.nRec
    def set_nRec(self, nRec):
        self.nRec = nRec
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def validate_TAmb(self, value):
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TAmb' % {"value" : value.encode("utf-8")} )
    def validate_TRec(self, value):
        # Validate type TRec, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TRec' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TRec_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TRec_patterns_, ))
    validate_TRec_patterns_ = [[u'^[0-9]{15}$']]
    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [[u'^4\\.00$']]
    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.nRec is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TConsReciNFe', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TConsReciNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TConsReciNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TConsReciNFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='editix:', name_='TConsReciNFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TConsReciNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespaceprefix_ , eol_))
        if self.nRec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snRec>%s</%snRec>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nRec), input_name='nRec')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'nRec':
            nRec_ = child_.text
            nRec_ = self.gds_validate_string(nRec_, node, 'nRec')
            self.nRec = nRec_
            # validate type TRec
            self.validate_TRec(self.nRec)
# end class TConsReciNFe


class TRetConsReciNFe(GeneratedsSuper):
    """Tipo Retorno do Pedido de Consulta do Recido do Lote de Notas
    Fiscais Eletrônicas"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, tpAmb=None, verAplic=None, nRec=None, cStat=None, xMotivo=None, cUF=None, dhRecbto=None, cMsg=None, xMsg=None, protNFe=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.versao = _cast(None, versao)
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.nRec = nRec
        self.validate_TRec(self.nRec)
        self.cStat = cStat
        self.validate_TStat(self.cStat)
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.dhRecbto = dhRecbto
        self.validate_TDateTimeUTC(self.dhRecbto)
        self.cMsg = cMsg
        self.validate_cMsgType(self.cMsg)
        self.xMsg = xMsg
        self.validate_xMsgType(self.xMsg)
        if protNFe is None:
            self.protNFe = []
        else:
            self.protNFe = protNFe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TRetConsReciNFe)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TRetConsReciNFe.subclass:
            return TRetConsReciNFe.subclass(*args_, **kwargs_)
        else:
            return TRetConsReciNFe(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpAmb(self):
        return self.tpAmb
    def set_tpAmb(self, tpAmb):
        self.tpAmb = tpAmb
    def get_verAplic(self):
        return self.verAplic
    def set_verAplic(self, verAplic):
        self.verAplic = verAplic
    def get_nRec(self):
        return self.nRec
    def set_nRec(self, nRec):
        self.nRec = nRec
    def get_cStat(self):
        return self.cStat
    def set_cStat(self, cStat):
        self.cStat = cStat
    def get_xMotivo(self):
        return self.xMotivo
    def set_xMotivo(self, xMotivo):
        self.xMotivo = xMotivo
    def get_cUF(self):
        return self.cUF
    def set_cUF(self, cUF):
        self.cUF = cUF
    def get_dhRecbto(self):
        return self.dhRecbto
    def set_dhRecbto(self, dhRecbto):
        self.dhRecbto = dhRecbto
    def get_cMsg(self):
        return self.cMsg
    def set_cMsg(self, cMsg):
        self.cMsg = cMsg
    def get_xMsg(self):
        return self.xMsg
    def set_xMsg(self, xMsg):
        self.xMsg = xMsg
    def get_protNFe(self):
        return self.protNFe
    def set_protNFe(self, protNFe):
        self.protNFe = protNFe
    def add_protNFe(self, value):
        self.protNFe.append(value)
    def add_protNFe(self, value):
        self.protNFe.append(value)
    def insert_protNFe_at(self, index, value):
        self.protNFe.insert(index, value)
    def replace_protNFe_at(self, index, value):
        self.protNFe[index] = value
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def validate_TAmb(self, value):
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TAmb' % {"value" : value.encode("utf-8")} )
    def validate_TVerAplic(self, value):
        # Validate type TVerAplic, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TVerAplic' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TVerAplic' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerAplic_patterns_, ))
    validate_TVerAplic_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TRec(self, value):
        # Validate type TRec, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TRec' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TRec_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TRec_patterns_, ))
    validate_TRec_patterns_ = [[u'^[0-9]{15}$']]
    def validate_TStat(self, value):
        # Validate type TStat, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TStat' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TStat_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TStat_patterns_, ))
    validate_TStat_patterns_ = [[u'^[0-9]{3}$']]
    def validate_TMotivo(self, value):
        # Validate type TMotivo, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TMotivo' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TMotivo' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TMotivo_patterns_, ))
    validate_TMotivo_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : value.encode("utf-8")} )
    def validate_TDateTimeUTC(self, value):
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDateTimeUTC_patterns_, ))
    validate_TDateTimeUTC_patterns_ = [[u'^(((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))T(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]|10|11):00|([\\+](12):00))$']]
    def validate_cMsgType(self, value):
        # Validate type cMsgType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cMsgType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cMsgType_patterns_, ))
    validate_cMsgType_patterns_ = [[u'^[0-9]{1,4}$']]
    def validate_xMsgType(self, value):
        # Validate type xMsgType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 200:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMsgType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMsgType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMsgType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMsgType_patterns_, ))
    validate_xMsgType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [[u'^4\\.00$']]
    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.verAplic is not None or
            self.nRec is not None or
            self.cStat is not None or
            self.xMotivo is not None or
            self.cUF is not None or
            self.dhRecbto is not None or
            self.cMsg is not None or
            self.xMsg is not None or
            self.protNFe
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TRetConsReciNFe', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TRetConsReciNFe')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TRetConsReciNFe')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TRetConsReciNFe', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='editix:', name_='TRetConsReciNFe'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TRetConsReciNFe', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespaceprefix_ , eol_))
        if self.verAplic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverAplic>%s</%sverAplic>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), namespaceprefix_ , eol_))
        if self.nRec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snRec>%s</%snRec>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nRec), input_name='nRec')), namespaceprefix_ , eol_))
        if self.cStat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scStat>%s</%scStat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), namespaceprefix_ , eol_))
        if self.xMotivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMotivo>%s</%sxMotivo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), namespaceprefix_ , eol_))
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespaceprefix_ , eol_))
        if self.dhRecbto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhRecbto>%s</%sdhRecbto>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhRecbto), input_name='dhRecbto')), namespaceprefix_ , eol_))
        if self.cMsg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMsg>%s</%scMsg>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMsg), input_name='cMsg')), namespaceprefix_ , eol_))
        if self.xMsg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMsg>%s</%sxMsg>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMsg), input_name='xMsg')), namespaceprefix_ , eol_))
        for protNFe_ in self.protNFe:
            protNFe_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='protNFe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'verAplic':
            verAplic_ = child_.text
            verAplic_ = self.gds_validate_string(verAplic_, node, 'verAplic')
            self.verAplic = verAplic_
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'nRec':
            nRec_ = child_.text
            nRec_ = self.gds_validate_string(nRec_, node, 'nRec')
            self.nRec = nRec_
            # validate type TRec
            self.validate_TRec(self.nRec)
        elif nodeName_ == 'cStat':
            cStat_ = child_.text
            cStat_ = self.gds_validate_string(cStat_, node, 'cStat')
            self.cStat = cStat_
            # validate type TStat
            self.validate_TStat(self.cStat)
        elif nodeName_ == 'xMotivo':
            xMotivo_ = child_.text
            xMotivo_ = self.gds_validate_string(xMotivo_, node, 'xMotivo')
            self.xMotivo = xMotivo_
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
        elif nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'dhRecbto':
            dhRecbto_ = child_.text
            dhRecbto_ = self.gds_validate_string(dhRecbto_, node, 'dhRecbto')
            self.dhRecbto = dhRecbto_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhRecbto)
        elif nodeName_ == 'cMsg':
            cMsg_ = child_.text
            cMsg_ = self.gds_validate_string(cMsg_, node, 'cMsg')
            self.cMsg = cMsg_
            # validate type cMsgType
            self.validate_cMsgType(self.cMsg)
        elif nodeName_ == 'xMsg':
            xMsg_ = child_.text
            xMsg_ = self.gds_validate_string(xMsg_, node, 'xMsg')
            self.xMsg = xMsg_
            # validate type xMsgType
            self.validate_xMsgType(self.xMsg)
        elif nodeName_ == 'protNFe':
            obj_ = TProtNFe.factory(parent_object_=self)
            obj_.build(child_)
            self.protNFe.append(obj_)
            obj_.original_tagname_ = 'protNFe'
# end class TRetConsReciNFe


class TNfeProc(GeneratedsSuper):
    """Tipo da NF-e processada"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, NFe=None, protNFe=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.versao = _cast(None, versao)
        self.NFe = NFe
        self.protNFe = protNFe
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TNfeProc)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TNfeProc.subclass:
            return TNfeProc.subclass(*args_, **kwargs_)
        else:
            return TNfeProc(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NFe(self):
        return self.NFe
    def set_NFe(self, NFe):
        self.NFe = NFe
    def get_protNFe(self):
        return self.protNFe
    def set_protNFe(self, protNFe):
        self.protNFe = protNFe
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [[u'^4\\.00$']]
    def hasContent_(self):
        if (
            self.NFe is not None or
            self.protNFe is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TNfeProc', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TNfeProc')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TNfeProc')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TNfeProc', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='editix:', name_='TNfeProc'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
    def exportChildren(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TNfeProc', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.NFe is not None:
            self.NFe.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NFe', pretty_print=pretty_print)
        if self.protNFe is not None:
            self.protNFe.export(outfile, level, namespaceprefix_, namespacedef_='', name_='protNFe', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'NFe':
            obj_ = TNFe.factory(parent_object_=self)
            obj_.build(child_)
            self.NFe = obj_
            obj_.original_tagname_ = 'NFe'
        elif nodeName_ == 'protNFe':
            obj_ = TProtNFe.factory(parent_object_=self)
            obj_.build(child_)
            self.protNFe = obj_
            obj_.original_tagname_ = 'protNFe'
# end class TNfeProc


class TEndereco(GeneratedsSuper):
    """Tipo Dados do Endereço // 24/10/08 - tamanho mínimo"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, UF=None, CEP=None, cPais=None, xPais=None, fone=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.xLgr = xLgr
        self.validate_xLgrType(self.xLgr)
        self.nro = nro
        self.validate_nroType(self.nro)
        self.xCpl = xCpl
        self.validate_xCplType(self.xCpl)
        self.xBairro = xBairro
        self.validate_xBairroType(self.xBairro)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.xMun = xMun
        self.validate_xMunType53(self.xMun)
        self.UF = UF
        self.validate_TUf(self.UF)
        self.CEP = CEP
        self.validate_CEPType(self.CEP)
        self.cPais = cPais
        self.validate_cPaisType54(self.cPais)
        self.xPais = xPais
        self.validate_xPaisType(self.xPais)
        self.fone = fone
        self.validate_foneType55(self.fone)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEndereco)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEndereco.subclass:
            return TEndereco.subclass(*args_, **kwargs_)
        else:
            return TEndereco(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xLgr(self):
        return self.xLgr
    def set_xLgr(self, xLgr):
        self.xLgr = xLgr
    def get_nro(self):
        return self.nro
    def set_nro(self, nro):
        self.nro = nro
    def get_xCpl(self):
        return self.xCpl
    def set_xCpl(self, xCpl):
        self.xCpl = xCpl
    def get_xBairro(self):
        return self.xBairro
    def set_xBairro(self, xBairro):
        self.xBairro = xBairro
    def get_cMun(self):
        return self.cMun
    def set_cMun(self, cMun):
        self.cMun = cMun
    def get_xMun(self):
        return self.xMun
    def set_xMun(self, xMun):
        self.xMun = xMun
    def get_UF(self):
        return self.UF
    def set_UF(self, UF):
        self.UF = UF
    def get_CEP(self):
        return self.CEP
    def set_CEP(self, CEP):
        self.CEP = CEP
    def get_cPais(self):
        return self.cPais
    def set_cPais(self, cPais):
        self.cPais = cPais
    def get_xPais(self):
        return self.xPais
    def set_xPais(self, xPais):
        self.xPais = xPais
    def get_fone(self):
        return self.fone
    def set_fone(self, fone):
        self.fone = fone
    def validate_xLgrType(self, value):
        # Validate type xLgrType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLgrType' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLgrType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLgrType_patterns_, ))
    validate_xLgrType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_nroType(self, value):
        # Validate type nroType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nroType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nroType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nroType_patterns_, ))
    validate_nroType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_xCplType(self, value):
        # Validate type xCplType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xCplType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xCplType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xCplType_patterns_, ))
    validate_xCplType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_xBairroType(self, value):
        # Validate type xBairroType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xBairroType' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xBairroType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xBairroType_patterns_, ))
    validate_xBairroType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [[u'^[0-9]{7}$']]
    def validate_xMunType53(self, value):
        # Validate type xMunType53, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunType53' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunType53' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType53_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunType53_patterns_, ))
    validate_xMunType53_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def validate_CEPType(self, value):
        # Validate type CEPType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CEPType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CEPType_patterns_, ))
    validate_CEPType_patterns_ = [[u'^[0-9]{8}$']]
    def validate_cPaisType54(self, value):
        # Validate type cPaisType54, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cPaisType54_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cPaisType54_patterns_, ))
    validate_cPaisType54_patterns_ = [[u'^[0-9]{1,4}$']]
    def validate_xPaisType(self, value):
        # Validate type xPaisType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xPaisType' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xPaisType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xPaisType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xPaisType_patterns_, ))
    validate_xPaisType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_foneType55(self, value):
        # Validate type foneType55, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_foneType55_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_foneType55_patterns_, ))
    validate_foneType55_patterns_ = [[u'^[0-9]{6,14}$']]
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None or
            self.CEP is not None or
            self.cPais is not None or
            self.xPais is not None or
            self.fone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TEndereco', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEndereco')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEndereco')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEndereco', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='editix:', name_='TEndereco'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TEndereco', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxLgr>%s</%sxLgr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), namespaceprefix_ , eol_))
        if self.nro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snro>%s</%snro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), namespaceprefix_ , eol_))
        if self.xCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCpl>%s</%sxCpl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), namespaceprefix_ , eol_))
        if self.xBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxBairro>%s</%sxBairro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), namespaceprefix_ , eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespaceprefix_ , eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMun>%s</%sxMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), namespaceprefix_ , eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespaceprefix_ , eol_))
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEP>%s</%sCEP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), namespaceprefix_ , eol_))
        if self.cPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scPais>%s</%scPais>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cPais), input_name='cPais')), namespaceprefix_ , eol_))
        if self.xPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxPais>%s</%sxPais>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xPais), input_name='xPais')), namespaceprefix_ , eol_))
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            xLgr_ = child_.text
            xLgr_ = self.gds_validate_string(xLgr_, node, 'xLgr')
            self.xLgr = xLgr_
            # validate type xLgrType
            self.validate_xLgrType(self.xLgr)
        elif nodeName_ == 'nro':
            nro_ = child_.text
            nro_ = self.gds_validate_string(nro_, node, 'nro')
            self.nro = nro_
            # validate type nroType
            self.validate_nroType(self.nro)
        elif nodeName_ == 'xCpl':
            xCpl_ = child_.text
            xCpl_ = self.gds_validate_string(xCpl_, node, 'xCpl')
            self.xCpl = xCpl_
            # validate type xCplType
            self.validate_xCplType(self.xCpl)
        elif nodeName_ == 'xBairro':
            xBairro_ = child_.text
            xBairro_ = self.gds_validate_string(xBairro_, node, 'xBairro')
            self.xBairro = xBairro_
            # validate type xBairroType
            self.validate_xBairroType(self.xBairro)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType53
            self.validate_xMunType53(self.xMun)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
            # validate type CEPType
            self.validate_CEPType(self.CEP)
        elif nodeName_ == 'cPais':
            cPais_ = child_.text
            cPais_ = self.gds_validate_string(cPais_, node, 'cPais')
            self.cPais = cPais_
            # validate type cPaisType54
            self.validate_cPaisType54(self.cPais)
        elif nodeName_ == 'xPais':
            xPais_ = child_.text
            xPais_ = self.gds_validate_string(xPais_, node, 'xPais')
            self.xPais = xPais_
            # validate type xPaisType
            self.validate_xPaisType(self.xPais)
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
            # validate type foneType55
            self.validate_foneType55(self.fone)
# end class TEndereco


class TEnderEmi(GeneratedsSuper):
    """Tipo Dados do Endereço do Emitente // 24/10/08 - desmembrado /
    tamanho mínimo"""
    subclass = None
    superclass = None
    def __init__(self, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, UF=None, CEP=None, cPais=None, xPais=None, fone=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.xLgr = xLgr
        self.validate_xLgrType56(self.xLgr)
        self.nro = nro
        self.validate_nroType57(self.nro)
        self.xCpl = xCpl
        self.validate_xCplType58(self.xCpl)
        self.xBairro = xBairro
        self.validate_xBairroType59(self.xBairro)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.xMun = xMun
        self.validate_xMunType60(self.xMun)
        self.UF = UF
        self.validate_TUfEmi(self.UF)
        self.CEP = CEP
        self.validate_CEPType61(self.CEP)
        self.cPais = cPais
        self.validate_cPaisType62(self.cPais)
        self.xPais = xPais
        self.validate_xPaisType63(self.xPais)
        self.fone = fone
        self.validate_foneType64(self.fone)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TEnderEmi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TEnderEmi.subclass:
            return TEnderEmi.subclass(*args_, **kwargs_)
        else:
            return TEnderEmi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xLgr(self):
        return self.xLgr
    def set_xLgr(self, xLgr):
        self.xLgr = xLgr
    def get_nro(self):
        return self.nro
    def set_nro(self, nro):
        self.nro = nro
    def get_xCpl(self):
        return self.xCpl
    def set_xCpl(self, xCpl):
        self.xCpl = xCpl
    def get_xBairro(self):
        return self.xBairro
    def set_xBairro(self, xBairro):
        self.xBairro = xBairro
    def get_cMun(self):
        return self.cMun
    def set_cMun(self, cMun):
        self.cMun = cMun
    def get_xMun(self):
        return self.xMun
    def set_xMun(self, xMun):
        self.xMun = xMun
    def get_UF(self):
        return self.UF
    def set_UF(self, UF):
        self.UF = UF
    def get_CEP(self):
        return self.CEP
    def set_CEP(self, CEP):
        self.CEP = CEP
    def get_cPais(self):
        return self.cPais
    def set_cPais(self, cPais):
        self.cPais = cPais
    def get_xPais(self):
        return self.xPais
    def set_xPais(self, xPais):
        self.xPais = xPais
    def get_fone(self):
        return self.fone
    def set_fone(self, fone):
        self.fone = fone
    def validate_xLgrType56(self, value):
        # Validate type xLgrType56, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLgrType56' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLgrType56' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType56_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLgrType56_patterns_, ))
    validate_xLgrType56_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_nroType57(self, value):
        # Validate type nroType57, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nroType57' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nroType57' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType57_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nroType57_patterns_, ))
    validate_nroType57_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_xCplType58(self, value):
        # Validate type xCplType58, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xCplType58' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xCplType58' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType58_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xCplType58_patterns_, ))
    validate_xCplType58_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_xBairroType59(self, value):
        # Validate type xBairroType59, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xBairroType59' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xBairroType59' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType59_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xBairroType59_patterns_, ))
    validate_xBairroType59_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [[u'^[0-9]{7}$']]
    def validate_xMunType60(self, value):
        # Validate type xMunType60, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunType60' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunType60' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType60_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunType60_patterns_, ))
    validate_xMunType60_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TUfEmi(self, value):
        # Validate type TUfEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUfEmi' % {"value" : value.encode("utf-8")} )
    def validate_CEPType61(self, value):
        # Validate type CEPType61, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CEPType61_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CEPType61_patterns_, ))
    validate_CEPType61_patterns_ = [[u'^[0-9]{8}$']]
    def validate_cPaisType62(self, value):
        # Validate type cPaisType62, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1058']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cPaisType62' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cPaisType62_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cPaisType62_patterns_, ))
    validate_cPaisType62_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_xPaisType63(self, value):
        # Validate type xPaisType63, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Brasil', 'BRASIL']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on xPaisType63' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xPaisType63_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xPaisType63_patterns_, ))
    validate_xPaisType63_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_foneType64(self, value):
        # Validate type foneType64, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_foneType64_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_foneType64_patterns_, ))
    validate_foneType64_patterns_ = [[u'^[0-9]{6,14}$']]
    def hasContent_(self):
        if (
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None or
            self.CEP is not None or
            self.cPais is not None or
            self.xPais is not None or
            self.fone is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TEnderEmi', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TEnderEmi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TEnderEmi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TEnderEmi', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='editix:', name_='TEnderEmi'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TEnderEmi', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xLgr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxLgr>%s</%sxLgr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), namespaceprefix_ , eol_))
        if self.nro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snro>%s</%snro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), namespaceprefix_ , eol_))
        if self.xCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCpl>%s</%sxCpl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), namespaceprefix_ , eol_))
        if self.xBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxBairro>%s</%sxBairro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), namespaceprefix_ , eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespaceprefix_ , eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMun>%s</%sxMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), namespaceprefix_ , eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespaceprefix_ , eol_))
        if self.CEP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEP>%s</%sCEP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CEP), input_name='CEP')), namespaceprefix_ , eol_))
        if self.cPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scPais>%s</%scPais>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cPais), input_name='cPais')), namespaceprefix_ , eol_))
        if self.xPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxPais>%s</%sxPais>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xPais), input_name='xPais')), namespaceprefix_ , eol_))
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xLgr':
            xLgr_ = child_.text
            xLgr_ = self.gds_validate_string(xLgr_, node, 'xLgr')
            self.xLgr = xLgr_
            # validate type xLgrType56
            self.validate_xLgrType56(self.xLgr)
        elif nodeName_ == 'nro':
            nro_ = child_.text
            nro_ = self.gds_validate_string(nro_, node, 'nro')
            self.nro = nro_
            # validate type nroType57
            self.validate_nroType57(self.nro)
        elif nodeName_ == 'xCpl':
            xCpl_ = child_.text
            xCpl_ = self.gds_validate_string(xCpl_, node, 'xCpl')
            self.xCpl = xCpl_
            # validate type xCplType58
            self.validate_xCplType58(self.xCpl)
        elif nodeName_ == 'xBairro':
            xBairro_ = child_.text
            xBairro_ = self.gds_validate_string(xBairro_, node, 'xBairro')
            self.xBairro = xBairro_
            # validate type xBairroType59
            self.validate_xBairroType59(self.xBairro)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType60
            self.validate_xMunType60(self.xMun)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUfEmi
            self.validate_TUfEmi(self.UF)
        elif nodeName_ == 'CEP':
            CEP_ = child_.text
            CEP_ = self.gds_validate_string(CEP_, node, 'CEP')
            self.CEP = CEP_
            # validate type CEPType61
            self.validate_CEPType61(self.CEP)
        elif nodeName_ == 'cPais':
            cPais_ = child_.text
            cPais_ = self.gds_validate_string(cPais_, node, 'cPais')
            self.cPais = cPais_
            # validate type cPaisType62
            self.validate_cPaisType62(self.cPais)
        elif nodeName_ == 'xPais':
            xPais_ = child_.text
            xPais_ = self.gds_validate_string(xPais_, node, 'xPais')
            self.xPais = xPais_
            # validate type xPaisType63
            self.validate_xPaisType63(self.xPais)
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
            # validate type foneType64
            self.validate_foneType64(self.fone)
# end class TEnderEmi


class TLocal(GeneratedsSuper):
    """Tipo Dados do Local de Retirada ou Entrega // 24/10/08 - tamanho
    mínimo // v2.0"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, xLgr=None, nro=None, xCpl=None, xBairro=None, cMun=None, xMun=None, UF=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CNPJ = CNPJ
        self.validate_TCnpjOpc(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.xLgr = xLgr
        self.validate_xLgrType65(self.xLgr)
        self.nro = nro
        self.validate_nroType66(self.nro)
        self.xCpl = xCpl
        self.validate_xCplType67(self.xCpl)
        self.xBairro = xBairro
        self.validate_xBairroType68(self.xBairro)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.xMun = xMun
        self.validate_xMunType69(self.xMun)
        self.UF = UF
        self.validate_TUf(self.UF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TLocal)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TLocal.subclass:
            return TLocal.subclass(*args_, **kwargs_)
        else:
            return TLocal(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_xLgr(self):
        return self.xLgr
    def set_xLgr(self, xLgr):
        self.xLgr = xLgr
    def get_nro(self):
        return self.nro
    def set_nro(self, nro):
        self.nro = nro
    def get_xCpl(self):
        return self.xCpl
    def set_xCpl(self, xCpl):
        self.xCpl = xCpl
    def get_xBairro(self):
        return self.xBairro
    def set_xBairro(self, xBairro):
        self.xBairro = xBairro
    def get_cMun(self):
        return self.cMun
    def set_cMun(self, cMun):
        self.cMun = cMun
    def get_xMun(self):
        return self.xMun
    def set_xMun(self, xMun):
        self.xMun = xMun
    def get_UF(self):
        return self.UF
    def set_UF(self, UF):
        self.UF = UF
    def validate_TCnpjOpc(self, value):
        # Validate type TCnpjOpc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpjOpc' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpjOpc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpjOpc_patterns_, ))
    validate_TCnpjOpc_patterns_ = [[u'^[0-9]{0}|[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [[u'^[0-9]{11}$']]
    def validate_xLgrType65(self, value):
        # Validate type xLgrType65, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLgrType65' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLgrType65' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLgrType65_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLgrType65_patterns_, ))
    validate_xLgrType65_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_nroType66(self, value):
        # Validate type nroType66, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nroType66' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nroType66' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nroType66_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nroType66_patterns_, ))
    validate_nroType66_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_xCplType67(self, value):
        # Validate type xCplType67, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xCplType67' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xCplType67' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xCplType67_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xCplType67_patterns_, ))
    validate_xCplType67_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_xBairroType68(self, value):
        # Validate type xBairroType68, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xBairroType68' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xBairroType68' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xBairroType68_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xBairroType68_patterns_, ))
    validate_xBairroType68_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [[u'^[0-9]{7}$']]
    def validate_xMunType69(self, value):
        # Validate type xMunType69, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunType69' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunType69' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType69_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunType69_patterns_, ))
    validate_xMunType69_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.xLgr is not None or
            self.nro is not None or
            self.xCpl is not None or
            self.xBairro is not None or
            self.cMun is not None or
            self.xMun is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TLocal', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TLocal')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TLocal')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TLocal', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='editix:', name_='TLocal'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TLocal', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.xLgr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxLgr>%s</%sxLgr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xLgr), input_name='xLgr')), namespaceprefix_ , eol_))
        if self.nro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snro>%s</%snro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nro), input_name='nro')), namespaceprefix_ , eol_))
        if self.xCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCpl>%s</%sxCpl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCpl), input_name='xCpl')), namespaceprefix_ , eol_))
        if self.xBairro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxBairro>%s</%sxBairro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xBairro), input_name='xBairro')), namespaceprefix_ , eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespaceprefix_ , eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMun>%s</%sxMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), namespaceprefix_ , eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpjOpc
            self.validate_TCnpjOpc(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'xLgr':
            xLgr_ = child_.text
            xLgr_ = self.gds_validate_string(xLgr_, node, 'xLgr')
            self.xLgr = xLgr_
            # validate type xLgrType65
            self.validate_xLgrType65(self.xLgr)
        elif nodeName_ == 'nro':
            nro_ = child_.text
            nro_ = self.gds_validate_string(nro_, node, 'nro')
            self.nro = nro_
            # validate type nroType66
            self.validate_nroType66(self.nro)
        elif nodeName_ == 'xCpl':
            xCpl_ = child_.text
            xCpl_ = self.gds_validate_string(xCpl_, node, 'xCpl')
            self.xCpl = xCpl_
            # validate type xCplType67
            self.validate_xCplType67(self.xCpl)
        elif nodeName_ == 'xBairro':
            xBairro_ = child_.text
            xBairro_ = self.gds_validate_string(xBairro_, node, 'xBairro')
            self.xBairro = xBairro_
            # validate type xBairroType68
            self.validate_xBairroType68(self.xBairro)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType69
            self.validate_xMunType69(self.xMun)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
# end class TLocal


class TVeiculo(GeneratedsSuper):
    """Tipo Dados do Veículo"""
    subclass = None
    superclass = None
    def __init__(self, placa=None, UF=None, RNTC=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.placa = placa
        self.validate_placaType(self.placa)
        self.UF = UF
        self.validate_TUf(self.UF)
        self.RNTC = RNTC
        self.validate_RNTCType(self.RNTC)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TVeiculo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TVeiculo.subclass:
            return TVeiculo.subclass(*args_, **kwargs_)
        else:
            return TVeiculo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_placa(self):
        return self.placa
    def set_placa(self, placa):
        self.placa = placa
    def get_UF(self):
        return self.UF
    def set_UF(self, UF):
        self.UF = UF
    def get_RNTC(self):
        return self.RNTC
    def set_RNTC(self, RNTC):
        self.RNTC = RNTC
    def validate_placaType(self, value):
        # Validate type placaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_placaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_placaType_patterns_, ))
    validate_placaType_patterns_ = [[u'^[A-Z]{2,3}[0-9]{4}|[A-Z]{3,4}[0-9]{3}|[A-Z0-9]{7}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def validate_RNTCType(self, value):
        # Validate type RNTCType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on RNTCType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on RNTCType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_RNTCType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_RNTCType_patterns_, ))
    validate_RNTCType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.placa is not None or
            self.UF is not None or
            self.RNTC is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TVeiculo', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TVeiculo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TVeiculo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TVeiculo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='editix:', name_='TVeiculo'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TVeiculo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.placa is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%splaca>%s</%splaca>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.placa), input_name='placa')), namespaceprefix_ , eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespaceprefix_ , eol_))
        if self.RNTC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRNTC>%s</%sRNTC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.RNTC), input_name='RNTC')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'placa':
            placa_ = child_.text
            placa_ = self.gds_validate_string(placa_, node, 'placa')
            self.placa = placa_
            # validate type placaType
            self.validate_placaType(self.placa)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
        elif nodeName_ == 'RNTC':
            RNTC_ = child_.text
            RNTC_ = self.gds_validate_string(RNTC_, node, 'RNTC')
            self.RNTC = RNTC_
            # validate type RNTCType
            self.validate_RNTCType(self.RNTC)
# end class TVeiculo


class TIpi(GeneratedsSuper):
    """Tipo: Dados do IPI"""
    subclass = None
    superclass = None
    def __init__(self, CNPJProd=None, cSelo=None, qSelo=None, cEnq=None, IPITrib=None, IPINT=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CNPJProd = CNPJProd
        self.validate_TCnpj(self.CNPJProd)
        self.cSelo = cSelo
        self.validate_cSeloType(self.cSelo)
        self.qSelo = qSelo
        self.validate_qSeloType(self.qSelo)
        self.cEnq = cEnq
        self.validate_cEnqType(self.cEnq)
        self.IPITrib = IPITrib
        self.IPINT = IPINT
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TIpi)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TIpi.subclass:
            return TIpi.subclass(*args_, **kwargs_)
        else:
            return TIpi(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJProd(self):
        return self.CNPJProd
    def set_CNPJProd(self, CNPJProd):
        self.CNPJProd = CNPJProd
    def get_cSelo(self):
        return self.cSelo
    def set_cSelo(self, cSelo):
        self.cSelo = cSelo
    def get_qSelo(self):
        return self.qSelo
    def set_qSelo(self, qSelo):
        self.qSelo = qSelo
    def get_cEnq(self):
        return self.cEnq
    def set_cEnq(self, cEnq):
        self.cEnq = cEnq
    def get_IPITrib(self):
        return self.IPITrib
    def set_IPITrib(self, IPITrib):
        self.IPITrib = IPITrib
    def get_IPINT(self):
        return self.IPINT
    def set_IPINT(self, IPINT):
        self.IPINT = IPINT
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [[u'^[0-9]{14}$']]
    def validate_cSeloType(self, value):
        # Validate type cSeloType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cSeloType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cSeloType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cSeloType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cSeloType_patterns_, ))
    validate_cSeloType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_qSeloType(self, value):
        # Validate type qSeloType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_qSeloType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_qSeloType_patterns_, ))
    validate_qSeloType_patterns_ = [[u'^[0-9]{1,12}$']]
    def validate_cEnqType(self, value):
        # Validate type cEnqType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cEnqType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cEnqType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cEnqType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cEnqType_patterns_, ))
    validate_cEnqType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.CNPJProd is not None or
            self.cSelo is not None or
            self.qSelo is not None or
            self.cEnq is not None or
            self.IPITrib is not None or
            self.IPINT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TIpi', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TIpi')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TIpi')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TIpi', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='editix:', name_='TIpi'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='editix:', namespacedef_='', name_='TIpi', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJProd>%s</%sCNPJProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJProd), input_name='CNPJProd')), namespaceprefix_ , eol_))
        if self.cSelo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scSelo>%s</%scSelo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cSelo), input_name='cSelo')), namespaceprefix_ , eol_))
        if self.qSelo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqSelo>%s</%sqSelo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qSelo), input_name='qSelo')), namespaceprefix_ , eol_))
        if self.cEnq is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scEnq>%s</%scEnq>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cEnq), input_name='cEnq')), namespaceprefix_ , eol_))
        if self.IPITrib is not None:
            self.IPITrib.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IPITrib', pretty_print=pretty_print)
        if self.IPINT is not None:
            self.IPINT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IPINT', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJProd':
            CNPJProd_ = child_.text
            CNPJProd_ = self.gds_validate_string(CNPJProd_, node, 'CNPJProd')
            self.CNPJProd = CNPJProd_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJProd)
        elif nodeName_ == 'cSelo':
            cSelo_ = child_.text
            cSelo_ = self.gds_validate_string(cSelo_, node, 'cSelo')
            self.cSelo = cSelo_
            # validate type cSeloType
            self.validate_cSeloType(self.cSelo)
        elif nodeName_ == 'qSelo':
            qSelo_ = child_.text
            qSelo_ = self.gds_validate_string(qSelo_, node, 'qSelo')
            self.qSelo = qSelo_
            # validate type qSeloType
            self.validate_qSeloType(self.qSelo)
        elif nodeName_ == 'cEnq':
            cEnq_ = child_.text
            cEnq_ = self.gds_validate_string(cEnq_, node, 'cEnq')
            self.cEnq = cEnq_
            # validate type cEnqType
            self.validate_cEnqType(self.cEnq)
        elif nodeName_ == 'IPITrib':
            obj_ = IPITribType.factory(parent_object_=self)
            obj_.build(child_)
            self.IPITrib = obj_
            obj_.original_tagname_ = 'IPITrib'
        elif nodeName_ == 'IPINT':
            obj_ = IPINTType.factory(parent_object_=self)
            obj_.build(child_)
            self.IPINT = obj_
            obj_.original_tagname_ = 'IPINT'
# end class TIpi


class SignatureType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, SignedInfo=None, SignatureValue=None, KeyInfo=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.Id = _cast(None, Id)
        self.SignedInfo = SignedInfo
        self.SignatureValue = SignatureValue
        self.KeyInfo = KeyInfo
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureType.subclass:
            return SignatureType.subclass(*args_, **kwargs_)
        else:
            return SignatureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SignedInfo(self):
        return self.SignedInfo
    def set_SignedInfo(self, SignedInfo):
        self.SignedInfo = SignedInfo
    def get_SignatureValue(self):
        return self.SignatureValue
    def set_SignatureValue(self, SignatureValue):
        self.SignatureValue = SignatureValue
    def get_KeyInfo(self):
        return self.KeyInfo
    def set_KeyInfo(self, KeyInfo):
        self.KeyInfo = KeyInfo
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def hasContent_(self):
        if (
            self.SignedInfo is not None or
            self.SignatureValue is not None or
            self.KeyInfo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='SignatureType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignatureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignatureType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='SignatureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SignedInfo is not None:
            self.SignedInfo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SignedInfo', pretty_print=pretty_print)
        if self.SignatureValue is not None:
            self.SignatureValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SignatureValue', pretty_print=pretty_print)
        if self.KeyInfo is not None:
            self.KeyInfo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='KeyInfo', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SignedInfo':
            obj_ = SignedInfoType.factory(parent_object_=self)
            obj_.build(child_)
            self.SignedInfo = obj_
            obj_.original_tagname_ = 'SignedInfo'
        elif nodeName_ == 'SignatureValue':
            obj_ = SignatureValueType.factory(parent_object_=self)
            obj_.build(child_)
            self.SignatureValue = obj_
            obj_.original_tagname_ = 'SignatureValue'
        elif nodeName_ == 'KeyInfo':
            obj_ = KeyInfoType.factory(parent_object_=self)
            obj_.build(child_)
            self.KeyInfo = obj_
            obj_.original_tagname_ = 'KeyInfo'
# end class SignatureType


class SignatureValueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, valueOf_=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.Id = _cast(None, Id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureValueType.subclass:
            return SignatureValueType.subclass(*args_, **kwargs_)
        else:
            return SignatureValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='SignatureValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignatureValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignatureValueType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='SignatureValueType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SignatureValueType


class SignedInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, CanonicalizationMethod=None, SignatureMethod=None, Reference=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.Id = _cast(None, Id)
        self.CanonicalizationMethod = CanonicalizationMethod
        self.SignatureMethod = SignatureMethod
        self.Reference = Reference
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignedInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignedInfoType.subclass:
            return SignedInfoType.subclass(*args_, **kwargs_)
        else:
            return SignedInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CanonicalizationMethod(self):
        return self.CanonicalizationMethod
    def set_CanonicalizationMethod(self, CanonicalizationMethod):
        self.CanonicalizationMethod = CanonicalizationMethod
    def get_SignatureMethod(self):
        return self.SignatureMethod
    def set_SignatureMethod(self, SignatureMethod):
        self.SignatureMethod = SignatureMethod
    def get_Reference(self):
        return self.Reference
    def set_Reference(self, Reference):
        self.Reference = Reference
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def hasContent_(self):
        if (
            self.CanonicalizationMethod is not None or
            self.SignatureMethod is not None or
            self.Reference is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='SignedInfoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignedInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignedInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignedInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='SignedInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='SignedInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CanonicalizationMethod is not None:
            self.CanonicalizationMethod.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CanonicalizationMethod', pretty_print=pretty_print)
        if self.SignatureMethod is not None:
            self.SignatureMethod.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SignatureMethod', pretty_print=pretty_print)
        if self.Reference is not None:
            self.Reference.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Reference', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CanonicalizationMethod':
            obj_ = CanonicalizationMethodType.factory(parent_object_=self)
            obj_.build(child_)
            self.CanonicalizationMethod = obj_
            obj_.original_tagname_ = 'CanonicalizationMethod'
        elif nodeName_ == 'SignatureMethod':
            obj_ = SignatureMethodType.factory(parent_object_=self)
            obj_.build(child_)
            self.SignatureMethod = obj_
            obj_.original_tagname_ = 'SignatureMethod'
        elif nodeName_ == 'Reference':
            obj_ = ReferenceType.factory(parent_object_=self)
            obj_.build(child_)
            self.Reference = obj_
            obj_.original_tagname_ = 'Reference'
# end class SignedInfoType


class ReferenceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, URI=None, Type=None, Transforms=None, DigestMethod=None, DigestValue=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.Id = _cast(None, Id)
        self.URI = _cast(None, URI)
        self.Type = _cast(None, Type)
        self.Transforms = Transforms
        self.DigestMethod = DigestMethod
        self.DigestValue = DigestValue
        self.validate_DigestValueType(self.DigestValue)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReferenceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReferenceType.subclass:
            return ReferenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transforms(self):
        return self.Transforms
    def set_Transforms(self, Transforms):
        self.Transforms = Transforms
    def get_DigestMethod(self):
        return self.DigestMethod
    def set_DigestMethod(self, DigestMethod):
        self.DigestMethod = DigestMethod
    def get_DigestValue(self):
        return self.DigestValue
    def set_DigestValue(self, DigestValue):
        self.DigestValue = DigestValue
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def get_URI(self):
        return self.URI
    def set_URI(self, URI):
        self.URI = URI
    def get_Type(self):
        return self.Type
    def set_Type(self, Type):
        self.Type = Type
    def validate_DigestValueType(self, value):
        # Validate type DigestValueType, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.Transforms is not None or
            self.DigestMethod is not None or
            self.DigestValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='ReferenceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReferenceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReferenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReferenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='ReferenceType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
        if self.URI is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            outfile.write(' URI=%s' % (quote_attrib(self.URI), ))
        if self.Type is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            outfile.write(' Type=%s' % (quote_attrib(self.Type), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='ReferenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Transforms is not None:
            self.Transforms.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Transforms', pretty_print=pretty_print)
        if self.DigestMethod is not None:
            self.DigestMethod.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DigestMethod', pretty_print=pretty_print)
        if self.DigestValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDigestValue>%s</%sDigestValue>%s' % (namespaceprefix_ , self.gds_format_base64(self.DigestValue, input_name='DigestValue'), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
        value = find_attr_value_('URI', node)
        if value is not None and 'URI' not in already_processed:
            already_processed.add('URI')
            self.URI = value
        value = find_attr_value_('Type', node)
        if value is not None and 'Type' not in already_processed:
            already_processed.add('Type')
            self.Type = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transforms':
            obj_ = TransformsType.factory(parent_object_=self)
            obj_.build(child_)
            self.Transforms = obj_
            obj_.original_tagname_ = 'Transforms'
        elif nodeName_ == 'DigestMethod':
            obj_ = DigestMethodType.factory(parent_object_=self)
            obj_.build(child_)
            self.DigestMethod = obj_
            obj_.original_tagname_ = 'DigestMethod'
        elif nodeName_ == 'DigestValue':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'DigestValue')
            else:
                bval_ = None
            self.DigestValue = bval_
            # validate type DigestValueType
            self.validate_DigestValueType(self.DigestValue)
# end class ReferenceType


class TransformsType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Transform=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if Transform is None:
            self.Transform = []
        else:
            self.Transform = Transform
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformsType.subclass:
            return TransformsType.subclass(*args_, **kwargs_)
        else:
            return TransformsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Transform(self):
        return self.Transform
    def set_Transform(self, Transform):
        self.Transform = Transform
    def add_Transform(self, value):
        self.Transform.append(value)
    def add_Transform(self, value):
        self.Transform.append(value)
    def insert_Transform_at(self, index, value):
        self.Transform.insert(index, value)
    def replace_Transform_at(self, index, value):
        self.Transform[index] = value
    def hasContent_(self):
        if (
            self.Transform
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='TransformsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransformsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransformsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='TransformsType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='TransformsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Transform_ in self.Transform:
            Transform_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Transform', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Transform':
            obj_ = TransformType.factory(parent_object_=self)
            obj_.build(child_)
            self.Transform.append(obj_)
            obj_.original_tagname_ = 'Transform'
# end class TransformsType


class TransformType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm=None, XPath=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.Algorithm = _cast(None, Algorithm)
        if XPath is None:
            self.XPath = []
        else:
            self.XPath = XPath
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TransformType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TransformType.subclass:
            return TransformType.subclass(*args_, **kwargs_)
        else:
            return TransformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_XPath(self):
        return self.XPath
    def set_XPath(self, XPath):
        self.XPath = XPath
    def add_XPath(self, value):
        self.XPath.append(value)
    def add_XPath(self, value):
        self.XPath.append(value)
    def insert_XPath_at(self, index, value):
        self.XPath.insert(index, value)
    def replace_XPath_at(self, index, value):
        self.XPath[index] = value
    def get_Algorithm(self):
        return self.Algorithm
    def set_Algorithm(self, Algorithm):
        self.Algorithm = Algorithm
    def hasContent_(self):
        if (
            self.XPath
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='TransformType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TransformType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TransformType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TransformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='TransformType'):
        if self.Algorithm is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='TransformType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for XPath_ in self.XPath:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sXPath>%s</%sXPath>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(XPath_), input_name='XPath')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'XPath':
            XPath_ = child_.text
            XPath_ = self.gds_validate_string(XPath_, node, 'XPath')
            self.XPath.append(XPath_)
# end class TransformType


class KeyInfoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, X509Data=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.Id = _cast(None, Id)
        self.X509Data = X509Data
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KeyInfoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KeyInfoType.subclass:
            return KeyInfoType.subclass(*args_, **kwargs_)
        else:
            return KeyInfoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X509Data(self):
        return self.X509Data
    def set_X509Data(self, X509Data):
        self.X509Data = X509Data
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def hasContent_(self):
        if (
            self.X509Data is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='KeyInfoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KeyInfoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KeyInfoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='KeyInfoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='KeyInfoType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (quote_attrib(self.Id), ))
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='KeyInfoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509Data is not None:
            self.X509Data.export(outfile, level, namespaceprefix_, namespacedef_='', name_='X509Data', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X509Data':
            obj_ = X509DataType.factory(parent_object_=self)
            obj_.build(child_)
            self.X509Data = obj_
            obj_.original_tagname_ = 'X509Data'
# end class KeyInfoType


class X509DataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, X509Certificate=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.X509Certificate = X509Certificate
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, X509DataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if X509DataType.subclass:
            return X509DataType.subclass(*args_, **kwargs_)
        else:
            return X509DataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_X509Certificate(self):
        return self.X509Certificate
    def set_X509Certificate(self, X509Certificate):
        self.X509Certificate = X509Certificate
    def hasContent_(self):
        if (
            self.X509Certificate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='X509DataType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('X509DataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='X509DataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='X509DataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='ds:', name_='X509DataType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='ds:', namespacedef_='', name_='X509DataType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.X509Certificate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX509Certificate>%s</%sX509Certificate>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.X509Certificate), input_name='X509Certificate')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'X509Certificate':
            X509Certificate_ = child_.text
            X509Certificate_ = self.gds_validate_string(X509Certificate_, node, 'X509Certificate')
            self.X509Certificate = X509Certificate_
# end class X509DataType


class infNFeType(GeneratedsSuper):
    """Versão do leiaute (v4.00)PL_005d - 11/08/09 - validação do Id"""
    subclass = None
    superclass = None
    def __init__(self, versao=None, Id=None, ide=None, emit=None, avulsa=None, dest=None, retirada=None, entrega=None, autXML=None, det=None, total=None, transp=None, cobr=None, pag=None, infAdic=None, exporta=None, compra=None, cana=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.versao = _cast(None, versao)
        self.Id = _cast(None, Id)
        self.ide = ide
        self.emit = emit
        self.avulsa = avulsa
        self.dest = dest
        self.retirada = retirada
        self.entrega = entrega
        if autXML is None:
            self.autXML = []
        else:
            self.autXML = autXML
        if det is None:
            self.det = []
        else:
            self.det = det
        self.total = total
        self.transp = transp
        self.cobr = cobr
        self.pag = pag
        self.infAdic = infAdic
        self.exporta = exporta
        self.compra = compra
        self.cana = cana
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infNFeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infNFeType.subclass:
            return infNFeType.subclass(*args_, **kwargs_)
        else:
            return infNFeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ide(self):
        return self.ide
    def set_ide(self, ide):
        self.ide = ide
    def get_emit(self):
        return self.emit
    def set_emit(self, emit):
        self.emit = emit
    def get_avulsa(self):
        return self.avulsa
    def set_avulsa(self, avulsa):
        self.avulsa = avulsa
    def get_dest(self):
        return self.dest
    def set_dest(self, dest):
        self.dest = dest
    def get_retirada(self):
        return self.retirada
    def set_retirada(self, retirada):
        self.retirada = retirada
    def get_entrega(self):
        return self.entrega
    def set_entrega(self, entrega):
        self.entrega = entrega
    def get_autXML(self):
        return self.autXML
    def set_autXML(self, autXML):
        self.autXML = autXML
    def add_autXML(self, value):
        self.autXML.append(value)
    def add_autXML(self, value):
        self.autXML.append(value)
    def insert_autXML_at(self, index, value):
        self.autXML.insert(index, value)
    def replace_autXML_at(self, index, value):
        self.autXML[index] = value
    def get_det(self):
        return self.det
    def set_det(self, det):
        self.det = det
    def add_det(self, value):
        self.det.append(value)
    def add_det(self, value):
        self.det.append(value)
    def insert_det_at(self, index, value):
        self.det.insert(index, value)
    def replace_det_at(self, index, value):
        self.det[index] = value
    def get_total(self):
        return self.total
    def set_total(self, total):
        self.total = total
    def get_transp(self):
        return self.transp
    def set_transp(self, transp):
        self.transp = transp
    def get_cobr(self):
        return self.cobr
    def set_cobr(self, cobr):
        self.cobr = cobr
    def get_pag(self):
        return self.pag
    def set_pag(self, pag):
        self.pag = pag
    def get_infAdic(self):
        return self.infAdic
    def set_infAdic(self, infAdic):
        self.infAdic = infAdic
    def get_exporta(self):
        return self.exporta
    def set_exporta(self, exporta):
        self.exporta = exporta
    def get_compra(self):
        return self.compra
    def set_compra(self, compra):
        self.compra = compra
    def get_cana(self):
        return self.cana
    def set_cana(self, cana):
        self.cana = cana
    def get_versao(self):
        return self.versao
    def set_versao(self, versao):
        self.versao = versao
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def validate_TVerNFe(self, value):
        # Validate type TVerNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerNFe_patterns_, ))
    validate_TVerNFe_patterns_ = [[u'^4\\.00$']]
    def hasContent_(self):
        if (
            self.ide is not None or
            self.emit is not None or
            self.avulsa is not None or
            self.dest is not None or
            self.retirada is not None or
            self.entrega is not None or
            self.autXML or
            self.det or
            self.total is not None or
            self.transp is not None or
            self.cobr is not None or
            self.pag is not None or
            self.infAdic is not None or
            self.exporta is not None or
            self.compra is not None or
            self.cana is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='infNFeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infNFeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infNFeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infNFeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infNFeType'):
        if self.versao is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            outfile.write(' versao=%s' % (quote_attrib(self.versao), ))
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='infNFeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ide is not None:
            self.ide.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ide', pretty_print=pretty_print)
        if self.emit is not None:
            self.emit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emit', pretty_print=pretty_print)
        if self.avulsa is not None:
            self.avulsa.export(outfile, level, namespaceprefix_, namespacedef_='', name_='avulsa', pretty_print=pretty_print)
        if self.dest is not None:
            self.dest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dest', pretty_print=pretty_print)
        if self.retirada is not None:
            self.retirada.export(outfile, level, namespaceprefix_, namespacedef_='', name_='retirada', pretty_print=pretty_print)
        if self.entrega is not None:
            self.entrega.export(outfile, level, namespaceprefix_, namespacedef_='', name_='entrega', pretty_print=pretty_print)
        for autXML_ in self.autXML:
            autXML_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='autXML', pretty_print=pretty_print)
        for det_ in self.det:
            det_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='det', pretty_print=pretty_print)
        if self.total is not None:
            self.total.export(outfile, level, namespaceprefix_, namespacedef_='', name_='total', pretty_print=pretty_print)
        if self.transp is not None:
            self.transp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='transp', pretty_print=pretty_print)
        if self.cobr is not None:
            self.cobr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cobr', pretty_print=pretty_print)
        if self.pag is not None:
            self.pag.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pag', pretty_print=pretty_print)
        if self.infAdic is not None:
            self.infAdic.export(outfile, level, namespaceprefix_, namespacedef_='', name_='infAdic', pretty_print=pretty_print)
        if self.exporta is not None:
            self.exporta.export(outfile, level, namespaceprefix_, namespacedef_='', name_='exporta', pretty_print=pretty_print)
        if self.compra is not None:
            self.compra.export(outfile, level, namespaceprefix_, namespacedef_='', name_='compra', pretty_print=pretty_print)
        if self.cana is not None:
            self.cana.export(outfile, level, namespaceprefix_, namespacedef_='', name_='cana', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('versao', node)
        if value is not None and 'versao' not in already_processed:
            already_processed.add('versao')
            self.versao = value
            self.validate_TVerNFe(self.versao)    # validate type TVerNFe
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ide':
            obj_ = ideType.factory(parent_object_=self)
            obj_.build(child_)
            self.ide = obj_
            obj_.original_tagname_ = 'ide'
        elif nodeName_ == 'emit':
            obj_ = emitType.factory(parent_object_=self)
            obj_.build(child_)
            self.emit = obj_
            obj_.original_tagname_ = 'emit'
        elif nodeName_ == 'avulsa':
            obj_ = avulsaType.factory(parent_object_=self)
            obj_.build(child_)
            self.avulsa = obj_
            obj_.original_tagname_ = 'avulsa'
        elif nodeName_ == 'dest':
            obj_ = destType.factory(parent_object_=self)
            obj_.build(child_)
            self.dest = obj_
            obj_.original_tagname_ = 'dest'
        elif nodeName_ == 'retirada':
            obj_ = TLocal.factory(parent_object_=self)
            obj_.build(child_)
            self.retirada = obj_
            obj_.original_tagname_ = 'retirada'
        elif nodeName_ == 'entrega':
            obj_ = TLocal.factory(parent_object_=self)
            obj_.build(child_)
            self.entrega = obj_
            obj_.original_tagname_ = 'entrega'
        elif nodeName_ == 'autXML':
            obj_ = autXMLType.factory(parent_object_=self)
            obj_.build(child_)
            self.autXML.append(obj_)
            obj_.original_tagname_ = 'autXML'
        elif nodeName_ == 'det':
            obj_ = detType.factory(parent_object_=self)
            obj_.build(child_)
            self.det.append(obj_)
            obj_.original_tagname_ = 'det'
        elif nodeName_ == 'total':
            obj_ = totalType.factory(parent_object_=self)
            obj_.build(child_)
            self.total = obj_
            obj_.original_tagname_ = 'total'
        elif nodeName_ == 'transp':
            obj_ = transpType.factory(parent_object_=self)
            obj_.build(child_)
            self.transp = obj_
            obj_.original_tagname_ = 'transp'
        elif nodeName_ == 'cobr':
            obj_ = cobrType.factory(parent_object_=self)
            obj_.build(child_)
            self.cobr = obj_
            obj_.original_tagname_ = 'cobr'
        elif nodeName_ == 'pag':
            obj_ = pagType.factory(parent_object_=self)
            obj_.build(child_)
            self.pag = obj_
            obj_.original_tagname_ = 'pag'
        elif nodeName_ == 'infAdic':
            obj_ = infAdicType.factory(parent_object_=self)
            obj_.build(child_)
            self.infAdic = obj_
            obj_.original_tagname_ = 'infAdic'
        elif nodeName_ == 'exporta':
            obj_ = exportaType.factory(parent_object_=self)
            obj_.build(child_)
            self.exporta = obj_
            obj_.original_tagname_ = 'exporta'
        elif nodeName_ == 'compra':
            obj_ = compraType.factory(parent_object_=self)
            obj_.build(child_)
            self.compra = obj_
            obj_.original_tagname_ = 'compra'
        elif nodeName_ == 'cana':
            obj_ = canaType.factory(parent_object_=self)
            obj_.build(child_)
            self.cana = obj_
            obj_.original_tagname_ = 'cana'
# end class infNFeType


class ideType(GeneratedsSuper):
    """Informar apenas para tpEmis diferente de 1"""
    subclass = None
    superclass = None
    def __init__(self, cUF=None, cNF=None, natOp=None, mod=None, serie=None, nNF=None, dhEmi=None, dhSaiEnt=None, tpNF=None, idDest=None, cMunFG=None, tpImp=None, tpEmis=None, cDV=None, tpAmb=None, finNFe=None, indFinal=None, indPres=None, procEmi=None, verProc=None, dhCont=None, xJust=None, NFref=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.cNF = cNF
        self.validate_cNFType(self.cNF)
        self.natOp = natOp
        self.validate_natOpType(self.natOp)
        self.mod = mod
        self.validate_TMod(self.mod)
        self.serie = serie
        self.validate_TSerie(self.serie)
        self.nNF = nNF
        self.validate_TNF(self.nNF)
        self.dhEmi = dhEmi
        self.validate_TDateTimeUTC(self.dhEmi)
        self.dhSaiEnt = dhSaiEnt
        self.validate_TDateTimeUTC(self.dhSaiEnt)
        self.tpNF = tpNF
        self.validate_tpNFType(self.tpNF)
        self.idDest = idDest
        self.validate_idDestType(self.idDest)
        self.cMunFG = cMunFG
        self.validate_TCodMunIBGE(self.cMunFG)
        self.tpImp = tpImp
        self.validate_tpImpType(self.tpImp)
        self.tpEmis = tpEmis
        self.validate_tpEmisType(self.tpEmis)
        self.cDV = cDV
        self.validate_cDVType(self.cDV)
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.finNFe = finNFe
        self.validate_TFinNFe(self.finNFe)
        self.indFinal = indFinal
        self.validate_indFinalType(self.indFinal)
        self.indPres = indPres
        self.validate_indPresType(self.indPres)
        self.procEmi = procEmi
        self.validate_TProcEmi(self.procEmi)
        self.verProc = verProc
        self.validate_verProcType(self.verProc)
        self.dhCont = dhCont
        self.validate_TDateTimeUTC(self.dhCont)
        self.xJust = xJust
        self.validate_xJustType(self.xJust)
        if NFref is None:
            self.NFref = []
        else:
            self.NFref = NFref
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ideType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ideType.subclass:
            return ideType.subclass(*args_, **kwargs_)
        else:
            return ideType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cUF(self):
        return self.cUF
    def set_cUF(self, cUF):
        self.cUF = cUF
    def get_cNF(self):
        return self.cNF
    def set_cNF(self, cNF):
        self.cNF = cNF
    def get_natOp(self):
        return self.natOp
    def set_natOp(self, natOp):
        self.natOp = natOp
    def get_mod(self):
        return self.mod
    def set_mod(self, mod):
        self.mod = mod
    def get_serie(self):
        return self.serie
    def set_serie(self, serie):
        self.serie = serie
    def get_nNF(self):
        return self.nNF
    def set_nNF(self, nNF):
        self.nNF = nNF
    def get_dhEmi(self):
        return self.dhEmi
    def set_dhEmi(self, dhEmi):
        self.dhEmi = dhEmi
    def get_dhSaiEnt(self):
        return self.dhSaiEnt
    def set_dhSaiEnt(self, dhSaiEnt):
        self.dhSaiEnt = dhSaiEnt
    def get_tpNF(self):
        return self.tpNF
    def set_tpNF(self, tpNF):
        self.tpNF = tpNF
    def get_idDest(self):
        return self.idDest
    def set_idDest(self, idDest):
        self.idDest = idDest
    def get_cMunFG(self):
        return self.cMunFG
    def set_cMunFG(self, cMunFG):
        self.cMunFG = cMunFG
    def get_tpImp(self):
        return self.tpImp
    def set_tpImp(self, tpImp):
        self.tpImp = tpImp
    def get_tpEmis(self):
        return self.tpEmis
    def set_tpEmis(self, tpEmis):
        self.tpEmis = tpEmis
    def get_cDV(self):
        return self.cDV
    def set_cDV(self, cDV):
        self.cDV = cDV
    def get_tpAmb(self):
        return self.tpAmb
    def set_tpAmb(self, tpAmb):
        self.tpAmb = tpAmb
    def get_finNFe(self):
        return self.finNFe
    def set_finNFe(self, finNFe):
        self.finNFe = finNFe
    def get_indFinal(self):
        return self.indFinal
    def set_indFinal(self, indFinal):
        self.indFinal = indFinal
    def get_indPres(self):
        return self.indPres
    def set_indPres(self, indPres):
        self.indPres = indPres
    def get_procEmi(self):
        return self.procEmi
    def set_procEmi(self, procEmi):
        self.procEmi = procEmi
    def get_verProc(self):
        return self.verProc
    def set_verProc(self, verProc):
        self.verProc = verProc
    def get_dhCont(self):
        return self.dhCont
    def set_dhCont(self, dhCont):
        self.dhCont = dhCont
    def get_xJust(self):
        return self.xJust
    def set_xJust(self, xJust):
        self.xJust = xJust
    def get_NFref(self):
        return self.NFref
    def set_NFref(self, NFref):
        self.NFref = NFref
    def add_NFref(self, value):
        self.NFref.append(value)
    def add_NFref(self, value):
        self.NFref.append(value)
    def insert_NFref_at(self, index, value):
        self.NFref.insert(index, value)
    def replace_NFref_at(self, index, value):
        self.NFref[index] = value
    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : value.encode("utf-8")} )
    def validate_cNFType(self, value):
        # Validate type cNFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cNFType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cNFType_patterns_, ))
    validate_cNFType_patterns_ = [[u'^[0-9]{8}$']]
    def validate_natOpType(self, value):
        # Validate type natOpType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on natOpType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on natOpType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_natOpType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_natOpType_patterns_, ))
    validate_natOpType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TMod(self, value):
        # Validate type TMod, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['55', '65']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TMod' % {"value" : value.encode("utf-8")} )
    def validate_TSerie(self, value):
        # Validate type TSerie, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TSerie_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TSerie_patterns_, ))
    validate_TSerie_patterns_ = [[u'^0|[1-9]{1}[0-9]{0,2}$']]
    def validate_TNF(self, value):
        # Validate type TNF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TNF_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TNF_patterns_, ))
    validate_TNF_patterns_ = [[u'^[1-9]{1}[0-9]{0,8}$']]
    def validate_TDateTimeUTC(self, value):
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDateTimeUTC_patterns_, ))
    validate_TDateTimeUTC_patterns_ = [[u'^(((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))T(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]|10|11):00|([\\+](12):00))$']]
    def validate_tpNFType(self, value):
        # Validate type tpNFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpNFType' % {"value" : value.encode("utf-8")} )
    def validate_idDestType(self, value):
        # Validate type idDestType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on idDestType' % {"value" : value.encode("utf-8")} )
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [[u'^[0-9]{7}$']]
    def validate_tpImpType(self, value):
        # Validate type tpImpType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpImpType' % {"value" : value.encode("utf-8")} )
    def validate_tpEmisType(self, value):
        # Validate type tpEmisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6', '7', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpEmisType' % {"value" : value.encode("utf-8")} )
    def validate_cDVType(self, value):
        # Validate type cDVType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cDVType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cDVType_patterns_, ))
    validate_cDVType_patterns_ = [[u'^[0-9]{1}$']]
    def validate_TAmb(self, value):
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TAmb' % {"value" : value.encode("utf-8")} )
    def validate_TFinNFe(self, value):
        # Validate type TFinNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TFinNFe' % {"value" : value.encode("utf-8")} )
    def validate_indFinalType(self, value):
        # Validate type indFinalType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indFinalType' % {"value" : value.encode("utf-8")} )
    def validate_indPresType(self, value):
        # Validate type indPresType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indPresType' % {"value" : value.encode("utf-8")} )
    def validate_TProcEmi(self, value):
        # Validate type TProcEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TProcEmi' % {"value" : value.encode("utf-8")} )
    def validate_verProcType(self, value):
        # Validate type verProcType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on verProcType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on verProcType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_verProcType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_verProcType_patterns_, ))
    validate_verProcType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_xJustType(self, value):
        # Validate type xJustType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 256:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xJustType' % {"value" : value} )
            if len(str(value)) < 15:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xJustType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xJustType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xJustType_patterns_, ))
    validate_xJustType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.cUF is not None or
            self.cNF is not None or
            self.natOp is not None or
            self.mod is not None or
            self.serie is not None or
            self.nNF is not None or
            self.dhEmi is not None or
            self.dhSaiEnt is not None or
            self.tpNF is not None or
            self.idDest is not None or
            self.cMunFG is not None or
            self.tpImp is not None or
            self.tpEmis is not None or
            self.cDV is not None or
            self.tpAmb is not None or
            self.finNFe is not None or
            self.indFinal is not None or
            self.indPres is not None or
            self.procEmi is not None or
            self.verProc is not None or
            self.dhCont is not None or
            self.xJust is not None or
            self.NFref
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ideType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ideType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ideType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ideType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ideType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ideType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespaceprefix_ , eol_))
        if self.cNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scNF>%s</%scNF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cNF), input_name='cNF')), namespaceprefix_ , eol_))
        if self.natOp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snatOp>%s</%snatOp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.natOp), input_name='natOp')), namespaceprefix_ , eol_))
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smod>%s</%smod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), namespaceprefix_ , eol_))
        if self.serie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserie>%s</%sserie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), namespaceprefix_ , eol_))
        if self.nNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snNF>%s</%snNF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nNF), input_name='nNF')), namespaceprefix_ , eol_))
        if self.dhEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhEmi>%s</%sdhEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhEmi), input_name='dhEmi')), namespaceprefix_ , eol_))
        if self.dhSaiEnt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhSaiEnt>%s</%sdhSaiEnt>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhSaiEnt), input_name='dhSaiEnt')), namespaceprefix_ , eol_))
        if self.tpNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpNF>%s</%stpNF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpNF), input_name='tpNF')), namespaceprefix_ , eol_))
        if self.idDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidDest>%s</%sidDest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.idDest), input_name='idDest')), namespaceprefix_ , eol_))
        if self.cMunFG is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMunFG>%s</%scMunFG>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMunFG), input_name='cMunFG')), namespaceprefix_ , eol_))
        if self.tpImp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpImp>%s</%stpImp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpImp), input_name='tpImp')), namespaceprefix_ , eol_))
        if self.tpEmis is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpEmis>%s</%stpEmis>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpEmis), input_name='tpEmis')), namespaceprefix_ , eol_))
        if self.cDV is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scDV>%s</%scDV>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cDV), input_name='cDV')), namespaceprefix_ , eol_))
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespaceprefix_ , eol_))
        if self.finNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfinNFe>%s</%sfinNFe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.finNFe), input_name='finNFe')), namespaceprefix_ , eol_))
        if self.indFinal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindFinal>%s</%sindFinal>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indFinal), input_name='indFinal')), namespaceprefix_ , eol_))
        if self.indPres is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindPres>%s</%sindPres>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indPres), input_name='indPres')), namespaceprefix_ , eol_))
        if self.procEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprocEmi>%s</%sprocEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.procEmi), input_name='procEmi')), namespaceprefix_ , eol_))
        if self.verProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverProc>%s</%sverProc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.verProc), input_name='verProc')), namespaceprefix_ , eol_))
        if self.dhCont is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhCont>%s</%sdhCont>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhCont), input_name='dhCont')), namespaceprefix_ , eol_))
        if self.xJust is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxJust>%s</%sxJust>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xJust), input_name='xJust')), namespaceprefix_ , eol_))
        for NFref_ in self.NFref:
            NFref_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NFref', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'cNF':
            cNF_ = child_.text
            cNF_ = self.gds_validate_string(cNF_, node, 'cNF')
            self.cNF = cNF_
            # validate type cNFType
            self.validate_cNFType(self.cNF)
        elif nodeName_ == 'natOp':
            natOp_ = child_.text
            natOp_ = self.gds_validate_string(natOp_, node, 'natOp')
            self.natOp = natOp_
            # validate type natOpType
            self.validate_natOpType(self.natOp)
        elif nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
            # validate type TMod
            self.validate_TMod(self.mod)
        elif nodeName_ == 'serie':
            serie_ = child_.text
            serie_ = self.gds_validate_string(serie_, node, 'serie')
            self.serie = serie_
            # validate type TSerie
            self.validate_TSerie(self.serie)
        elif nodeName_ == 'nNF':
            nNF_ = child_.text
            nNF_ = self.gds_validate_string(nNF_, node, 'nNF')
            self.nNF = nNF_
            # validate type TNF
            self.validate_TNF(self.nNF)
        elif nodeName_ == 'dhEmi':
            dhEmi_ = child_.text
            dhEmi_ = self.gds_validate_string(dhEmi_, node, 'dhEmi')
            self.dhEmi = dhEmi_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhEmi)
        elif nodeName_ == 'dhSaiEnt':
            dhSaiEnt_ = child_.text
            dhSaiEnt_ = self.gds_validate_string(dhSaiEnt_, node, 'dhSaiEnt')
            self.dhSaiEnt = dhSaiEnt_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhSaiEnt)
        elif nodeName_ == 'tpNF':
            tpNF_ = child_.text
            tpNF_ = self.gds_validate_string(tpNF_, node, 'tpNF')
            self.tpNF = tpNF_
            # validate type tpNFType
            self.validate_tpNFType(self.tpNF)
        elif nodeName_ == 'idDest':
            idDest_ = child_.text
            idDest_ = self.gds_validate_string(idDest_, node, 'idDest')
            self.idDest = idDest_
            # validate type idDestType
            self.validate_idDestType(self.idDest)
        elif nodeName_ == 'cMunFG':
            cMunFG_ = child_.text
            cMunFG_ = self.gds_validate_string(cMunFG_, node, 'cMunFG')
            self.cMunFG = cMunFG_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunFG)
        elif nodeName_ == 'tpImp':
            tpImp_ = child_.text
            tpImp_ = self.gds_validate_string(tpImp_, node, 'tpImp')
            self.tpImp = tpImp_
            # validate type tpImpType
            self.validate_tpImpType(self.tpImp)
        elif nodeName_ == 'tpEmis':
            tpEmis_ = child_.text
            tpEmis_ = self.gds_validate_string(tpEmis_, node, 'tpEmis')
            self.tpEmis = tpEmis_
            # validate type tpEmisType
            self.validate_tpEmisType(self.tpEmis)
        elif nodeName_ == 'cDV':
            cDV_ = child_.text
            cDV_ = self.gds_validate_string(cDV_, node, 'cDV')
            self.cDV = cDV_
            # validate type cDVType
            self.validate_cDVType(self.cDV)
        elif nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'finNFe':
            finNFe_ = child_.text
            finNFe_ = self.gds_validate_string(finNFe_, node, 'finNFe')
            self.finNFe = finNFe_
            # validate type TFinNFe
            self.validate_TFinNFe(self.finNFe)
        elif nodeName_ == 'indFinal':
            indFinal_ = child_.text
            indFinal_ = self.gds_validate_string(indFinal_, node, 'indFinal')
            self.indFinal = indFinal_
            # validate type indFinalType
            self.validate_indFinalType(self.indFinal)
        elif nodeName_ == 'indPres':
            indPres_ = child_.text
            indPres_ = self.gds_validate_string(indPres_, node, 'indPres')
            self.indPres = indPres_
            # validate type indPresType
            self.validate_indPresType(self.indPres)
        elif nodeName_ == 'procEmi':
            procEmi_ = child_.text
            procEmi_ = self.gds_validate_string(procEmi_, node, 'procEmi')
            self.procEmi = procEmi_
            # validate type TProcEmi
            self.validate_TProcEmi(self.procEmi)
        elif nodeName_ == 'verProc':
            verProc_ = child_.text
            verProc_ = self.gds_validate_string(verProc_, node, 'verProc')
            self.verProc = verProc_
            # validate type verProcType
            self.validate_verProcType(self.verProc)
        elif nodeName_ == 'dhCont':
            dhCont_ = child_.text
            dhCont_ = self.gds_validate_string(dhCont_, node, 'dhCont')
            self.dhCont = dhCont_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhCont)
        elif nodeName_ == 'xJust':
            xJust_ = child_.text
            xJust_ = self.gds_validate_string(xJust_, node, 'xJust')
            self.xJust = xJust_
            # validate type xJustType
            self.validate_xJustType(self.xJust)
        elif nodeName_ == 'NFref':
            obj_ = NFrefType.factory(parent_object_=self)
            obj_.build(child_)
            self.NFref.append(obj_)
            obj_.original_tagname_ = 'NFref'
# end class ideType


class NFrefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, refNFe=None, refNF=None, refNFP=None, refCTe=None, refECF=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.refNFe = refNFe
        self.validate_TChNFe(self.refNFe)
        self.refNF = refNF
        self.refNFP = refNFP
        self.refCTe = refCTe
        self.validate_TChNFe(self.refCTe)
        self.refECF = refECF
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NFrefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NFrefType.subclass:
            return NFrefType.subclass(*args_, **kwargs_)
        else:
            return NFrefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_refNFe(self):
        return self.refNFe
    def set_refNFe(self, refNFe):
        self.refNFe = refNFe
    def get_refNF(self):
        return self.refNF
    def set_refNF(self, refNF):
        self.refNF = refNF
    def get_refNFP(self):
        return self.refNFP
    def set_refNFP(self, refNFP):
        self.refNFP = refNFP
    def get_refCTe(self):
        return self.refCTe
    def set_refCTe(self, refCTe):
        self.refCTe = refCTe
    def get_refECF(self):
        return self.refECF
    def set_refECF(self, refECF):
        self.refECF = refECF
    def validate_TChNFe(self, value):
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 44:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TChNFe' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TChNFe_patterns_, ))
    validate_TChNFe_patterns_ = [[u'^[0-9]{44}$']]
    def hasContent_(self):
        if (
            self.refNFe is not None or
            self.refNF is not None or
            self.refNFP is not None or
            self.refCTe is not None or
            self.refECF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NFrefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NFrefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NFrefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NFrefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NFrefType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NFrefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.refNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srefNFe>%s</%srefNFe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.refNFe), input_name='refNFe')), namespaceprefix_ , eol_))
        if self.refNF is not None:
            self.refNF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='refNF', pretty_print=pretty_print)
        if self.refNFP is not None:
            self.refNFP.export(outfile, level, namespaceprefix_, namespacedef_='', name_='refNFP', pretty_print=pretty_print)
        if self.refCTe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srefCTe>%s</%srefCTe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.refCTe), input_name='refCTe')), namespaceprefix_ , eol_))
        if self.refECF is not None:
            self.refECF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='refECF', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'refNFe':
            refNFe_ = child_.text
            refNFe_ = self.gds_validate_string(refNFe_, node, 'refNFe')
            self.refNFe = refNFe_
            # validate type TChNFe
            self.validate_TChNFe(self.refNFe)
        elif nodeName_ == 'refNF':
            obj_ = refNFType.factory(parent_object_=self)
            obj_.build(child_)
            self.refNF = obj_
            obj_.original_tagname_ = 'refNF'
        elif nodeName_ == 'refNFP':
            obj_ = refNFPType.factory(parent_object_=self)
            obj_.build(child_)
            self.refNFP = obj_
            obj_.original_tagname_ = 'refNFP'
        elif nodeName_ == 'refCTe':
            refCTe_ = child_.text
            refCTe_ = self.gds_validate_string(refCTe_, node, 'refCTe')
            self.refCTe = refCTe_
            # validate type TChNFe
            self.validate_TChNFe(self.refCTe)
        elif nodeName_ == 'refECF':
            obj_ = refECFType.factory(parent_object_=self)
            obj_.build(child_)
            self.refECF = obj_
            obj_.original_tagname_ = 'refECF'
# end class NFrefType


class refNFType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cUF=None, AAMM=None, CNPJ=None, mod=None, serie=None, nNF=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.AAMM = AAMM
        self.validate_AAMMType(self.AAMM)
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.mod = mod
        self.validate_modType(self.mod)
        self.serie = serie
        self.validate_TSerie(self.serie)
        self.nNF = nNF
        self.validate_TNF(self.nNF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refNFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refNFType.subclass:
            return refNFType.subclass(*args_, **kwargs_)
        else:
            return refNFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cUF(self):
        return self.cUF
    def set_cUF(self, cUF):
        self.cUF = cUF
    def get_AAMM(self):
        return self.AAMM
    def set_AAMM(self, AAMM):
        self.AAMM = AAMM
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_mod(self):
        return self.mod
    def set_mod(self, mod):
        self.mod = mod
    def get_serie(self):
        return self.serie
    def set_serie(self, serie):
        self.serie = serie
    def get_nNF(self):
        return self.nNF
    def set_nNF(self, nNF):
        self.nNF = nNF
    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : value.encode("utf-8")} )
    def validate_AAMMType(self, value):
        # Validate type AAMMType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AAMMType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AAMMType_patterns_, ))
    validate_AAMMType_patterns_ = [[u'^[0-9]{2}[0]{1}[1-9]{1}|[0-9]{2}[1]{1}[0-2]{1}$']]
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [[u'^[0-9]{14}$']]
    def validate_modType(self, value):
        # Validate type modType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modType' % {"value" : value.encode("utf-8")} )
    def validate_TSerie(self, value):
        # Validate type TSerie, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TSerie_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TSerie_patterns_, ))
    validate_TSerie_patterns_ = [[u'^0|[1-9]{1}[0-9]{0,2}$']]
    def validate_TNF(self, value):
        # Validate type TNF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TNF_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TNF_patterns_, ))
    validate_TNF_patterns_ = [[u'^[1-9]{1}[0-9]{0,8}$']]
    def hasContent_(self):
        if (
            self.cUF is not None or
            self.AAMM is not None or
            self.CNPJ is not None or
            self.mod is not None or
            self.serie is not None or
            self.nNF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='refNFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refNFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='refNFType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='refNFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='refNFType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='refNFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespaceprefix_ , eol_))
        if self.AAMM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAAMM>%s</%sAAMM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AAMM), input_name='AAMM')), namespaceprefix_ , eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smod>%s</%smod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), namespaceprefix_ , eol_))
        if self.serie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserie>%s</%sserie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), namespaceprefix_ , eol_))
        if self.nNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snNF>%s</%snNF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nNF), input_name='nNF')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'AAMM':
            AAMM_ = child_.text
            AAMM_ = self.gds_validate_string(AAMM_, node, 'AAMM')
            self.AAMM = AAMM_
            # validate type AAMMType
            self.validate_AAMMType(self.AAMM)
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
            # validate type modType
            self.validate_modType(self.mod)
        elif nodeName_ == 'serie':
            serie_ = child_.text
            serie_ = self.gds_validate_string(serie_, node, 'serie')
            self.serie = serie_
            # validate type TSerie
            self.validate_TSerie(self.serie)
        elif nodeName_ == 'nNF':
            nNF_ = child_.text
            nNF_ = self.gds_validate_string(nNF_, node, 'nNF')
            self.nNF = nNF_
            # validate type TNF
            self.validate_TNF(self.nNF)
# end class refNFType


class refNFPType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cUF=None, AAMM=None, CNPJ=None, CPF=None, IE=None, mod=None, serie=None, nNF=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.cUF = cUF
        self.validate_TCodUfIBGE(self.cUF)
        self.AAMM = AAMM
        self.validate_AAMMType1(self.AAMM)
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.IE = IE
        self.validate_TIeDest(self.IE)
        self.mod = mod
        self.validate_modType2(self.mod)
        self.serie = serie
        self.validate_TSerie(self.serie)
        self.nNF = nNF
        self.validate_TNF(self.nNF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refNFPType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refNFPType.subclass:
            return refNFPType.subclass(*args_, **kwargs_)
        else:
            return refNFPType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cUF(self):
        return self.cUF
    def set_cUF(self, cUF):
        self.cUF = cUF
    def get_AAMM(self):
        return self.AAMM
    def set_AAMM(self, AAMM):
        self.AAMM = AAMM
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_mod(self):
        return self.mod
    def set_mod(self, mod):
        self.mod = mod
    def get_serie(self):
        return self.serie
    def set_serie(self, serie):
        self.serie = serie
    def get_nNF(self):
        return self.nNF
    def set_nNF(self, nNF):
        self.nNF = nNF
    def validate_TCodUfIBGE(self, value):
        # Validate type TCodUfIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['11', '12', '13', '14', '15', '16', '17', '21', '22', '23', '24', '25', '26', '27', '28', '29', '31', '32', '33', '35', '41', '42', '43', '50', '51', '52', '53']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TCodUfIBGE' % {"value" : value.encode("utf-8")} )
    def validate_AAMMType1(self, value):
        # Validate type AAMMType1, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_AAMMType1_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_AAMMType1_patterns_, ))
    validate_AAMMType1_patterns_ = [[u'^[0-9]{2}[0]{1}[1-9]{1}|[0-9]{2}[1]{1}[0-2]{1}$']]
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [[u'^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [[u'^[0-9]{11}$']]
    def validate_TIeDest(self, value):
        # Validate type TIeDest, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TIeDest' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TIeDest_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TIeDest_patterns_, ))
    validate_TIeDest_patterns_ = [[u'^ISENTO|[0-9]{2,14}$']]
    def validate_modType2(self, value):
        # Validate type modType2, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '04']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modType2' % {"value" : value.encode("utf-8")} )
    def validate_TSerie(self, value):
        # Validate type TSerie, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TSerie_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TSerie_patterns_, ))
    validate_TSerie_patterns_ = [[u'^0|[1-9]{1}[0-9]{0,2}$']]
    def validate_TNF(self, value):
        # Validate type TNF, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TNF_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TNF_patterns_, ))
    validate_TNF_patterns_ = [[u'^[1-9]{1}[0-9]{0,8}$']]
    def hasContent_(self):
        if (
            self.cUF is not None or
            self.AAMM is not None or
            self.CNPJ is not None or
            self.CPF is not None or
            self.IE is not None or
            self.mod is not None or
            self.serie is not None or
            self.nNF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='refNFPType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refNFPType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='refNFPType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='refNFPType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='refNFPType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='refNFPType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scUF>%s</%scUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cUF), input_name='cUF')), namespaceprefix_ , eol_))
        if self.AAMM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAAMM>%s</%sAAMM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.AAMM), input_name='AAMM')), namespaceprefix_ , eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.IE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smod>%s</%smod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), namespaceprefix_ , eol_))
        if self.serie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserie>%s</%sserie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serie), input_name='serie')), namespaceprefix_ , eol_))
        if self.nNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snNF>%s</%snNF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nNF), input_name='nNF')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cUF':
            cUF_ = child_.text
            cUF_ = self.gds_validate_string(cUF_, node, 'cUF')
            self.cUF = cUF_
            # validate type TCodUfIBGE
            self.validate_TCodUfIBGE(self.cUF)
        elif nodeName_ == 'AAMM':
            AAMM_ = child_.text
            AAMM_ = self.gds_validate_string(AAMM_, node, 'AAMM')
            self.AAMM = AAMM_
            # validate type AAMMType1
            self.validate_AAMMType1(self.AAMM)
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'IE':
            IE_ = child_.text
            IE_ = self.gds_validate_string(IE_, node, 'IE')
            self.IE = IE_
            # validate type TIeDest
            self.validate_TIeDest(self.IE)
        elif nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
            # validate type modType2
            self.validate_modType2(self.mod)
        elif nodeName_ == 'serie':
            serie_ = child_.text
            serie_ = self.gds_validate_string(serie_, node, 'serie')
            self.serie = serie_
            # validate type TSerie
            self.validate_TSerie(self.serie)
        elif nodeName_ == 'nNF':
            nNF_ = child_.text
            nNF_ = self.gds_validate_string(nNF_, node, 'nNF')
            self.nNF = nNF_
            # validate type TNF
            self.validate_TNF(self.nNF)
# end class refNFPType


class refECFType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, mod=None, nECF=None, nCOO=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.mod = mod
        self.validate_modType3(self.mod)
        self.nECF = nECF
        self.validate_nECFType(self.nECF)
        self.nCOO = nCOO
        self.validate_nCOOType(self.nCOO)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, refECFType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if refECFType.subclass:
            return refECFType.subclass(*args_, **kwargs_)
        else:
            return refECFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mod(self):
        return self.mod
    def set_mod(self, mod):
        self.mod = mod
    def get_nECF(self):
        return self.nECF
    def set_nECF(self, nECF):
        self.nECF = nECF
    def get_nCOO(self):
        return self.nCOO
    def set_nCOO(self, nCOO):
        self.nCOO = nCOO
    def validate_modType3(self, value):
        # Validate type modType3, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['2B', '2C', '2D']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modType3' % {"value" : value.encode("utf-8")} )
    def validate_nECFType(self, value):
        # Validate type nECFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nECFType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nECFType_patterns_, ))
    validate_nECFType_patterns_ = [[u'^[0-9]{1,3}$']]
    def validate_nCOOType(self, value):
        # Validate type nCOOType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nCOOType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nCOOType_patterns_, ))
    validate_nCOOType_patterns_ = [[u'^[0-9]{1,6}$']]
    def hasContent_(self):
        if (
            self.mod is not None or
            self.nECF is not None or
            self.nCOO is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='refECFType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('refECFType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='refECFType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='refECFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='refECFType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='refECFType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smod>%s</%smod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mod), input_name='mod')), namespaceprefix_ , eol_))
        if self.nECF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snECF>%s</%snECF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nECF), input_name='nECF')), namespaceprefix_ , eol_))
        if self.nCOO is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snCOO>%s</%snCOO>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nCOO), input_name='nCOO')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mod':
            mod_ = child_.text
            mod_ = self.gds_validate_string(mod_, node, 'mod')
            self.mod = mod_
            # validate type modType3
            self.validate_modType3(self.mod)
        elif nodeName_ == 'nECF':
            nECF_ = child_.text
            nECF_ = self.gds_validate_string(nECF_, node, 'nECF')
            self.nECF = nECF_
            # validate type nECFType
            self.validate_nECFType(self.nECF)
        elif nodeName_ == 'nCOO':
            nCOO_ = child_.text
            nCOO_ = self.gds_validate_string(nCOO_, node, 'nCOO')
            self.nCOO = nCOO_
            # validate type nCOOType
            self.validate_nCOOType(self.nCOO)
# end class refECFType


class emitType(GeneratedsSuper):
    """Grupo de informações de interesse da Prefeitura"""
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, xNome=None, xFant=None, enderEmit=None, IE=None, IEST=None, IM=None, CNAE=None, CRT=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.xNome = xNome
        self.validate_xNomeType(self.xNome)
        self.xFant = xFant
        self.validate_xFantType(self.xFant)
        self.enderEmit = enderEmit
        self.IE = IE
        self.validate_TIe(self.IE)
        self.IEST = IEST
        self.validate_TIeST(self.IEST)
        self.IM = IM
        self.validate_IMType(self.IM)
        self.CNAE = CNAE
        self.validate_CNAEType(self.CNAE)
        self.CRT = CRT
        self.validate_CRTType(self.CRT)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emitType.subclass:
            return emitType.subclass(*args_, **kwargs_)
        else:
            return emitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_xFant(self):
        return self.xFant
    def set_xFant(self, xFant):
        self.xFant = xFant
    def get_enderEmit(self):
        return self.enderEmit
    def set_enderEmit(self, enderEmit):
        self.enderEmit = enderEmit
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_IEST(self):
        return self.IEST
    def set_IEST(self, IEST):
        self.IEST = IEST
    def get_IM(self):
        return self.IM
    def set_IM(self, IM):
        self.IM = IM
    def get_CNAE(self):
        return self.CNAE
    def set_CNAE(self, CNAE):
        self.CNAE = CNAE
    def get_CRT(self):
        return self.CRT
    def set_CRT(self, CRT):
        self.CRT = CRT
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [[u'^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [[u'^[0-9]{11}$']]
    def validate_xNomeType(self, value):
        # Validate type xNomeType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xNomeType' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xNomeType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xNomeType_patterns_, ))
    validate_xNomeType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_xFantType(self, value):
        # Validate type xFantType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xFantType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xFantType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xFantType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xFantType_patterns_, ))
    validate_xFantType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TIe(self, value):
        # Validate type TIe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TIe' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TIe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TIe_patterns_, ))
    validate_TIe_patterns_ = [[u'^[0-9]{2,14}|ISENTO$']]
    def validate_TIeST(self, value):
        # Validate type TIeST, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TIeST' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TIeST_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TIeST_patterns_, ))
    validate_TIeST_patterns_ = [[u'^[0-9]{2,14}$']]
    def validate_IMType(self, value):
        # Validate type IMType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on IMType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on IMType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_IMType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IMType_patterns_, ))
    validate_IMType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_CNAEType(self, value):
        # Validate type CNAEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CNAEType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CNAEType_patterns_, ))
    validate_CNAEType_patterns_ = [[u'^[0-9]{7}$']]
    def validate_CRTType(self, value):
        # Validate type CRTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CRTType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.xNome is not None or
            self.xFant is not None or
            self.enderEmit is not None or
            self.IE is not None or
            self.IEST is not None or
            self.IM is not None or
            self.CNAE is not None or
            self.CRT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='emitType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='emitType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='emitType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='emitType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='emitType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.xFant is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxFant>%s</%sxFant>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xFant), input_name='xFant')), namespaceprefix_ , eol_))
        if self.enderEmit is not None:
            self.enderEmit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enderEmit', pretty_print=pretty_print)
        if self.IE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.IEST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIEST>%s</%sIEST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IEST), input_name='IEST')), namespaceprefix_ , eol_))
        if self.IM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIM>%s</%sIM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IM), input_name='IM')), namespaceprefix_ , eol_))
        if self.CNAE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNAE>%s</%sCNAE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNAE), input_name='CNAE')), namespaceprefix_ , eol_))
        if self.CRT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCRT>%s</%sCRT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CRT), input_name='CRT')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'xNome':
            xNome_ = child_.text
            xNome_ = self.gds_validate_string(xNome_, node, 'xNome')
            self.xNome = xNome_
            # validate type xNomeType
            self.validate_xNomeType(self.xNome)
        elif nodeName_ == 'xFant':
            xFant_ = child_.text
            xFant_ = self.gds_validate_string(xFant_, node, 'xFant')
            self.xFant = xFant_
            # validate type xFantType
            self.validate_xFantType(self.xFant)
        elif nodeName_ == 'enderEmit':
            obj_ = TEnderEmi.factory(parent_object_=self)
            obj_.build(child_)
            self.enderEmit = obj_
            obj_.original_tagname_ = 'enderEmit'
        elif nodeName_ == 'IE':
            IE_ = child_.text
            IE_ = self.gds_validate_string(IE_, node, 'IE')
            self.IE = IE_
            # validate type TIe
            self.validate_TIe(self.IE)
        elif nodeName_ == 'IEST':
            IEST_ = child_.text
            IEST_ = self.gds_validate_string(IEST_, node, 'IEST')
            self.IEST = IEST_
            # validate type TIeST
            self.validate_TIeST(self.IEST)
        elif nodeName_ == 'IM':
            IM_ = child_.text
            IM_ = self.gds_validate_string(IM_, node, 'IM')
            self.IM = IM_
            # validate type IMType
            self.validate_IMType(self.IM)
        elif nodeName_ == 'CNAE':
            CNAE_ = child_.text
            CNAE_ = self.gds_validate_string(CNAE_, node, 'CNAE')
            self.CNAE = CNAE_
            # validate type CNAEType
            self.validate_CNAEType(self.CNAE)
        elif nodeName_ == 'CRT':
            CRT_ = child_.text
            CRT_ = self.gds_validate_string(CRT_, node, 'CRT')
            self.CRT = CRT_
            # validate type CRTType
            self.validate_CRTType(self.CRT)
# end class emitType


class avulsaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, xOrgao=None, matr=None, xAgente=None, fone=None, UF=None, nDAR=None, dEmi=None, vDAR=None, repEmi=None, dPag=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.xOrgao = xOrgao
        self.validate_xOrgaoType(self.xOrgao)
        self.matr = matr
        self.validate_matrType(self.matr)
        self.xAgente = xAgente
        self.validate_xAgenteType(self.xAgente)
        self.fone = fone
        self.validate_foneType(self.fone)
        self.UF = UF
        self.validate_TUfEmi(self.UF)
        self.nDAR = nDAR
        self.validate_nDARType(self.nDAR)
        self.dEmi = dEmi
        self.validate_TData(self.dEmi)
        self.vDAR = vDAR
        self.validate_TDec_1302(self.vDAR)
        self.repEmi = repEmi
        self.validate_repEmiType(self.repEmi)
        self.dPag = dPag
        self.validate_TData(self.dPag)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, avulsaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if avulsaType.subclass:
            return avulsaType.subclass(*args_, **kwargs_)
        else:
            return avulsaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_xOrgao(self):
        return self.xOrgao
    def set_xOrgao(self, xOrgao):
        self.xOrgao = xOrgao
    def get_matr(self):
        return self.matr
    def set_matr(self, matr):
        self.matr = matr
    def get_xAgente(self):
        return self.xAgente
    def set_xAgente(self, xAgente):
        self.xAgente = xAgente
    def get_fone(self):
        return self.fone
    def set_fone(self, fone):
        self.fone = fone
    def get_UF(self):
        return self.UF
    def set_UF(self, UF):
        self.UF = UF
    def get_nDAR(self):
        return self.nDAR
    def set_nDAR(self, nDAR):
        self.nDAR = nDAR
    def get_dEmi(self):
        return self.dEmi
    def set_dEmi(self, dEmi):
        self.dEmi = dEmi
    def get_vDAR(self):
        return self.vDAR
    def set_vDAR(self, vDAR):
        self.vDAR = vDAR
    def get_repEmi(self):
        return self.repEmi
    def set_repEmi(self, repEmi):
        self.repEmi = repEmi
    def get_dPag(self):
        return self.dPag
    def set_dPag(self, dPag):
        self.dPag = dPag
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [[u'^[0-9]{14}$']]
    def validate_xOrgaoType(self, value):
        # Validate type xOrgaoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xOrgaoType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xOrgaoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xOrgaoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xOrgaoType_patterns_, ))
    validate_xOrgaoType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_matrType(self, value):
        # Validate type matrType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on matrType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on matrType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_matrType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_matrType_patterns_, ))
    validate_matrType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_xAgenteType(self, value):
        # Validate type xAgenteType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xAgenteType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xAgenteType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xAgenteType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xAgenteType_patterns_, ))
    validate_xAgenteType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_foneType(self, value):
        # Validate type foneType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_foneType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_foneType_patterns_, ))
    validate_foneType_patterns_ = [[u'^[0-9]{6,14}$']]
    def validate_TUfEmi(self, value):
        # Validate type TUfEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUfEmi' % {"value" : value.encode("utf-8")} )
    def validate_nDARType(self, value):
        # Validate type nDARType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nDARType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nDARType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nDARType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nDARType_patterns_, ))
    validate_nDARType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [[u'^(((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_repEmiType(self, value):
        # Validate type repEmiType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on repEmiType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on repEmiType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_repEmiType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_repEmiType_patterns_, ))
    validate_repEmiType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.xOrgao is not None or
            self.matr is not None or
            self.xAgente is not None or
            self.fone is not None or
            self.UF is not None or
            self.nDAR is not None or
            self.dEmi is not None or
            self.vDAR is not None or
            self.repEmi is not None or
            self.dPag is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='avulsaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('avulsaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='avulsaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='avulsaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='avulsaType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='avulsaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.xOrgao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxOrgao>%s</%sxOrgao>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xOrgao), input_name='xOrgao')), namespaceprefix_ , eol_))
        if self.matr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smatr>%s</%smatr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.matr), input_name='matr')), namespaceprefix_ , eol_))
        if self.xAgente is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxAgente>%s</%sxAgente>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xAgente), input_name='xAgente')), namespaceprefix_ , eol_))
        if self.fone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfone>%s</%sfone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fone), input_name='fone')), namespaceprefix_ , eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespaceprefix_ , eol_))
        if self.nDAR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snDAR>%s</%snDAR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nDAR), input_name='nDAR')), namespaceprefix_ , eol_))
        if self.dEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdEmi>%s</%sdEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dEmi), input_name='dEmi')), namespaceprefix_ , eol_))
        if self.vDAR is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDAR>%s</%svDAR>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDAR), input_name='vDAR')), namespaceprefix_ , eol_))
        if self.repEmi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srepEmi>%s</%srepEmi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.repEmi), input_name='repEmi')), namespaceprefix_ , eol_))
        if self.dPag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdPag>%s</%sdPag>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dPag), input_name='dPag')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'xOrgao':
            xOrgao_ = child_.text
            xOrgao_ = self.gds_validate_string(xOrgao_, node, 'xOrgao')
            self.xOrgao = xOrgao_
            # validate type xOrgaoType
            self.validate_xOrgaoType(self.xOrgao)
        elif nodeName_ == 'matr':
            matr_ = child_.text
            matr_ = self.gds_validate_string(matr_, node, 'matr')
            self.matr = matr_
            # validate type matrType
            self.validate_matrType(self.matr)
        elif nodeName_ == 'xAgente':
            xAgente_ = child_.text
            xAgente_ = self.gds_validate_string(xAgente_, node, 'xAgente')
            self.xAgente = xAgente_
            # validate type xAgenteType
            self.validate_xAgenteType(self.xAgente)
        elif nodeName_ == 'fone':
            fone_ = child_.text
            fone_ = self.gds_validate_string(fone_, node, 'fone')
            self.fone = fone_
            # validate type foneType
            self.validate_foneType(self.fone)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUfEmi
            self.validate_TUfEmi(self.UF)
        elif nodeName_ == 'nDAR':
            nDAR_ = child_.text
            nDAR_ = self.gds_validate_string(nDAR_, node, 'nDAR')
            self.nDAR = nDAR_
            # validate type nDARType
            self.validate_nDARType(self.nDAR)
        elif nodeName_ == 'dEmi':
            dEmi_ = child_.text
            dEmi_ = self.gds_validate_string(dEmi_, node, 'dEmi')
            self.dEmi = dEmi_
            # validate type TData
            self.validate_TData(self.dEmi)
        elif nodeName_ == 'vDAR':
            vDAR_ = child_.text
            vDAR_ = self.gds_validate_string(vDAR_, node, 'vDAR')
            self.vDAR = vDAR_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vDAR)
        elif nodeName_ == 'repEmi':
            repEmi_ = child_.text
            repEmi_ = self.gds_validate_string(repEmi_, node, 'repEmi')
            self.repEmi = repEmi_
            # validate type repEmiType
            self.validate_repEmiType(self.repEmi)
        elif nodeName_ == 'dPag':
            dPag_ = child_.text
            dPag_ = self.gds_validate_string(dPag_, node, 'dPag')
            self.dPag = dPag_
            # validate type TData
            self.validate_TData(self.dPag)
# end class avulsaType


class destType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, idEstrangeiro=None, xNome=None, enderDest=None, indIEDest=None, IE=None, ISUF=None, IM=None, email=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.idEstrangeiro = idEstrangeiro
        self.validate_idEstrangeiroType(self.idEstrangeiro)
        self.xNome = xNome
        self.validate_xNomeType4(self.xNome)
        self.enderDest = enderDest
        self.indIEDest = indIEDest
        self.validate_indIEDestType(self.indIEDest)
        self.IE = IE
        self.validate_TIeDestNaoIsento(self.IE)
        self.ISUF = ISUF
        self.validate_ISUFType(self.ISUF)
        self.IM = IM
        self.validate_IMType5(self.IM)
        self.email = email
        self.validate_emailType(self.email)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, destType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if destType.subclass:
            return destType.subclass(*args_, **kwargs_)
        else:
            return destType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_idEstrangeiro(self):
        return self.idEstrangeiro
    def set_idEstrangeiro(self, idEstrangeiro):
        self.idEstrangeiro = idEstrangeiro
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_enderDest(self):
        return self.enderDest
    def set_enderDest(self, enderDest):
        self.enderDest = enderDest
    def get_indIEDest(self):
        return self.indIEDest
    def set_indIEDest(self, indIEDest):
        self.indIEDest = indIEDest
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_ISUF(self):
        return self.ISUF
    def set_ISUF(self, ISUF):
        self.ISUF = ISUF
    def get_IM(self):
        return self.IM
    def set_IM(self, IM):
        self.IM = IM
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [[u'^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [[u'^[0-9]{11}$']]
    def validate_idEstrangeiroType(self, value):
        # Validate type idEstrangeiroType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_idEstrangeiroType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_idEstrangeiroType_patterns_, ))
    validate_idEstrangeiroType_patterns_ = [[u'^([!-\xff]{0}|[!-\xff]{5,20})?$']]
    def validate_xNomeType4(self, value):
        # Validate type xNomeType4, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xNomeType4' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xNomeType4' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType4_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xNomeType4_patterns_, ))
    validate_xNomeType4_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_indIEDestType(self, value):
        # Validate type indIEDestType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indIEDestType' % {"value" : value.encode("utf-8")} )
    def validate_TIeDestNaoIsento(self, value):
        # Validate type TIeDestNaoIsento, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TIeDestNaoIsento' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TIeDestNaoIsento_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TIeDestNaoIsento_patterns_, ))
    validate_TIeDestNaoIsento_patterns_ = [[u'^[0-9]{2,14}$']]
    def validate_ISUFType(self, value):
        # Validate type ISUFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_ISUFType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_ISUFType_patterns_, ))
    validate_ISUFType_patterns_ = [[u'^[0-9]{8,9}$']]
    def validate_IMType5(self, value):
        # Validate type IMType5, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on IMType5' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on IMType5' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_IMType5_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_IMType5_patterns_, ))
    validate_IMType5_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_emailType(self, value):
        # Validate type emailType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on emailType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on emailType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_emailType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_emailType_patterns_, ))
    validate_emailType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.idEstrangeiro is not None or
            self.xNome is not None or
            self.enderDest is not None or
            self.indIEDest is not None or
            self.IE is not None or
            self.ISUF is not None or
            self.IM is not None or
            self.email is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='destType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('destType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='destType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='destType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='destType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='destType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.idEstrangeiro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sidEstrangeiro>%s</%sidEstrangeiro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.idEstrangeiro), input_name='idEstrangeiro')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.enderDest is not None:
            self.enderDest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='enderDest', pretty_print=pretty_print)
        if self.indIEDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindIEDest>%s</%sindIEDest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indIEDest), input_name='indIEDest')), namespaceprefix_ , eol_))
        if self.IE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.ISUF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sISUF>%s</%sISUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ISUF), input_name='ISUF')), namespaceprefix_ , eol_))
        if self.IM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIM>%s</%sIM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IM), input_name='IM')), namespaceprefix_ , eol_))
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'idEstrangeiro':
            idEstrangeiro_ = child_.text
            idEstrangeiro_ = self.gds_validate_string(idEstrangeiro_, node, 'idEstrangeiro')
            self.idEstrangeiro = idEstrangeiro_
            # validate type idEstrangeiroType
            self.validate_idEstrangeiroType(self.idEstrangeiro)
        elif nodeName_ == 'xNome':
            xNome_ = child_.text
            xNome_ = self.gds_validate_string(xNome_, node, 'xNome')
            self.xNome = xNome_
            # validate type xNomeType4
            self.validate_xNomeType4(self.xNome)
        elif nodeName_ == 'enderDest':
            obj_ = TEndereco.factory(parent_object_=self)
            obj_.build(child_)
            self.enderDest = obj_
            obj_.original_tagname_ = 'enderDest'
        elif nodeName_ == 'indIEDest':
            indIEDest_ = child_.text
            indIEDest_ = self.gds_validate_string(indIEDest_, node, 'indIEDest')
            self.indIEDest = indIEDest_
            # validate type indIEDestType
            self.validate_indIEDestType(self.indIEDest)
        elif nodeName_ == 'IE':
            IE_ = child_.text
            IE_ = self.gds_validate_string(IE_, node, 'IE')
            self.IE = IE_
            # validate type TIeDestNaoIsento
            self.validate_TIeDestNaoIsento(self.IE)
        elif nodeName_ == 'ISUF':
            ISUF_ = child_.text
            ISUF_ = self.gds_validate_string(ISUF_, node, 'ISUF')
            self.ISUF = ISUF_
            # validate type ISUFType
            self.validate_ISUFType(self.ISUF)
        elif nodeName_ == 'IM':
            IM_ = child_.text
            IM_ = self.gds_validate_string(IM_, node, 'IM')
            self.IM = IM_
            # validate type IMType5
            self.validate_IMType5(self.IM)
        elif nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
            # validate type emailType
            self.validate_emailType(self.email)
# end class destType


class autXMLType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, autXMLType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if autXMLType.subclass:
            return autXMLType.subclass(*args_, **kwargs_)
        else:
            return autXMLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [[u'^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [[u'^[0-9]{11}$']]
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='autXMLType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('autXMLType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='autXMLType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='autXMLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='autXMLType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='autXMLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
# end class autXMLType


class detType(GeneratedsSuper):
    """Número do item do NF"""
    subclass = None
    superclass = None
    def __init__(self, nItem=None, prod=None, imposto=None, impostoDevol=None, infAdProd=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.nItem = _cast(None, nItem)
        self.prod = prod
        self.imposto = imposto
        self.impostoDevol = impostoDevol
        self.infAdProd = infAdProd
        self.validate_infAdProdType(self.infAdProd)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detType.subclass:
            return detType.subclass(*args_, **kwargs_)
        else:
            return detType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_prod(self):
        return self.prod
    def set_prod(self, prod):
        self.prod = prod
    def get_imposto(self):
        return self.imposto
    def set_imposto(self, imposto):
        self.imposto = imposto
    def get_impostoDevol(self):
        return self.impostoDevol
    def set_impostoDevol(self, impostoDevol):
        self.impostoDevol = impostoDevol
    def get_infAdProd(self):
        return self.infAdProd
    def set_infAdProd(self, infAdProd):
        self.infAdProd = infAdProd
    def get_nItem(self):
        return self.nItem
    def set_nItem(self, nItem):
        self.nItem = nItem
    def validate_infAdProdType(self, value):
        # Validate type infAdProdType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 500:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on infAdProdType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on infAdProdType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_infAdProdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_infAdProdType_patterns_, ))
    validate_infAdProdType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.prod is not None or
            self.imposto is not None or
            self.impostoDevol is not None or
            self.infAdProd is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='detType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='detType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='detType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='detType'):
        if self.nItem is not None and 'nItem' not in already_processed:
            already_processed.add('nItem')
            outfile.write(' nItem=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.nItem), input_name='nItem')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='detType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.prod is not None:
            self.prod.export(outfile, level, namespaceprefix_, namespacedef_='', name_='prod', pretty_print=pretty_print)
        if self.imposto is not None:
            self.imposto.export(outfile, level, namespaceprefix_, namespacedef_='', name_='imposto', pretty_print=pretty_print)
        if self.impostoDevol is not None:
            self.impostoDevol.export(outfile, level, namespaceprefix_, namespacedef_='', name_='impostoDevol', pretty_print=pretty_print)
        if self.infAdProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinfAdProd>%s</%sinfAdProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.infAdProd), input_name='infAdProd')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nItem', node)
        if value is not None and 'nItem' not in already_processed:
            already_processed.add('nItem')
            self.nItem = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'prod':
            obj_ = prodType.factory(parent_object_=self)
            obj_.build(child_)
            self.prod = obj_
            obj_.original_tagname_ = 'prod'
        elif nodeName_ == 'imposto':
            obj_ = impostoType.factory(parent_object_=self)
            obj_.build(child_)
            self.imposto = obj_
            obj_.original_tagname_ = 'imposto'
        elif nodeName_ == 'impostoDevol':
            obj_ = impostoDevolType.factory(parent_object_=self)
            obj_.build(child_)
            self.impostoDevol = obj_
            obj_.original_tagname_ = 'impostoDevol'
        elif nodeName_ == 'infAdProd':
            infAdProd_ = child_.text
            infAdProd_ = self.gds_validate_string(infAdProd_, node, 'infAdProd')
            self.infAdProd = infAdProd_
            # validate type infAdProdType
            self.validate_infAdProdType(self.infAdProd)
# end class detType


class prodType(GeneratedsSuper):
    """Informações específicas de produtos e serviços"""
    subclass = None
    superclass = None
    def __init__(self, cProd=None, cEAN=None, xProd=None, NCM=None, NVE=None, CEST=None, indEscala=None, CNPJFab=None, cBenef=None, EXTIPI=None, CFOP=None, uCom=None, qCom=None, vUnCom=None, vProd=None, cEANTrib=None, uTrib=None, qTrib=None, vUnTrib=None, vFrete=None, vSeg=None, vDesc=None, vOutro=None, indTot=None, DI=None, detExport=None, xPed=None, nItemPed=None, nFCI=None, rastro=None, veicProd=None, med=None, arma=None, comb=None, nRECOPI=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.cProd = cProd
        self.validate_cProdType(self.cProd)
        self.cEAN = cEAN
        self.validate_cEANType(self.cEAN)
        self.xProd = xProd
        self.validate_xProdType(self.xProd)
        self.NCM = NCM
        self.validate_NCMType(self.NCM)
        if NVE is None:
            self.NVE = []
        else:
            self.NVE = NVE
        self.CEST = CEST
        self.validate_CESTType(self.CEST)
        self.indEscala = indEscala
        self.validate_indEscalaType(self.indEscala)
        self.CNPJFab = CNPJFab
        self.validate_TCnpj(self.CNPJFab)
        self.cBenef = cBenef
        self.validate_cBenefType(self.cBenef)
        self.EXTIPI = EXTIPI
        self.validate_EXTIPIType(self.EXTIPI)
        self.CFOP = CFOP
        self.validate_CFOPType(self.CFOP)
        self.uCom = uCom
        self.validate_uComType(self.uCom)
        self.qCom = qCom
        self.validate_TDec_1104v(self.qCom)
        self.vUnCom = vUnCom
        self.validate_TDec_1110v(self.vUnCom)
        self.vProd = vProd
        self.validate_TDec_1302(self.vProd)
        self.cEANTrib = cEANTrib
        self.validate_cEANTribType(self.cEANTrib)
        self.uTrib = uTrib
        self.validate_uTribType(self.uTrib)
        self.qTrib = qTrib
        self.validate_TDec_1104v(self.qTrib)
        self.vUnTrib = vUnTrib
        self.validate_TDec_1110v(self.vUnTrib)
        self.vFrete = vFrete
        self.validate_TDec_1302Opc(self.vFrete)
        self.vSeg = vSeg
        self.validate_TDec_1302Opc(self.vSeg)
        self.vDesc = vDesc
        self.validate_TDec_1302Opc(self.vDesc)
        self.vOutro = vOutro
        self.validate_TDec_1302Opc(self.vOutro)
        self.indTot = indTot
        self.validate_indTotType(self.indTot)
        if DI is None:
            self.DI = []
        else:
            self.DI = DI
        if detExport is None:
            self.detExport = []
        else:
            self.detExport = detExport
        self.xPed = xPed
        self.validate_xPedType(self.xPed)
        self.nItemPed = nItemPed
        self.validate_nItemPedType(self.nItemPed)
        self.nFCI = nFCI
        self.validate_TGuid(self.nFCI)
        if rastro is None:
            self.rastro = []
        else:
            self.rastro = rastro
        self.veicProd = veicProd
        self.med = med
        if arma is None:
            self.arma = []
        else:
            self.arma = arma
        self.comb = comb
        self.nRECOPI = nRECOPI
        self.validate_nRECOPIType(self.nRECOPI)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, prodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if prodType.subclass:
            return prodType.subclass(*args_, **kwargs_)
        else:
            return prodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cProd(self):
        return self.cProd
    def set_cProd(self, cProd):
        self.cProd = cProd
    def get_cEAN(self):
        return self.cEAN
    def set_cEAN(self, cEAN):
        self.cEAN = cEAN
    def get_xProd(self):
        return self.xProd
    def set_xProd(self, xProd):
        self.xProd = xProd
    def get_NCM(self):
        return self.NCM
    def set_NCM(self, NCM):
        self.NCM = NCM
    def get_NVE(self):
        return self.NVE
    def set_NVE(self, NVE):
        self.NVE = NVE
    def add_NVE(self, value):
        self.NVE.append(value)
    def add_NVE(self, value):
        self.NVE.append(value)
    def insert_NVE_at(self, index, value):
        self.NVE.insert(index, value)
    def replace_NVE_at(self, index, value):
        self.NVE[index] = value
    def get_CEST(self):
        return self.CEST
    def set_CEST(self, CEST):
        self.CEST = CEST
    def get_indEscala(self):
        return self.indEscala
    def set_indEscala(self, indEscala):
        self.indEscala = indEscala
    def get_CNPJFab(self):
        return self.CNPJFab
    def set_CNPJFab(self, CNPJFab):
        self.CNPJFab = CNPJFab
    def get_cBenef(self):
        return self.cBenef
    def set_cBenef(self, cBenef):
        self.cBenef = cBenef
    def get_EXTIPI(self):
        return self.EXTIPI
    def set_EXTIPI(self, EXTIPI):
        self.EXTIPI = EXTIPI
    def get_CFOP(self):
        return self.CFOP
    def set_CFOP(self, CFOP):
        self.CFOP = CFOP
    def get_uCom(self):
        return self.uCom
    def set_uCom(self, uCom):
        self.uCom = uCom
    def get_qCom(self):
        return self.qCom
    def set_qCom(self, qCom):
        self.qCom = qCom
    def get_vUnCom(self):
        return self.vUnCom
    def set_vUnCom(self, vUnCom):
        self.vUnCom = vUnCom
    def get_vProd(self):
        return self.vProd
    def set_vProd(self, vProd):
        self.vProd = vProd
    def get_cEANTrib(self):
        return self.cEANTrib
    def set_cEANTrib(self, cEANTrib):
        self.cEANTrib = cEANTrib
    def get_uTrib(self):
        return self.uTrib
    def set_uTrib(self, uTrib):
        self.uTrib = uTrib
    def get_qTrib(self):
        return self.qTrib
    def set_qTrib(self, qTrib):
        self.qTrib = qTrib
    def get_vUnTrib(self):
        return self.vUnTrib
    def set_vUnTrib(self, vUnTrib):
        self.vUnTrib = vUnTrib
    def get_vFrete(self):
        return self.vFrete
    def set_vFrete(self, vFrete):
        self.vFrete = vFrete
    def get_vSeg(self):
        return self.vSeg
    def set_vSeg(self, vSeg):
        self.vSeg = vSeg
    def get_vDesc(self):
        return self.vDesc
    def set_vDesc(self, vDesc):
        self.vDesc = vDesc
    def get_vOutro(self):
        return self.vOutro
    def set_vOutro(self, vOutro):
        self.vOutro = vOutro
    def get_indTot(self):
        return self.indTot
    def set_indTot(self, indTot):
        self.indTot = indTot
    def get_DI(self):
        return self.DI
    def set_DI(self, DI):
        self.DI = DI
    def add_DI(self, value):
        self.DI.append(value)
    def add_DI(self, value):
        self.DI.append(value)
    def insert_DI_at(self, index, value):
        self.DI.insert(index, value)
    def replace_DI_at(self, index, value):
        self.DI[index] = value
    def get_detExport(self):
        return self.detExport
    def set_detExport(self, detExport):
        self.detExport = detExport
    def add_detExport(self, value):
        self.detExport.append(value)
    def add_detExport(self, value):
        self.detExport.append(value)
    def insert_detExport_at(self, index, value):
        self.detExport.insert(index, value)
    def replace_detExport_at(self, index, value):
        self.detExport[index] = value
    def get_xPed(self):
        return self.xPed
    def set_xPed(self, xPed):
        self.xPed = xPed
    def get_nItemPed(self):
        return self.nItemPed
    def set_nItemPed(self, nItemPed):
        self.nItemPed = nItemPed
    def get_nFCI(self):
        return self.nFCI
    def set_nFCI(self, nFCI):
        self.nFCI = nFCI
    def get_rastro(self):
        return self.rastro
    def set_rastro(self, rastro):
        self.rastro = rastro
    def add_rastro(self, value):
        self.rastro.append(value)
    def add_rastro(self, value):
        self.rastro.append(value)
    def insert_rastro_at(self, index, value):
        self.rastro.insert(index, value)
    def replace_rastro_at(self, index, value):
        self.rastro[index] = value
    def get_veicProd(self):
        return self.veicProd
    def set_veicProd(self, veicProd):
        self.veicProd = veicProd
    def get_med(self):
        return self.med
    def set_med(self, med):
        self.med = med
    def get_arma(self):
        return self.arma
    def set_arma(self, arma):
        self.arma = arma
    def add_arma(self, value):
        self.arma.append(value)
    def add_arma(self, value):
        self.arma.append(value)
    def insert_arma_at(self, index, value):
        self.arma.insert(index, value)
    def replace_arma_at(self, index, value):
        self.arma[index] = value
    def get_comb(self):
        return self.comb
    def set_comb(self, comb):
        self.comb = comb
    def get_nRECOPI(self):
        return self.nRECOPI
    def set_nRECOPI(self, nRECOPI):
        self.nRECOPI = nRECOPI
    def validate_cProdType(self, value):
        # Validate type cProdType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cProdType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cProdType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cProdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cProdType_patterns_, ))
    validate_cProdType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_cEANType(self, value):
        # Validate type cEANType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cEANType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cEANType_patterns_, ))
    validate_cEANType_patterns_ = [[u'^SEM GTIN|[0-9]{0}|[0-9]{8}|[0-9]{12,14}$']]
    def validate_xProdType(self, value):
        # Validate type xProdType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 120:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xProdType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xProdType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xProdType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xProdType_patterns_, ))
    validate_xProdType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_NCMType(self, value):
        # Validate type NCMType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_NCMType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_NCMType_patterns_, ))
    validate_NCMType_patterns_ = [[u'^[0-9]{2}|[0-9]{8}$']]
    def validate_NVEType(self, value):
        # Validate type NVEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_NVEType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_NVEType_patterns_, ))
    validate_NVEType_patterns_ = [[u'^[A-Z]{2}[0-9]{4}$']]
    def validate_CESTType(self, value):
        # Validate type CESTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CESTType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CESTType_patterns_, ))
    validate_CESTType_patterns_ = [[u'^[0-9]{7}$']]
    def validate_indEscalaType(self, value):
        # Validate type indEscalaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['S', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indEscalaType' % {"value" : value.encode("utf-8")} )
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [[u'^[0-9]{14}$']]
    def validate_cBenefType(self, value):
        # Validate type cBenefType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cBenefType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cBenefType_patterns_, ))
    validate_cBenefType_patterns_ = [[u'^([!-\xff]{8}|[!-\xff]{10})?$']]
    def validate_EXTIPIType(self, value):
        # Validate type EXTIPIType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_EXTIPIType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_EXTIPIType_patterns_, ))
    validate_EXTIPIType_patterns_ = [[u'^[0-9]{2,3}$']]
    def validate_CFOPType(self, value):
        # Validate type CFOPType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CFOPType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CFOPType_patterns_, ))
    validate_CFOPType_patterns_ = [[u'^[1,2,3,5,6,7]{1}[0-9]{3}$']]
    def validate_uComType(self, value):
        # Validate type uComType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on uComType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on uComType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_uComType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_uComType_patterns_, ))
    validate_uComType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [[u'^0|0\\.[0-9]{1,4}|[1-9]{1}[0-9]{0,10}|[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1110v(self, value):
        # Validate type TDec_1110v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1110v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1110v_patterns_, ))
    validate_TDec_1110v_patterns_ = [[u'^0|0\\.[0-9]{1,10}|[1-9]{1}[0-9]{0,10}|[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,10})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_cEANTribType(self, value):
        # Validate type cEANTribType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cEANTribType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cEANTribType_patterns_, ))
    validate_cEANTribType_patterns_ = [[u'^SEM GTIN|[0-9]{0}|[0-9]{8}|[0-9]{12,14}$']]
    def validate_uTribType(self, value):
        # Validate type uTribType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 6:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on uTribType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on uTribType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_uTribType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_uTribType_patterns_, ))
    validate_uTribType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [[u'^0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_indTotType(self, value):
        # Validate type indTotType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indTotType' % {"value" : value.encode("utf-8")} )
    def validate_xPedType(self, value):
        # Validate type xPedType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xPedType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xPedType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xPedType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xPedType_patterns_, ))
    validate_xPedType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_nItemPedType(self, value):
        # Validate type nItemPedType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nItemPedType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nItemPedType_patterns_, ))
    validate_nItemPedType_patterns_ = [[u'^[0-9]{1,6}$']]
    def validate_TGuid(self, value):
        # Validate type TGuid, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TGuid_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TGuid_patterns_, ))
    validate_TGuid_patterns_ = [[u'^[A-F0-9]{8}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{4}-[A-F0-9]{12}$']]
    def validate_nRECOPIType(self, value):
        # Validate type nRECOPIType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nRECOPIType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nRECOPIType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nRECOPIType_patterns_, ))
    validate_nRECOPIType_patterns_ = [[u'^[0-9]{20}$']]
    def hasContent_(self):
        if (
            self.cProd is not None or
            self.cEAN is not None or
            self.xProd is not None or
            self.NCM is not None or
            self.NVE or
            self.CEST is not None or
            self.indEscala is not None or
            self.CNPJFab is not None or
            self.cBenef is not None or
            self.EXTIPI is not None or
            self.CFOP is not None or
            self.uCom is not None or
            self.qCom is not None or
            self.vUnCom is not None or
            self.vProd is not None or
            self.cEANTrib is not None or
            self.uTrib is not None or
            self.qTrib is not None or
            self.vUnTrib is not None or
            self.vFrete is not None or
            self.vSeg is not None or
            self.vDesc is not None or
            self.vOutro is not None or
            self.indTot is not None or
            self.DI or
            self.detExport or
            self.xPed is not None or
            self.nItemPed is not None or
            self.nFCI is not None or
            self.rastro or
            self.veicProd is not None or
            self.med is not None or
            self.arma or
            self.comb is not None or
            self.nRECOPI is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='prodType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('prodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='prodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='prodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='prodType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='prodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scProd>%s</%scProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cProd), input_name='cProd')), namespaceprefix_ , eol_))
        if self.cEAN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scEAN>%s</%scEAN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cEAN), input_name='cEAN')), namespaceprefix_ , eol_))
        if self.xProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxProd>%s</%sxProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xProd), input_name='xProd')), namespaceprefix_ , eol_))
        if self.NCM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNCM>%s</%sNCM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.NCM), input_name='NCM')), namespaceprefix_ , eol_))
        for NVE_ in self.NVE:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNVE>%s</%sNVE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(NVE_), input_name='NVE')), namespaceprefix_ , eol_))
        if self.CEST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCEST>%s</%sCEST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CEST), input_name='CEST')), namespaceprefix_ , eol_))
        if self.indEscala is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindEscala>%s</%sindEscala>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indEscala), input_name='indEscala')), namespaceprefix_ , eol_))
        if self.CNPJFab is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJFab>%s</%sCNPJFab>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJFab), input_name='CNPJFab')), namespaceprefix_ , eol_))
        if self.cBenef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scBenef>%s</%scBenef>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cBenef), input_name='cBenef')), namespaceprefix_ , eol_))
        if self.EXTIPI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEXTIPI>%s</%sEXTIPI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EXTIPI), input_name='EXTIPI')), namespaceprefix_ , eol_))
        if self.CFOP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCFOP>%s</%sCFOP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CFOP), input_name='CFOP')), namespaceprefix_ , eol_))
        if self.uCom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suCom>%s</%suCom>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.uCom), input_name='uCom')), namespaceprefix_ , eol_))
        if self.qCom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqCom>%s</%sqCom>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qCom), input_name='qCom')), namespaceprefix_ , eol_))
        if self.vUnCom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svUnCom>%s</%svUnCom>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vUnCom), input_name='vUnCom')), namespaceprefix_ , eol_))
        if self.vProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svProd>%s</%svProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vProd), input_name='vProd')), namespaceprefix_ , eol_))
        if self.cEANTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scEANTrib>%s</%scEANTrib>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cEANTrib), input_name='cEANTrib')), namespaceprefix_ , eol_))
        if self.uTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suTrib>%s</%suTrib>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.uTrib), input_name='uTrib')), namespaceprefix_ , eol_))
        if self.qTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqTrib>%s</%sqTrib>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qTrib), input_name='qTrib')), namespaceprefix_ , eol_))
        if self.vUnTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svUnTrib>%s</%svUnTrib>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vUnTrib), input_name='vUnTrib')), namespaceprefix_ , eol_))
        if self.vFrete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFrete>%s</%svFrete>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFrete), input_name='vFrete')), namespaceprefix_ , eol_))
        if self.vSeg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svSeg>%s</%svSeg>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vSeg), input_name='vSeg')), namespaceprefix_ , eol_))
        if self.vDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDesc>%s</%svDesc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDesc), input_name='vDesc')), namespaceprefix_ , eol_))
        if self.vOutro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svOutro>%s</%svOutro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vOutro), input_name='vOutro')), namespaceprefix_ , eol_))
        if self.indTot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindTot>%s</%sindTot>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indTot), input_name='indTot')), namespaceprefix_ , eol_))
        for DI_ in self.DI:
            DI_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DI', pretty_print=pretty_print)
        for detExport_ in self.detExport:
            detExport_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='detExport', pretty_print=pretty_print)
        if self.xPed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxPed>%s</%sxPed>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xPed), input_name='xPed')), namespaceprefix_ , eol_))
        if self.nItemPed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snItemPed>%s</%snItemPed>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nItemPed), input_name='nItemPed')), namespaceprefix_ , eol_))
        if self.nFCI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snFCI>%s</%snFCI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nFCI), input_name='nFCI')), namespaceprefix_ , eol_))
        for rastro_ in self.rastro:
            rastro_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rastro', pretty_print=pretty_print)
        if self.veicProd is not None:
            self.veicProd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='veicProd', pretty_print=pretty_print)
        if self.med is not None:
            self.med.export(outfile, level, namespaceprefix_, namespacedef_='', name_='med', pretty_print=pretty_print)
        for arma_ in self.arma:
            arma_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='arma', pretty_print=pretty_print)
        if self.comb is not None:
            self.comb.export(outfile, level, namespaceprefix_, namespacedef_='', name_='comb', pretty_print=pretty_print)
        if self.nRECOPI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snRECOPI>%s</%snRECOPI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nRECOPI), input_name='nRECOPI')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cProd':
            cProd_ = child_.text
            cProd_ = self.gds_validate_string(cProd_, node, 'cProd')
            self.cProd = cProd_
            # validate type cProdType
            self.validate_cProdType(self.cProd)
        elif nodeName_ == 'cEAN':
            cEAN_ = child_.text
            cEAN_ = self.gds_validate_string(cEAN_, node, 'cEAN')
            self.cEAN = cEAN_
            # validate type cEANType
            self.validate_cEANType(self.cEAN)
        elif nodeName_ == 'xProd':
            xProd_ = child_.text
            xProd_ = self.gds_validate_string(xProd_, node, 'xProd')
            self.xProd = xProd_
            # validate type xProdType
            self.validate_xProdType(self.xProd)
        elif nodeName_ == 'NCM':
            NCM_ = child_.text
            NCM_ = self.gds_validate_string(NCM_, node, 'NCM')
            self.NCM = NCM_
            # validate type NCMType
            self.validate_NCMType(self.NCM)
        elif nodeName_ == 'NVE':
            NVE_ = child_.text
            NVE_ = self.gds_validate_string(NVE_, node, 'NVE')
            self.NVE.append(NVE_)
            # validate type NVEType
            self.validate_NVEType(self.NVE[-1])
        elif nodeName_ == 'CEST':
            CEST_ = child_.text
            CEST_ = self.gds_validate_string(CEST_, node, 'CEST')
            self.CEST = CEST_
            # validate type CESTType
            self.validate_CESTType(self.CEST)
        elif nodeName_ == 'indEscala':
            indEscala_ = child_.text
            indEscala_ = self.gds_validate_string(indEscala_, node, 'indEscala')
            self.indEscala = indEscala_
            # validate type indEscalaType
            self.validate_indEscalaType(self.indEscala)
        elif nodeName_ == 'CNPJFab':
            CNPJFab_ = child_.text
            CNPJFab_ = self.gds_validate_string(CNPJFab_, node, 'CNPJFab')
            self.CNPJFab = CNPJFab_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJFab)
        elif nodeName_ == 'cBenef':
            cBenef_ = child_.text
            cBenef_ = self.gds_validate_string(cBenef_, node, 'cBenef')
            self.cBenef = cBenef_
            # validate type cBenefType
            self.validate_cBenefType(self.cBenef)
        elif nodeName_ == 'EXTIPI':
            EXTIPI_ = child_.text
            EXTIPI_ = self.gds_validate_string(EXTIPI_, node, 'EXTIPI')
            self.EXTIPI = EXTIPI_
            # validate type EXTIPIType
            self.validate_EXTIPIType(self.EXTIPI)
        elif nodeName_ == 'CFOP':
            CFOP_ = child_.text
            CFOP_ = self.gds_validate_string(CFOP_, node, 'CFOP')
            self.CFOP = CFOP_
            # validate type CFOPType
            self.validate_CFOPType(self.CFOP)
        elif nodeName_ == 'uCom':
            uCom_ = child_.text
            uCom_ = self.gds_validate_string(uCom_, node, 'uCom')
            self.uCom = uCom_
            # validate type uComType
            self.validate_uComType(self.uCom)
        elif nodeName_ == 'qCom':
            qCom_ = child_.text
            qCom_ = self.gds_validate_string(qCom_, node, 'qCom')
            self.qCom = qCom_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.qCom)
        elif nodeName_ == 'vUnCom':
            vUnCom_ = child_.text
            vUnCom_ = self.gds_validate_string(vUnCom_, node, 'vUnCom')
            self.vUnCom = vUnCom_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.vUnCom)
        elif nodeName_ == 'vProd':
            vProd_ = child_.text
            vProd_ = self.gds_validate_string(vProd_, node, 'vProd')
            self.vProd = vProd_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vProd)
        elif nodeName_ == 'cEANTrib':
            cEANTrib_ = child_.text
            cEANTrib_ = self.gds_validate_string(cEANTrib_, node, 'cEANTrib')
            self.cEANTrib = cEANTrib_
            # validate type cEANTribType
            self.validate_cEANTribType(self.cEANTrib)
        elif nodeName_ == 'uTrib':
            uTrib_ = child_.text
            uTrib_ = self.gds_validate_string(uTrib_, node, 'uTrib')
            self.uTrib = uTrib_
            # validate type uTribType
            self.validate_uTribType(self.uTrib)
        elif nodeName_ == 'qTrib':
            qTrib_ = child_.text
            qTrib_ = self.gds_validate_string(qTrib_, node, 'qTrib')
            self.qTrib = qTrib_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.qTrib)
        elif nodeName_ == 'vUnTrib':
            vUnTrib_ = child_.text
            vUnTrib_ = self.gds_validate_string(vUnTrib_, node, 'vUnTrib')
            self.vUnTrib = vUnTrib_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.vUnTrib)
        elif nodeName_ == 'vFrete':
            vFrete_ = child_.text
            vFrete_ = self.gds_validate_string(vFrete_, node, 'vFrete')
            self.vFrete = vFrete_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vFrete)
        elif nodeName_ == 'vSeg':
            vSeg_ = child_.text
            vSeg_ = self.gds_validate_string(vSeg_, node, 'vSeg')
            self.vSeg = vSeg_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vSeg)
        elif nodeName_ == 'vDesc':
            vDesc_ = child_.text
            vDesc_ = self.gds_validate_string(vDesc_, node, 'vDesc')
            self.vDesc = vDesc_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDesc)
        elif nodeName_ == 'vOutro':
            vOutro_ = child_.text
            vOutro_ = self.gds_validate_string(vOutro_, node, 'vOutro')
            self.vOutro = vOutro_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vOutro)
        elif nodeName_ == 'indTot':
            indTot_ = child_.text
            indTot_ = self.gds_validate_string(indTot_, node, 'indTot')
            self.indTot = indTot_
            # validate type indTotType
            self.validate_indTotType(self.indTot)
        elif nodeName_ == 'DI':
            obj_ = DIType.factory(parent_object_=self)
            obj_.build(child_)
            self.DI.append(obj_)
            obj_.original_tagname_ = 'DI'
        elif nodeName_ == 'detExport':
            obj_ = detExportType.factory(parent_object_=self)
            obj_.build(child_)
            self.detExport.append(obj_)
            obj_.original_tagname_ = 'detExport'
        elif nodeName_ == 'xPed':
            xPed_ = child_.text
            xPed_ = self.gds_validate_string(xPed_, node, 'xPed')
            self.xPed = xPed_
            # validate type xPedType
            self.validate_xPedType(self.xPed)
        elif nodeName_ == 'nItemPed':
            nItemPed_ = child_.text
            nItemPed_ = self.gds_validate_string(nItemPed_, node, 'nItemPed')
            self.nItemPed = nItemPed_
            # validate type nItemPedType
            self.validate_nItemPedType(self.nItemPed)
        elif nodeName_ == 'nFCI':
            nFCI_ = child_.text
            nFCI_ = self.gds_validate_string(nFCI_, node, 'nFCI')
            self.nFCI = nFCI_
            # validate type TGuid
            self.validate_TGuid(self.nFCI)
        elif nodeName_ == 'rastro':
            obj_ = rastroType.factory(parent_object_=self)
            obj_.build(child_)
            self.rastro.append(obj_)
            obj_.original_tagname_ = 'rastro'
        elif nodeName_ == 'veicProd':
            obj_ = veicProdType.factory(parent_object_=self)
            obj_.build(child_)
            self.veicProd = obj_
            obj_.original_tagname_ = 'veicProd'
        elif nodeName_ == 'med':
            obj_ = medType.factory(parent_object_=self)
            obj_.build(child_)
            self.med = obj_
            obj_.original_tagname_ = 'med'
        elif nodeName_ == 'arma':
            obj_ = armaType.factory(parent_object_=self)
            obj_.build(child_)
            self.arma.append(obj_)
            obj_.original_tagname_ = 'arma'
        elif nodeName_ == 'comb':
            obj_ = combType.factory(parent_object_=self)
            obj_.build(child_)
            self.comb = obj_
            obj_.original_tagname_ = 'comb'
        elif nodeName_ == 'nRECOPI':
            nRECOPI_ = child_.text
            nRECOPI_ = self.gds_validate_string(nRECOPI_, node, 'nRECOPI')
            self.nRECOPI = nRECOPI_
            # validate type nRECOPIType
            self.validate_nRECOPIType(self.nRECOPI)
# end class prodType


class DIType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nDI=None, dDI=None, xLocDesemb=None, UFDesemb=None, dDesemb=None, tpViaTransp=None, vAFRMM=None, tpIntermedio=None, CNPJ=None, UFTerceiro=None, cExportador=None, adi=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.nDI = nDI
        self.validate_nDIType(self.nDI)
        self.dDI = dDI
        self.validate_TData(self.dDI)
        self.xLocDesemb = xLocDesemb
        self.validate_xLocDesembType(self.xLocDesemb)
        self.UFDesemb = UFDesemb
        self.validate_TUfEmi(self.UFDesemb)
        self.dDesemb = dDesemb
        self.validate_TData(self.dDesemb)
        self.tpViaTransp = tpViaTransp
        self.validate_tpViaTranspType(self.tpViaTransp)
        self.vAFRMM = vAFRMM
        self.validate_TDec_1302(self.vAFRMM)
        self.tpIntermedio = tpIntermedio
        self.validate_tpIntermedioType(self.tpIntermedio)
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.UFTerceiro = UFTerceiro
        self.validate_TUfEmi(self.UFTerceiro)
        self.cExportador = cExportador
        self.validate_cExportadorType(self.cExportador)
        if adi is None:
            self.adi = []
        else:
            self.adi = adi
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DIType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DIType.subclass:
            return DIType.subclass(*args_, **kwargs_)
        else:
            return DIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nDI(self):
        return self.nDI
    def set_nDI(self, nDI):
        self.nDI = nDI
    def get_dDI(self):
        return self.dDI
    def set_dDI(self, dDI):
        self.dDI = dDI
    def get_xLocDesemb(self):
        return self.xLocDesemb
    def set_xLocDesemb(self, xLocDesemb):
        self.xLocDesemb = xLocDesemb
    def get_UFDesemb(self):
        return self.UFDesemb
    def set_UFDesemb(self, UFDesemb):
        self.UFDesemb = UFDesemb
    def get_dDesemb(self):
        return self.dDesemb
    def set_dDesemb(self, dDesemb):
        self.dDesemb = dDesemb
    def get_tpViaTransp(self):
        return self.tpViaTransp
    def set_tpViaTransp(self, tpViaTransp):
        self.tpViaTransp = tpViaTransp
    def get_vAFRMM(self):
        return self.vAFRMM
    def set_vAFRMM(self, vAFRMM):
        self.vAFRMM = vAFRMM
    def get_tpIntermedio(self):
        return self.tpIntermedio
    def set_tpIntermedio(self, tpIntermedio):
        self.tpIntermedio = tpIntermedio
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_UFTerceiro(self):
        return self.UFTerceiro
    def set_UFTerceiro(self, UFTerceiro):
        self.UFTerceiro = UFTerceiro
    def get_cExportador(self):
        return self.cExportador
    def set_cExportador(self, cExportador):
        self.cExportador = cExportador
    def get_adi(self):
        return self.adi
    def set_adi(self, adi):
        self.adi = adi
    def add_adi(self, value):
        self.adi.append(value)
    def add_adi(self, value):
        self.adi.append(value)
    def insert_adi_at(self, index, value):
        self.adi.insert(index, value)
    def replace_adi_at(self, index, value):
        self.adi[index] = value
    def validate_nDIType(self, value):
        # Validate type nDIType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 12:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nDIType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nDIType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nDIType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nDIType_patterns_, ))
    validate_nDIType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [[u'^(((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))$']]
    def validate_xLocDesembType(self, value):
        # Validate type xLocDesembType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLocDesembType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLocDesembType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLocDesembType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLocDesembType_patterns_, ))
    validate_xLocDesembType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TUfEmi(self, value):
        # Validate type TUfEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUfEmi' % {"value" : value.encode("utf-8")} )
    def validate_tpViaTranspType(self, value):
        # Validate type tpViaTranspType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpViaTranspType' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_tpIntermedioType(self, value):
        # Validate type tpIntermedioType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpIntermedioType' % {"value" : value.encode("utf-8")} )
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [[u'^[0-9]{14}$']]
    def validate_cExportadorType(self, value):
        # Validate type cExportadorType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cExportadorType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cExportadorType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cExportadorType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cExportadorType_patterns_, ))
    validate_cExportadorType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.nDI is not None or
            self.dDI is not None or
            self.xLocDesemb is not None or
            self.UFDesemb is not None or
            self.dDesemb is not None or
            self.tpViaTransp is not None or
            self.vAFRMM is not None or
            self.tpIntermedio is not None or
            self.CNPJ is not None or
            self.UFTerceiro is not None or
            self.cExportador is not None or
            self.adi
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DIType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DIType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DIType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DIType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DIType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DIType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nDI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snDI>%s</%snDI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nDI), input_name='nDI')), namespaceprefix_ , eol_))
        if self.dDI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdDI>%s</%sdDI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dDI), input_name='dDI')), namespaceprefix_ , eol_))
        if self.xLocDesemb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxLocDesemb>%s</%sxLocDesemb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xLocDesemb), input_name='xLocDesemb')), namespaceprefix_ , eol_))
        if self.UFDesemb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFDesemb>%s</%sUFDesemb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UFDesemb), input_name='UFDesemb')), namespaceprefix_ , eol_))
        if self.dDesemb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdDesemb>%s</%sdDesemb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dDesemb), input_name='dDesemb')), namespaceprefix_ , eol_))
        if self.tpViaTransp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpViaTransp>%s</%stpViaTransp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpViaTransp), input_name='tpViaTransp')), namespaceprefix_ , eol_))
        if self.vAFRMM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svAFRMM>%s</%svAFRMM>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vAFRMM), input_name='vAFRMM')), namespaceprefix_ , eol_))
        if self.tpIntermedio is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpIntermedio>%s</%stpIntermedio>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpIntermedio), input_name='tpIntermedio')), namespaceprefix_ , eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.UFTerceiro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFTerceiro>%s</%sUFTerceiro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UFTerceiro), input_name='UFTerceiro')), namespaceprefix_ , eol_))
        if self.cExportador is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scExportador>%s</%scExportador>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cExportador), input_name='cExportador')), namespaceprefix_ , eol_))
        for adi_ in self.adi:
            adi_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='adi', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nDI':
            nDI_ = child_.text
            nDI_ = self.gds_validate_string(nDI_, node, 'nDI')
            self.nDI = nDI_
            # validate type nDIType
            self.validate_nDIType(self.nDI)
        elif nodeName_ == 'dDI':
            dDI_ = child_.text
            dDI_ = self.gds_validate_string(dDI_, node, 'dDI')
            self.dDI = dDI_
            # validate type TData
            self.validate_TData(self.dDI)
        elif nodeName_ == 'xLocDesemb':
            xLocDesemb_ = child_.text
            xLocDesemb_ = self.gds_validate_string(xLocDesemb_, node, 'xLocDesemb')
            self.xLocDesemb = xLocDesemb_
            # validate type xLocDesembType
            self.validate_xLocDesembType(self.xLocDesemb)
        elif nodeName_ == 'UFDesemb':
            UFDesemb_ = child_.text
            UFDesemb_ = self.gds_validate_string(UFDesemb_, node, 'UFDesemb')
            self.UFDesemb = UFDesemb_
            # validate type TUfEmi
            self.validate_TUfEmi(self.UFDesemb)
        elif nodeName_ == 'dDesemb':
            dDesemb_ = child_.text
            dDesemb_ = self.gds_validate_string(dDesemb_, node, 'dDesemb')
            self.dDesemb = dDesemb_
            # validate type TData
            self.validate_TData(self.dDesemb)
        elif nodeName_ == 'tpViaTransp':
            tpViaTransp_ = child_.text
            tpViaTransp_ = self.gds_validate_string(tpViaTransp_, node, 'tpViaTransp')
            self.tpViaTransp = tpViaTransp_
            # validate type tpViaTranspType
            self.validate_tpViaTranspType(self.tpViaTransp)
        elif nodeName_ == 'vAFRMM':
            vAFRMM_ = child_.text
            vAFRMM_ = self.gds_validate_string(vAFRMM_, node, 'vAFRMM')
            self.vAFRMM = vAFRMM_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vAFRMM)
        elif nodeName_ == 'tpIntermedio':
            tpIntermedio_ = child_.text
            tpIntermedio_ = self.gds_validate_string(tpIntermedio_, node, 'tpIntermedio')
            self.tpIntermedio = tpIntermedio_
            # validate type tpIntermedioType
            self.validate_tpIntermedioType(self.tpIntermedio)
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'UFTerceiro':
            UFTerceiro_ = child_.text
            UFTerceiro_ = self.gds_validate_string(UFTerceiro_, node, 'UFTerceiro')
            self.UFTerceiro = UFTerceiro_
            # validate type TUfEmi
            self.validate_TUfEmi(self.UFTerceiro)
        elif nodeName_ == 'cExportador':
            cExportador_ = child_.text
            cExportador_ = self.gds_validate_string(cExportador_, node, 'cExportador')
            self.cExportador = cExportador_
            # validate type cExportadorType
            self.validate_cExportadorType(self.cExportador)
        elif nodeName_ == 'adi':
            obj_ = adiType.factory(parent_object_=self)
            obj_.build(child_)
            self.adi.append(obj_)
            obj_.original_tagname_ = 'adi'
# end class DIType


class adiType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nAdicao=None, nSeqAdic=None, cFabricante=None, vDescDI=None, nDraw=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.nAdicao = nAdicao
        self.validate_nAdicaoType(self.nAdicao)
        self.nSeqAdic = nSeqAdic
        self.validate_nSeqAdicType(self.nSeqAdic)
        self.cFabricante = cFabricante
        self.validate_cFabricanteType(self.cFabricante)
        self.vDescDI = vDescDI
        self.validate_TDec_1302Opc(self.vDescDI)
        self.nDraw = nDraw
        self.validate_nDrawType(self.nDraw)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, adiType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if adiType.subclass:
            return adiType.subclass(*args_, **kwargs_)
        else:
            return adiType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nAdicao(self):
        return self.nAdicao
    def set_nAdicao(self, nAdicao):
        self.nAdicao = nAdicao
    def get_nSeqAdic(self):
        return self.nSeqAdic
    def set_nSeqAdic(self, nSeqAdic):
        self.nSeqAdic = nSeqAdic
    def get_cFabricante(self):
        return self.cFabricante
    def set_cFabricante(self, cFabricante):
        self.cFabricante = cFabricante
    def get_vDescDI(self):
        return self.vDescDI
    def set_vDescDI(self, vDescDI):
        self.vDescDI = vDescDI
    def get_nDraw(self):
        return self.nDraw
    def set_nDraw(self, nDraw):
        self.nDraw = nDraw
    def validate_nAdicaoType(self, value):
        # Validate type nAdicaoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nAdicaoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nAdicaoType_patterns_, ))
    validate_nAdicaoType_patterns_ = [[u'^[1-9]{1}[0-9]{0,2}$']]
    def validate_nSeqAdicType(self, value):
        # Validate type nSeqAdicType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nSeqAdicType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nSeqAdicType_patterns_, ))
    validate_nSeqAdicType_patterns_ = [[u'^[1-9]{1}[0-9]{0,2}$']]
    def validate_cFabricanteType(self, value):
        # Validate type cFabricanteType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cFabricanteType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cFabricanteType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cFabricanteType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cFabricanteType_patterns_, ))
    validate_cFabricanteType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [[u'^0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_nDrawType(self, value):
        # Validate type nDrawType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nDrawType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nDrawType_patterns_, ))
    validate_nDrawType_patterns_ = [[u'^[0-9]{0,11}$']]
    def hasContent_(self):
        if (
            self.nAdicao is not None or
            self.nSeqAdic is not None or
            self.cFabricante is not None or
            self.vDescDI is not None or
            self.nDraw is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adiType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('adiType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='adiType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='adiType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='adiType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='adiType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nAdicao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snAdicao>%s</%snAdicao>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nAdicao), input_name='nAdicao')), namespaceprefix_ , eol_))
        if self.nSeqAdic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snSeqAdic>%s</%snSeqAdic>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nSeqAdic), input_name='nSeqAdic')), namespaceprefix_ , eol_))
        if self.cFabricante is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scFabricante>%s</%scFabricante>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cFabricante), input_name='cFabricante')), namespaceprefix_ , eol_))
        if self.vDescDI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDescDI>%s</%svDescDI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDescDI), input_name='vDescDI')), namespaceprefix_ , eol_))
        if self.nDraw is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snDraw>%s</%snDraw>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nDraw), input_name='nDraw')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nAdicao':
            nAdicao_ = child_.text
            nAdicao_ = self.gds_validate_string(nAdicao_, node, 'nAdicao')
            self.nAdicao = nAdicao_
            # validate type nAdicaoType
            self.validate_nAdicaoType(self.nAdicao)
        elif nodeName_ == 'nSeqAdic':
            nSeqAdic_ = child_.text
            nSeqAdic_ = self.gds_validate_string(nSeqAdic_, node, 'nSeqAdic')
            self.nSeqAdic = nSeqAdic_
            # validate type nSeqAdicType
            self.validate_nSeqAdicType(self.nSeqAdic)
        elif nodeName_ == 'cFabricante':
            cFabricante_ = child_.text
            cFabricante_ = self.gds_validate_string(cFabricante_, node, 'cFabricante')
            self.cFabricante = cFabricante_
            # validate type cFabricanteType
            self.validate_cFabricanteType(self.cFabricante)
        elif nodeName_ == 'vDescDI':
            vDescDI_ = child_.text
            vDescDI_ = self.gds_validate_string(vDescDI_, node, 'vDescDI')
            self.vDescDI = vDescDI_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDescDI)
        elif nodeName_ == 'nDraw':
            nDraw_ = child_.text
            nDraw_ = self.gds_validate_string(nDraw_, node, 'nDraw')
            self.nDraw = nDraw_
            # validate type nDrawType
            self.validate_nDrawType(self.nDraw)
# end class adiType


class detExportType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nDraw=None, exportInd=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.nDraw = nDraw
        self.validate_nDrawType6(self.nDraw)
        self.exportInd = exportInd
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detExportType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detExportType.subclass:
            return detExportType.subclass(*args_, **kwargs_)
        else:
            return detExportType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nDraw(self):
        return self.nDraw
    def set_nDraw(self, nDraw):
        self.nDraw = nDraw
    def get_exportInd(self):
        return self.exportInd
    def set_exportInd(self, exportInd):
        self.exportInd = exportInd
    def validate_nDrawType6(self, value):
        # Validate type nDrawType6, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nDrawType6_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nDrawType6_patterns_, ))
    validate_nDrawType6_patterns_ = [[u'^[0-9]{0,11}$']]
    def hasContent_(self):
        if (
            self.nDraw is not None or
            self.exportInd is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='detExportType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detExportType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='detExportType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='detExportType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='detExportType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='detExportType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nDraw is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snDraw>%s</%snDraw>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nDraw), input_name='nDraw')), namespaceprefix_ , eol_))
        if self.exportInd is not None:
            self.exportInd.export(outfile, level, namespaceprefix_, namespacedef_='', name_='exportInd', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nDraw':
            nDraw_ = child_.text
            nDraw_ = self.gds_validate_string(nDraw_, node, 'nDraw')
            self.nDraw = nDraw_
            # validate type nDrawType6
            self.validate_nDrawType6(self.nDraw)
        elif nodeName_ == 'exportInd':
            obj_ = exportIndType.factory(parent_object_=self)
            obj_.build(child_)
            self.exportInd = obj_
            obj_.original_tagname_ = 'exportInd'
# end class detExportType


class exportIndType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nRE=None, chNFe=None, qExport=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.nRE = nRE
        self.validate_nREType(self.nRE)
        self.chNFe = chNFe
        self.validate_TChNFe(self.chNFe)
        self.qExport = qExport
        self.validate_TDec_1104v(self.qExport)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exportIndType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exportIndType.subclass:
            return exportIndType.subclass(*args_, **kwargs_)
        else:
            return exportIndType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nRE(self):
        return self.nRE
    def set_nRE(self, nRE):
        self.nRE = nRE
    def get_chNFe(self):
        return self.chNFe
    def set_chNFe(self, chNFe):
        self.chNFe = chNFe
    def get_qExport(self):
        return self.qExport
    def set_qExport(self, qExport):
        self.qExport = qExport
    def validate_nREType(self, value):
        # Validate type nREType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nREType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nREType_patterns_, ))
    validate_nREType_patterns_ = [[u'^[0-9]{0,12}$']]
    def validate_TChNFe(self, value):
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 44:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TChNFe' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TChNFe_patterns_, ))
    validate_TChNFe_patterns_ = [[u'^[0-9]{44}$']]
    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [[u'^0|0\\.[0-9]{1,4}|[1-9]{1}[0-9]{0,10}|[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]
    def hasContent_(self):
        if (
            self.nRE is not None or
            self.chNFe is not None or
            self.qExport is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='exportIndType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exportIndType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='exportIndType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='exportIndType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='exportIndType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='exportIndType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nRE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snRE>%s</%snRE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nRE), input_name='nRE')), namespaceprefix_ , eol_))
        if self.chNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schNFe>%s</%schNFe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chNFe), input_name='chNFe')), namespaceprefix_ , eol_))
        if self.qExport is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqExport>%s</%sqExport>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qExport), input_name='qExport')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nRE':
            nRE_ = child_.text
            nRE_ = self.gds_validate_string(nRE_, node, 'nRE')
            self.nRE = nRE_
            # validate type nREType
            self.validate_nREType(self.nRE)
        elif nodeName_ == 'chNFe':
            chNFe_ = child_.text
            chNFe_ = self.gds_validate_string(chNFe_, node, 'chNFe')
            self.chNFe = chNFe_
            # validate type TChNFe
            self.validate_TChNFe(self.chNFe)
        elif nodeName_ == 'qExport':
            qExport_ = child_.text
            qExport_ = self.gds_validate_string(qExport_, node, 'qExport')
            self.qExport = qExport_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.qExport)
# end class exportIndType


class rastroType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nLote=None, qLote=None, dFab=None, dVal=None, cAgreg=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.nLote = nLote
        self.validate_nLoteType(self.nLote)
        self.qLote = qLote
        self.validate_TDec_0803v(self.qLote)
        self.dFab = dFab
        self.validate_TData(self.dFab)
        self.dVal = dVal
        self.validate_TData(self.dVal)
        self.cAgreg = cAgreg
        self.validate_cAgregType(self.cAgreg)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, rastroType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if rastroType.subclass:
            return rastroType.subclass(*args_, **kwargs_)
        else:
            return rastroType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nLote(self):
        return self.nLote
    def set_nLote(self, nLote):
        self.nLote = nLote
    def get_qLote(self):
        return self.qLote
    def set_qLote(self, qLote):
        self.qLote = qLote
    def get_dFab(self):
        return self.dFab
    def set_dFab(self, dFab):
        self.dFab = dFab
    def get_dVal(self):
        return self.dVal
    def set_dVal(self, dVal):
        self.dVal = dVal
    def get_cAgreg(self):
        return self.cAgreg
    def set_cAgreg(self, cAgreg):
        self.cAgreg = cAgreg
    def validate_nLoteType(self, value):
        # Validate type nLoteType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nLoteType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nLoteType' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0803v(self, value):
        # Validate type TDec_0803v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0803v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0803v_patterns_, ))
    validate_TDec_0803v_patterns_ = [[u'^0|0\\.[0-9]{3}|[1-9]{1}[0-9]{0,7}(\\.[0-9]{1,3})?$']]
    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [[u'^(((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))$']]
    def validate_cAgregType(self, value):
        # Validate type cAgregType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cAgregType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cAgregType_patterns_, ))
    validate_cAgregType_patterns_ = [[u'^[0-9]{1,20}$']]
    def hasContent_(self):
        if (
            self.nLote is not None or
            self.qLote is not None or
            self.dFab is not None or
            self.dVal is not None or
            self.cAgreg is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='rastroType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('rastroType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='rastroType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='rastroType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='rastroType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='rastroType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snLote>%s</%snLote>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nLote), input_name='nLote')), namespaceprefix_ , eol_))
        if self.qLote is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqLote>%s</%sqLote>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qLote), input_name='qLote')), namespaceprefix_ , eol_))
        if self.dFab is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdFab>%s</%sdFab>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dFab), input_name='dFab')), namespaceprefix_ , eol_))
        if self.dVal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdVal>%s</%sdVal>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dVal), input_name='dVal')), namespaceprefix_ , eol_))
        if self.cAgreg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scAgreg>%s</%scAgreg>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cAgreg), input_name='cAgreg')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nLote':
            nLote_ = child_.text
            nLote_ = self.gds_validate_string(nLote_, node, 'nLote')
            self.nLote = nLote_
            # validate type nLoteType
            self.validate_nLoteType(self.nLote)
        elif nodeName_ == 'qLote':
            qLote_ = child_.text
            qLote_ = self.gds_validate_string(qLote_, node, 'qLote')
            self.qLote = qLote_
            # validate type TDec_0803v
            self.validate_TDec_0803v(self.qLote)
        elif nodeName_ == 'dFab':
            dFab_ = child_.text
            dFab_ = self.gds_validate_string(dFab_, node, 'dFab')
            self.dFab = dFab_
            # validate type TData
            self.validate_TData(self.dFab)
        elif nodeName_ == 'dVal':
            dVal_ = child_.text
            dVal_ = self.gds_validate_string(dVal_, node, 'dVal')
            self.dVal = dVal_
            # validate type TData
            self.validate_TData(self.dVal)
        elif nodeName_ == 'cAgreg':
            cAgreg_ = child_.text
            cAgreg_ = self.gds_validate_string(cAgreg_, node, 'cAgreg')
            self.cAgreg = cAgreg_
            # validate type cAgregType
            self.validate_cAgregType(self.cAgreg)
# end class rastroType


class veicProdType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tpOp=None, chassi=None, cCor=None, xCor=None, pot=None, cilin=None, pesoL=None, pesoB=None, nSerie=None, tpComb=None, nMotor=None, CMT=None, dist=None, anoMod=None, anoFab=None, tpPint=None, tpVeic=None, espVeic=None, VIN=None, condVeic=None, cMod=None, cCorDENATRAN=None, lota=None, tpRest=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.tpOp = tpOp
        self.validate_tpOpType(self.tpOp)
        self.chassi = chassi
        self.validate_chassiType(self.chassi)
        self.cCor = cCor
        self.validate_cCorType(self.cCor)
        self.xCor = xCor
        self.validate_xCorType(self.xCor)
        self.pot = pot
        self.validate_potType(self.pot)
        self.cilin = cilin
        self.validate_cilinType(self.cilin)
        self.pesoL = pesoL
        self.validate_pesoLType(self.pesoL)
        self.pesoB = pesoB
        self.validate_pesoBType(self.pesoB)
        self.nSerie = nSerie
        self.validate_nSerieType(self.nSerie)
        self.tpComb = tpComb
        self.validate_tpCombType(self.tpComb)
        self.nMotor = nMotor
        self.validate_nMotorType(self.nMotor)
        self.CMT = CMT
        self.validate_CMTType(self.CMT)
        self.dist = dist
        self.validate_distType(self.dist)
        self.anoMod = anoMod
        self.validate_anoModType(self.anoMod)
        self.anoFab = anoFab
        self.validate_anoFabType(self.anoFab)
        self.tpPint = tpPint
        self.validate_tpPintType(self.tpPint)
        self.tpVeic = tpVeic
        self.validate_tpVeicType(self.tpVeic)
        self.espVeic = espVeic
        self.validate_espVeicType(self.espVeic)
        self.VIN = VIN
        self.validate_VINType(self.VIN)
        self.condVeic = condVeic
        self.validate_condVeicType(self.condVeic)
        self.cMod = cMod
        self.validate_cModType(self.cMod)
        self.cCorDENATRAN = cCorDENATRAN
        self.validate_cCorDENATRANType(self.cCorDENATRAN)
        self.lota = lota
        self.validate_lotaType(self.lota)
        self.tpRest = tpRest
        self.validate_tpRestType(self.tpRest)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, veicProdType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if veicProdType.subclass:
            return veicProdType.subclass(*args_, **kwargs_)
        else:
            return veicProdType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpOp(self):
        return self.tpOp
    def set_tpOp(self, tpOp):
        self.tpOp = tpOp
    def get_chassi(self):
        return self.chassi
    def set_chassi(self, chassi):
        self.chassi = chassi
    def get_cCor(self):
        return self.cCor
    def set_cCor(self, cCor):
        self.cCor = cCor
    def get_xCor(self):
        return self.xCor
    def set_xCor(self, xCor):
        self.xCor = xCor
    def get_pot(self):
        return self.pot
    def set_pot(self, pot):
        self.pot = pot
    def get_cilin(self):
        return self.cilin
    def set_cilin(self, cilin):
        self.cilin = cilin
    def get_pesoL(self):
        return self.pesoL
    def set_pesoL(self, pesoL):
        self.pesoL = pesoL
    def get_pesoB(self):
        return self.pesoB
    def set_pesoB(self, pesoB):
        self.pesoB = pesoB
    def get_nSerie(self):
        return self.nSerie
    def set_nSerie(self, nSerie):
        self.nSerie = nSerie
    def get_tpComb(self):
        return self.tpComb
    def set_tpComb(self, tpComb):
        self.tpComb = tpComb
    def get_nMotor(self):
        return self.nMotor
    def set_nMotor(self, nMotor):
        self.nMotor = nMotor
    def get_CMT(self):
        return self.CMT
    def set_CMT(self, CMT):
        self.CMT = CMT
    def get_dist(self):
        return self.dist
    def set_dist(self, dist):
        self.dist = dist
    def get_anoMod(self):
        return self.anoMod
    def set_anoMod(self, anoMod):
        self.anoMod = anoMod
    def get_anoFab(self):
        return self.anoFab
    def set_anoFab(self, anoFab):
        self.anoFab = anoFab
    def get_tpPint(self):
        return self.tpPint
    def set_tpPint(self, tpPint):
        self.tpPint = tpPint
    def get_tpVeic(self):
        return self.tpVeic
    def set_tpVeic(self, tpVeic):
        self.tpVeic = tpVeic
    def get_espVeic(self):
        return self.espVeic
    def set_espVeic(self, espVeic):
        self.espVeic = espVeic
    def get_VIN(self):
        return self.VIN
    def set_VIN(self, VIN):
        self.VIN = VIN
    def get_condVeic(self):
        return self.condVeic
    def set_condVeic(self, condVeic):
        self.condVeic = condVeic
    def get_cMod(self):
        return self.cMod
    def set_cMod(self, cMod):
        self.cMod = cMod
    def get_cCorDENATRAN(self):
        return self.cCorDENATRAN
    def set_cCorDENATRAN(self, cCorDENATRAN):
        self.cCorDENATRAN = cCorDENATRAN
    def get_lota(self):
        return self.lota
    def set_lota(self, lota):
        self.lota = lota
    def get_tpRest(self):
        return self.tpRest
    def set_tpRest(self, tpRest):
        self.tpRest = tpRest
    def validate_tpOpType(self, value):
        # Validate type tpOpType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpOpType' % {"value" : value.encode("utf-8")} )
    def validate_chassiType(self, value):
        # Validate type chassiType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) != 17:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on chassiType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_chassiType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_chassiType_patterns_, ))
    validate_chassiType_patterns_ = [[u'^[A-Z0-9]+$']]
    def validate_cCorType(self, value):
        # Validate type cCorType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cCorType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cCorType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cCorType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cCorType_patterns_, ))
    validate_cCorType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_xCorType(self, value):
        # Validate type xCorType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 40:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xCorType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xCorType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xCorType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xCorType_patterns_, ))
    validate_xCorType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_potType(self, value):
        # Validate type potType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on potType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on potType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_potType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_potType_patterns_, ))
    validate_potType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_cilinType(self, value):
        # Validate type cilinType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cilinType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cilinType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cilinType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cilinType_patterns_, ))
    validate_cilinType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_pesoLType(self, value):
        # Validate type pesoLType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 9:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on pesoLType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on pesoLType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_pesoLType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_pesoLType_patterns_, ))
    validate_pesoLType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_pesoBType(self, value):
        # Validate type pesoBType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 9:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on pesoBType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on pesoBType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_pesoBType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_pesoBType_patterns_, ))
    validate_pesoBType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_nSerieType(self, value):
        # Validate type nSerieType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 9:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nSerieType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nSerieType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nSerieType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nSerieType_patterns_, ))
    validate_nSerieType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_tpCombType(self, value):
        # Validate type tpCombType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on tpCombType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on tpCombType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpCombType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpCombType_patterns_, ))
    validate_tpCombType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_nMotorType(self, value):
        # Validate type nMotorType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 21:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nMotorType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nMotorType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nMotorType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nMotorType_patterns_, ))
    validate_nMotorType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_CMTType(self, value):
        # Validate type CMTType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 9:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on CMTType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on CMTType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_CMTType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CMTType_patterns_, ))
    validate_CMTType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_distType(self, value):
        # Validate type distType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 4:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on distType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on distType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_distType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_distType_patterns_, ))
    validate_distType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_anoModType(self, value):
        # Validate type anoModType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_anoModType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_anoModType_patterns_, ))
    validate_anoModType_patterns_ = [[u'^[0-9]{4}$']]
    def validate_anoFabType(self, value):
        # Validate type anoFabType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_anoFabType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_anoFabType_patterns_, ))
    validate_anoFabType_patterns_ = [[u'^[0-9]{4}$']]
    def validate_tpPintType(self, value):
        # Validate type tpPintType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on tpPintType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_tpPintType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpPintType_patterns_, ))
    validate_tpPintType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_tpVeicType(self, value):
        # Validate type tpVeicType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_tpVeicType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_tpVeicType_patterns_, ))
    validate_tpVeicType_patterns_ = [[u'^[0-9]{1,2}$']]
    def validate_espVeicType(self, value):
        # Validate type espVeicType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_espVeicType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_espVeicType_patterns_, ))
    validate_espVeicType_patterns_ = [[u'^[0-9]{1}$']]
    def validate_VINType(self, value):
        # Validate type VINType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['R', 'N']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on VINType' % {"value" : value.encode("utf-8")} )
            if len(str(value)) != 1:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on VINType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_VINType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_VINType_patterns_, ))
    validate_VINType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_condVeicType(self, value):
        # Validate type condVeicType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on condVeicType' % {"value" : value.encode("utf-8")} )
    def validate_cModType(self, value):
        # Validate type cModType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cModType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cModType_patterns_, ))
    validate_cModType_patterns_ = [[u'^[0-9]{1,6}$']]
    def validate_cCorDENATRANType(self, value):
        # Validate type cCorDENATRANType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 2:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cCorDENATRANType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cCorDENATRANType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cCorDENATRANType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cCorDENATRANType_patterns_, ))
    validate_cCorDENATRANType_patterns_ = [[u'^[0-9]{1,2}$']]
    def validate_lotaType(self, value):
        # Validate type lotaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on lotaType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on lotaType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_lotaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_lotaType_patterns_, ))
    validate_lotaType_patterns_ = [[u'^[0-9]{1,3}$']]
    def validate_tpRestType(self, value):
        # Validate type tpRestType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpRestType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.tpOp is not None or
            self.chassi is not None or
            self.cCor is not None or
            self.xCor is not None or
            self.pot is not None or
            self.cilin is not None or
            self.pesoL is not None or
            self.pesoB is not None or
            self.nSerie is not None or
            self.tpComb is not None or
            self.nMotor is not None or
            self.CMT is not None or
            self.dist is not None or
            self.anoMod is not None or
            self.anoFab is not None or
            self.tpPint is not None or
            self.tpVeic is not None or
            self.espVeic is not None or
            self.VIN is not None or
            self.condVeic is not None or
            self.cMod is not None or
            self.cCorDENATRAN is not None or
            self.lota is not None or
            self.tpRest is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='veicProdType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('veicProdType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='veicProdType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='veicProdType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='veicProdType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='veicProdType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpOp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpOp>%s</%stpOp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpOp), input_name='tpOp')), namespaceprefix_ , eol_))
        if self.chassi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schassi>%s</%schassi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chassi), input_name='chassi')), namespaceprefix_ , eol_))
        if self.cCor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scCor>%s</%scCor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cCor), input_name='cCor')), namespaceprefix_ , eol_))
        if self.xCor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCor>%s</%sxCor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCor), input_name='xCor')), namespaceprefix_ , eol_))
        if self.pot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spot>%s</%spot>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pot), input_name='pot')), namespaceprefix_ , eol_))
        if self.cilin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scilin>%s</%scilin>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cilin), input_name='cilin')), namespaceprefix_ , eol_))
        if self.pesoL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spesoL>%s</%spesoL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pesoL), input_name='pesoL')), namespaceprefix_ , eol_))
        if self.pesoB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spesoB>%s</%spesoB>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pesoB), input_name='pesoB')), namespaceprefix_ , eol_))
        if self.nSerie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snSerie>%s</%snSerie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nSerie), input_name='nSerie')), namespaceprefix_ , eol_))
        if self.tpComb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpComb>%s</%stpComb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpComb), input_name='tpComb')), namespaceprefix_ , eol_))
        if self.nMotor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snMotor>%s</%snMotor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nMotor), input_name='nMotor')), namespaceprefix_ , eol_))
        if self.CMT is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCMT>%s</%sCMT>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CMT), input_name='CMT')), namespaceprefix_ , eol_))
        if self.dist is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdist>%s</%sdist>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dist), input_name='dist')), namespaceprefix_ , eol_))
        if self.anoMod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sanoMod>%s</%sanoMod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.anoMod), input_name='anoMod')), namespaceprefix_ , eol_))
        if self.anoFab is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sanoFab>%s</%sanoFab>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.anoFab), input_name='anoFab')), namespaceprefix_ , eol_))
        if self.tpPint is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpPint>%s</%stpPint>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpPint), input_name='tpPint')), namespaceprefix_ , eol_))
        if self.tpVeic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpVeic>%s</%stpVeic>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpVeic), input_name='tpVeic')), namespaceprefix_ , eol_))
        if self.espVeic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sespVeic>%s</%sespVeic>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.espVeic), input_name='espVeic')), namespaceprefix_ , eol_))
        if self.VIN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVIN>%s</%sVIN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.VIN), input_name='VIN')), namespaceprefix_ , eol_))
        if self.condVeic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scondVeic>%s</%scondVeic>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.condVeic), input_name='condVeic')), namespaceprefix_ , eol_))
        if self.cMod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMod>%s</%scMod>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMod), input_name='cMod')), namespaceprefix_ , eol_))
        if self.cCorDENATRAN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scCorDENATRAN>%s</%scCorDENATRAN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cCorDENATRAN), input_name='cCorDENATRAN')), namespaceprefix_ , eol_))
        if self.lota is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slota>%s</%slota>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.lota), input_name='lota')), namespaceprefix_ , eol_))
        if self.tpRest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpRest>%s</%stpRest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpRest), input_name='tpRest')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpOp':
            tpOp_ = child_.text
            tpOp_ = self.gds_validate_string(tpOp_, node, 'tpOp')
            self.tpOp = tpOp_
            # validate type tpOpType
            self.validate_tpOpType(self.tpOp)
        elif nodeName_ == 'chassi':
            chassi_ = child_.text
            chassi_ = self.gds_validate_string(chassi_, node, 'chassi')
            self.chassi = chassi_
            # validate type chassiType
            self.validate_chassiType(self.chassi)
        elif nodeName_ == 'cCor':
            cCor_ = child_.text
            cCor_ = self.gds_validate_string(cCor_, node, 'cCor')
            self.cCor = cCor_
            # validate type cCorType
            self.validate_cCorType(self.cCor)
        elif nodeName_ == 'xCor':
            xCor_ = child_.text
            xCor_ = self.gds_validate_string(xCor_, node, 'xCor')
            self.xCor = xCor_
            # validate type xCorType
            self.validate_xCorType(self.xCor)
        elif nodeName_ == 'pot':
            pot_ = child_.text
            pot_ = self.gds_validate_string(pot_, node, 'pot')
            self.pot = pot_
            # validate type potType
            self.validate_potType(self.pot)
        elif nodeName_ == 'cilin':
            cilin_ = child_.text
            cilin_ = self.gds_validate_string(cilin_, node, 'cilin')
            self.cilin = cilin_
            # validate type cilinType
            self.validate_cilinType(self.cilin)
        elif nodeName_ == 'pesoL':
            pesoL_ = child_.text
            pesoL_ = self.gds_validate_string(pesoL_, node, 'pesoL')
            self.pesoL = pesoL_
            # validate type pesoLType
            self.validate_pesoLType(self.pesoL)
        elif nodeName_ == 'pesoB':
            pesoB_ = child_.text
            pesoB_ = self.gds_validate_string(pesoB_, node, 'pesoB')
            self.pesoB = pesoB_
            # validate type pesoBType
            self.validate_pesoBType(self.pesoB)
        elif nodeName_ == 'nSerie':
            nSerie_ = child_.text
            nSerie_ = self.gds_validate_string(nSerie_, node, 'nSerie')
            self.nSerie = nSerie_
            # validate type nSerieType
            self.validate_nSerieType(self.nSerie)
        elif nodeName_ == 'tpComb':
            tpComb_ = child_.text
            tpComb_ = self.gds_validate_string(tpComb_, node, 'tpComb')
            self.tpComb = tpComb_
            # validate type tpCombType
            self.validate_tpCombType(self.tpComb)
        elif nodeName_ == 'nMotor':
            nMotor_ = child_.text
            nMotor_ = self.gds_validate_string(nMotor_, node, 'nMotor')
            self.nMotor = nMotor_
            # validate type nMotorType
            self.validate_nMotorType(self.nMotor)
        elif nodeName_ == 'CMT':
            CMT_ = child_.text
            CMT_ = self.gds_validate_string(CMT_, node, 'CMT')
            self.CMT = CMT_
            # validate type CMTType
            self.validate_CMTType(self.CMT)
        elif nodeName_ == 'dist':
            dist_ = child_.text
            dist_ = self.gds_validate_string(dist_, node, 'dist')
            self.dist = dist_
            # validate type distType
            self.validate_distType(self.dist)
        elif nodeName_ == 'anoMod':
            anoMod_ = child_.text
            anoMod_ = self.gds_validate_string(anoMod_, node, 'anoMod')
            self.anoMod = anoMod_
            # validate type anoModType
            self.validate_anoModType(self.anoMod)
        elif nodeName_ == 'anoFab':
            anoFab_ = child_.text
            anoFab_ = self.gds_validate_string(anoFab_, node, 'anoFab')
            self.anoFab = anoFab_
            # validate type anoFabType
            self.validate_anoFabType(self.anoFab)
        elif nodeName_ == 'tpPint':
            tpPint_ = child_.text
            tpPint_ = self.gds_validate_string(tpPint_, node, 'tpPint')
            self.tpPint = tpPint_
            # validate type tpPintType
            self.validate_tpPintType(self.tpPint)
        elif nodeName_ == 'tpVeic':
            tpVeic_ = child_.text
            tpVeic_ = self.gds_validate_string(tpVeic_, node, 'tpVeic')
            self.tpVeic = tpVeic_
            # validate type tpVeicType
            self.validate_tpVeicType(self.tpVeic)
        elif nodeName_ == 'espVeic':
            espVeic_ = child_.text
            espVeic_ = self.gds_validate_string(espVeic_, node, 'espVeic')
            self.espVeic = espVeic_
            # validate type espVeicType
            self.validate_espVeicType(self.espVeic)
        elif nodeName_ == 'VIN':
            VIN_ = child_.text
            VIN_ = self.gds_validate_string(VIN_, node, 'VIN')
            self.VIN = VIN_
            # validate type VINType
            self.validate_VINType(self.VIN)
        elif nodeName_ == 'condVeic':
            condVeic_ = child_.text
            condVeic_ = self.gds_validate_string(condVeic_, node, 'condVeic')
            self.condVeic = condVeic_
            # validate type condVeicType
            self.validate_condVeicType(self.condVeic)
        elif nodeName_ == 'cMod':
            cMod_ = child_.text
            cMod_ = self.gds_validate_string(cMod_, node, 'cMod')
            self.cMod = cMod_
            # validate type cModType
            self.validate_cModType(self.cMod)
        elif nodeName_ == 'cCorDENATRAN':
            cCorDENATRAN_ = child_.text
            cCorDENATRAN_ = self.gds_validate_string(cCorDENATRAN_, node, 'cCorDENATRAN')
            self.cCorDENATRAN = cCorDENATRAN_
            # validate type cCorDENATRANType
            self.validate_cCorDENATRANType(self.cCorDENATRAN)
        elif nodeName_ == 'lota':
            lota_ = child_.text
            lota_ = self.gds_validate_string(lota_, node, 'lota')
            self.lota = lota_
            # validate type lotaType
            self.validate_lotaType(self.lota)
        elif nodeName_ == 'tpRest':
            tpRest_ = child_.text
            tpRest_ = self.gds_validate_string(tpRest_, node, 'tpRest')
            self.tpRest = tpRest_
            # validate type tpRestType
            self.validate_tpRestType(self.tpRest)
# end class veicProdType


class medType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cProdANVISA=None, vPMC=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.cProdANVISA = cProdANVISA
        self.validate_cProdANVISAType(self.cProdANVISA)
        self.vPMC = vPMC
        self.validate_TDec_1302(self.vPMC)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, medType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if medType.subclass:
            return medType.subclass(*args_, **kwargs_)
        else:
            return medType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cProdANVISA(self):
        return self.cProdANVISA
    def set_cProdANVISA(self, cProdANVISA):
        self.cProdANVISA = cProdANVISA
    def get_vPMC(self):
        return self.vPMC
    def set_vPMC(self, vPMC):
        self.vPMC = vPMC
    def validate_cProdANVISAType(self, value):
        # Validate type cProdANVISAType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) != 13:
                warnings_.warn('Value "%(value)s" does not match xsd length restriction on cProdANVISAType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cProdANVISAType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cProdANVISAType_patterns_, ))
    validate_cProdANVISAType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.cProdANVISA is not None or
            self.vPMC is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='medType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('medType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='medType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='medType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='medType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='medType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cProdANVISA is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scProdANVISA>%s</%scProdANVISA>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cProdANVISA), input_name='cProdANVISA')), namespaceprefix_ , eol_))
        if self.vPMC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svPMC>%s</%svPMC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vPMC), input_name='vPMC')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cProdANVISA':
            cProdANVISA_ = child_.text
            cProdANVISA_ = self.gds_validate_string(cProdANVISA_, node, 'cProdANVISA')
            self.cProdANVISA = cProdANVISA_
            # validate type cProdANVISAType
            self.validate_cProdANVISAType(self.cProdANVISA)
        elif nodeName_ == 'vPMC':
            vPMC_ = child_.text
            vPMC_ = self.gds_validate_string(vPMC_, node, 'vPMC')
            self.vPMC = vPMC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPMC)
# end class medType


class armaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tpArma=None, nSerie=None, nCano=None, descr=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.tpArma = tpArma
        self.validate_tpArmaType(self.tpArma)
        self.nSerie = nSerie
        self.validate_nSerieType7(self.nSerie)
        self.nCano = nCano
        self.validate_nCanoType(self.nCano)
        self.descr = descr
        self.validate_descrType(self.descr)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, armaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if armaType.subclass:
            return armaType.subclass(*args_, **kwargs_)
        else:
            return armaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpArma(self):
        return self.tpArma
    def set_tpArma(self, tpArma):
        self.tpArma = tpArma
    def get_nSerie(self):
        return self.nSerie
    def set_nSerie(self, nSerie):
        self.nSerie = nSerie
    def get_nCano(self):
        return self.nCano
    def set_nCano(self, nCano):
        self.nCano = nCano
    def get_descr(self):
        return self.descr
    def set_descr(self, descr):
        self.descr = descr
    def validate_tpArmaType(self, value):
        # Validate type tpArmaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpArmaType' % {"value" : value.encode("utf-8")} )
    def validate_nSerieType7(self, value):
        # Validate type nSerieType7, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nSerieType7' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nSerieType7' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nSerieType7_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nSerieType7_patterns_, ))
    validate_nSerieType7_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_nCanoType(self, value):
        # Validate type nCanoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nCanoType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nCanoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nCanoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nCanoType_patterns_, ))
    validate_nCanoType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_descrType(self, value):
        # Validate type descrType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 256:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on descrType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on descrType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_descrType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_descrType_patterns_, ))
    validate_descrType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.tpArma is not None or
            self.nSerie is not None or
            self.nCano is not None or
            self.descr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='armaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('armaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='armaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='armaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='armaType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='armaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpArma is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpArma>%s</%stpArma>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpArma), input_name='tpArma')), namespaceprefix_ , eol_))
        if self.nSerie is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snSerie>%s</%snSerie>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nSerie), input_name='nSerie')), namespaceprefix_ , eol_))
        if self.nCano is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snCano>%s</%snCano>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nCano), input_name='nCano')), namespaceprefix_ , eol_))
        if self.descr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescr>%s</%sdescr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.descr), input_name='descr')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpArma':
            tpArma_ = child_.text
            tpArma_ = self.gds_validate_string(tpArma_, node, 'tpArma')
            self.tpArma = tpArma_
            # validate type tpArmaType
            self.validate_tpArmaType(self.tpArma)
        elif nodeName_ == 'nSerie':
            nSerie_ = child_.text
            nSerie_ = self.gds_validate_string(nSerie_, node, 'nSerie')
            self.nSerie = nSerie_
            # validate type nSerieType7
            self.validate_nSerieType7(self.nSerie)
        elif nodeName_ == 'nCano':
            nCano_ = child_.text
            nCano_ = self.gds_validate_string(nCano_, node, 'nCano')
            self.nCano = nCano_
            # validate type nCanoType
            self.validate_nCanoType(self.nCano)
        elif nodeName_ == 'descr':
            descr_ = child_.text
            descr_ = self.gds_validate_string(descr_, node, 'descr')
            self.descr = descr_
            # validate type descrType
            self.validate_descrType(self.descr)
# end class armaType


class combType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, cProdANP=None, descANP=None, pGLP=None, pGNn=None, pGNi=None, vPart=None, CODIF=None, qTemp=None, UFCons=None, CIDE=None, encerrante=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.cProdANP = cProdANP
        self.validate_cProdANPType(self.cProdANP)
        self.descANP = descANP
        self.validate_descANPType(self.descANP)
        self.pGLP = pGLP
        self.validate_TDec_0302a04Max100(self.pGLP)
        self.pGNn = pGNn
        self.validate_TDec_0302a04Max100(self.pGNn)
        self.pGNi = pGNi
        self.validate_TDec_0302a04Max100(self.pGNi)
        self.vPart = vPart
        self.validate_TDec_1302(self.vPart)
        self.CODIF = CODIF
        self.validate_CODIFType(self.CODIF)
        self.qTemp = qTemp
        self.validate_TDec_1204temperatura(self.qTemp)
        self.UFCons = UFCons
        self.validate_TUf(self.UFCons)
        self.CIDE = CIDE
        self.encerrante = encerrante
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, combType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if combType.subclass:
            return combType.subclass(*args_, **kwargs_)
        else:
            return combType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_cProdANP(self):
        return self.cProdANP
    def set_cProdANP(self, cProdANP):
        self.cProdANP = cProdANP
    def get_descANP(self):
        return self.descANP
    def set_descANP(self, descANP):
        self.descANP = descANP
    def get_pGLP(self):
        return self.pGLP
    def set_pGLP(self, pGLP):
        self.pGLP = pGLP
    def get_pGNn(self):
        return self.pGNn
    def set_pGNn(self, pGNn):
        self.pGNn = pGNn
    def get_pGNi(self):
        return self.pGNi
    def set_pGNi(self, pGNi):
        self.pGNi = pGNi
    def get_vPart(self):
        return self.vPart
    def set_vPart(self, vPart):
        self.vPart = vPart
    def get_CODIF(self):
        return self.CODIF
    def set_CODIF(self, CODIF):
        self.CODIF = CODIF
    def get_qTemp(self):
        return self.qTemp
    def set_qTemp(self, qTemp):
        self.qTemp = qTemp
    def get_UFCons(self):
        return self.UFCons
    def set_UFCons(self, UFCons):
        self.UFCons = UFCons
    def get_CIDE(self):
        return self.CIDE
    def set_CIDE(self, CIDE):
        self.CIDE = CIDE
    def get_encerrante(self):
        return self.encerrante
    def set_encerrante(self, encerrante):
        self.encerrante = encerrante
    def validate_cProdANPType(self, value):
        # Validate type cProdANPType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cProdANPType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cProdANPType_patterns_, ))
    validate_cProdANPType_patterns_ = [[u'^[0-9]{9}$']]
    def validate_descANPType(self, value):
        # Validate type descANPType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 95:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on descANPType' % {"value" : value.encode("utf-8")} )
            if len(value) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on descANPType' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0302a04Max100(self, value):
        # Validate type TDec_0302a04Max100, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Max100_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Max100_patterns_, ))
    validate_TDec_0302a04Max100_patterns_ = [[u'^0(\\.[0-9]{2,4})?|[1-9]{1}[0-9]{0,1}(\\.[0-9]{2,4})?|100(\\.0{2,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_CODIFType(self, value):
        # Validate type CODIFType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CODIFType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CODIFType_patterns_, ))
    validate_CODIFType_patterns_ = [[u'^[0-9]{1,21}$']]
    def validate_TDec_1204temperatura(self, value):
        # Validate type TDec_1204temperatura, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204temperatura_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204temperatura_patterns_, ))
    validate_TDec_1204temperatura_patterns_ = [[u'^0\\.[1-9]{1}[0-9]{3}|0\\.[0-9]{3}[1-9]{1}|0\\.[0-9]{2}[1-9]{1}[0-9]{1}|0\\.[0-9]{1}[1-9]{1}[0-9]{2}|[1-9]{1}[0-9]{0,11}(\\.[0-9]{4})?$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.cProdANP is not None or
            self.descANP is not None or
            self.pGLP is not None or
            self.pGNn is not None or
            self.pGNi is not None or
            self.vPart is not None or
            self.CODIF is not None or
            self.qTemp is not None or
            self.UFCons is not None or
            self.CIDE is not None or
            self.encerrante is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='combType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('combType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='combType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='combType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='combType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='combType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.cProdANP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scProdANP>%s</%scProdANP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cProdANP), input_name='cProdANP')), namespaceprefix_ , eol_))
        if self.descANP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescANP>%s</%sdescANP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.descANP), input_name='descANP')), namespaceprefix_ , eol_))
        if self.pGLP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spGLP>%s</%spGLP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pGLP), input_name='pGLP')), namespaceprefix_ , eol_))
        if self.pGNn is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spGNn>%s</%spGNn>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pGNn), input_name='pGNn')), namespaceprefix_ , eol_))
        if self.pGNi is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spGNi>%s</%spGNi>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pGNi), input_name='pGNi')), namespaceprefix_ , eol_))
        if self.vPart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svPart>%s</%svPart>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vPart), input_name='vPart')), namespaceprefix_ , eol_))
        if self.CODIF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCODIF>%s</%sCODIF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CODIF), input_name='CODIF')), namespaceprefix_ , eol_))
        if self.qTemp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqTemp>%s</%sqTemp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qTemp), input_name='qTemp')), namespaceprefix_ , eol_))
        if self.UFCons is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFCons>%s</%sUFCons>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UFCons), input_name='UFCons')), namespaceprefix_ , eol_))
        if self.CIDE is not None:
            self.CIDE.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CIDE', pretty_print=pretty_print)
        if self.encerrante is not None:
            self.encerrante.export(outfile, level, namespaceprefix_, namespacedef_='', name_='encerrante', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'cProdANP':
            cProdANP_ = child_.text
            cProdANP_ = self.gds_validate_string(cProdANP_, node, 'cProdANP')
            self.cProdANP = cProdANP_
            # validate type cProdANPType
            self.validate_cProdANPType(self.cProdANP)
        elif nodeName_ == 'descANP':
            descANP_ = child_.text
            descANP_ = self.gds_validate_string(descANP_, node, 'descANP')
            self.descANP = descANP_
            # validate type descANPType
            self.validate_descANPType(self.descANP)
        elif nodeName_ == 'pGLP':
            pGLP_ = child_.text
            pGLP_ = self.gds_validate_string(pGLP_, node, 'pGLP')
            self.pGLP = pGLP_
            # validate type TDec_0302a04Max100
            self.validate_TDec_0302a04Max100(self.pGLP)
        elif nodeName_ == 'pGNn':
            pGNn_ = child_.text
            pGNn_ = self.gds_validate_string(pGNn_, node, 'pGNn')
            self.pGNn = pGNn_
            # validate type TDec_0302a04Max100
            self.validate_TDec_0302a04Max100(self.pGNn)
        elif nodeName_ == 'pGNi':
            pGNi_ = child_.text
            pGNi_ = self.gds_validate_string(pGNi_, node, 'pGNi')
            self.pGNi = pGNi_
            # validate type TDec_0302a04Max100
            self.validate_TDec_0302a04Max100(self.pGNi)
        elif nodeName_ == 'vPart':
            vPart_ = child_.text
            vPart_ = self.gds_validate_string(vPart_, node, 'vPart')
            self.vPart = vPart_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPart)
        elif nodeName_ == 'CODIF':
            CODIF_ = child_.text
            CODIF_ = self.gds_validate_string(CODIF_, node, 'CODIF')
            self.CODIF = CODIF_
            # validate type CODIFType
            self.validate_CODIFType(self.CODIF)
        elif nodeName_ == 'qTemp':
            qTemp_ = child_.text
            qTemp_ = self.gds_validate_string(qTemp_, node, 'qTemp')
            self.qTemp = qTemp_
            # validate type TDec_1204temperatura
            self.validate_TDec_1204temperatura(self.qTemp)
        elif nodeName_ == 'UFCons':
            UFCons_ = child_.text
            UFCons_ = self.gds_validate_string(UFCons_, node, 'UFCons')
            self.UFCons = UFCons_
            # validate type TUf
            self.validate_TUf(self.UFCons)
        elif nodeName_ == 'CIDE':
            obj_ = CIDEType.factory(parent_object_=self)
            obj_.build(child_)
            self.CIDE = obj_
            obj_.original_tagname_ = 'CIDE'
        elif nodeName_ == 'encerrante':
            obj_ = encerranteType.factory(parent_object_=self)
            obj_.build(child_)
            self.encerrante = obj_
            obj_.original_tagname_ = 'encerrante'
# end class combType


class CIDEType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, qBCProd=None, vAliqProd=None, vCIDE=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.qBCProd = qBCProd
        self.validate_TDec_1204v(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104(self.vAliqProd)
        self.vCIDE = vCIDE
        self.validate_TDec_1302(self.vCIDE)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CIDEType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CIDEType.subclass:
            return CIDEType.subclass(*args_, **kwargs_)
        else:
            return CIDEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qBCProd(self):
        return self.qBCProd
    def set_qBCProd(self, qBCProd):
        self.qBCProd = qBCProd
    def get_vAliqProd(self):
        return self.vAliqProd
    def set_vAliqProd(self, vAliqProd):
        self.vAliqProd = vAliqProd
    def get_vCIDE(self):
        return self.vCIDE
    def set_vCIDE(self, vCIDE):
        self.vCIDE = vCIDE
    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [[u'^0|0\\.[0-9]{1,4}|[1-9]{1}[0-9]{0,11}|[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1104(self, value):
        # Validate type TDec_1104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104_patterns_, ))
    validate_TDec_1104_patterns_ = [[u'^0|0\\.[0-9]{4}|[1-9]{1}[0-9]{0,10}(\\.[0-9]{4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vCIDE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CIDEType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CIDEType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CIDEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CIDEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CIDEType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CIDEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqBCProd>%s</%sqBCProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qBCProd), input_name='qBCProd')), namespaceprefix_ , eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svAliqProd>%s</%svAliqProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vAliqProd), input_name='vAliqProd')), namespaceprefix_ , eol_))
        if self.vCIDE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCIDE>%s</%svCIDE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCIDE), input_name='vCIDE')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104
            self.validate_TDec_1104(self.vAliqProd)
        elif nodeName_ == 'vCIDE':
            vCIDE_ = child_.text
            vCIDE_ = self.gds_validate_string(vCIDE_, node, 'vCIDE')
            self.vCIDE = vCIDE_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCIDE)
# end class CIDEType


class encerranteType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nBico=None, nBomba=None, nTanque=None, vEncIni=None, vEncFin=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.nBico = nBico
        self.validate_nBicoType(self.nBico)
        self.nBomba = nBomba
        self.validate_nBombaType(self.nBomba)
        self.nTanque = nTanque
        self.validate_nTanqueType(self.nTanque)
        self.vEncIni = vEncIni
        self.validate_TDec_1203(self.vEncIni)
        self.vEncFin = vEncFin
        self.validate_TDec_1203(self.vEncFin)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, encerranteType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if encerranteType.subclass:
            return encerranteType.subclass(*args_, **kwargs_)
        else:
            return encerranteType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nBico(self):
        return self.nBico
    def set_nBico(self, nBico):
        self.nBico = nBico
    def get_nBomba(self):
        return self.nBomba
    def set_nBomba(self, nBomba):
        self.nBomba = nBomba
    def get_nTanque(self):
        return self.nTanque
    def set_nTanque(self, nTanque):
        self.nTanque = nTanque
    def get_vEncIni(self):
        return self.vEncIni
    def set_vEncIni(self, vEncIni):
        self.vEncIni = vEncIni
    def get_vEncFin(self):
        return self.vEncFin
    def set_vEncFin(self, vEncFin):
        self.vEncFin = vEncFin
    def validate_nBicoType(self, value):
        # Validate type nBicoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nBicoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nBicoType_patterns_, ))
    validate_nBicoType_patterns_ = [[u'^[0-9]{1,3}$']]
    def validate_nBombaType(self, value):
        # Validate type nBombaType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nBombaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nBombaType_patterns_, ))
    validate_nBombaType_patterns_ = [[u'^[0-9]{1,3}$']]
    def validate_nTanqueType(self, value):
        # Validate type nTanqueType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_nTanqueType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nTanqueType_patterns_, ))
    validate_nTanqueType_patterns_ = [[u'^[0-9]{1,3}$']]
    def validate_TDec_1203(self, value):
        # Validate type TDec_1203, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1203_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1203_patterns_, ))
    validate_TDec_1203_patterns_ = [[u'^0|0\\.[0-9]{3}|[1-9]{1}[0-9]{0,11}(\\.[0-9]{3})?$']]
    def hasContent_(self):
        if (
            self.nBico is not None or
            self.nBomba is not None or
            self.nTanque is not None or
            self.vEncIni is not None or
            self.vEncFin is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='encerranteType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('encerranteType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='encerranteType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='encerranteType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='encerranteType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='encerranteType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nBico is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snBico>%s</%snBico>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nBico), input_name='nBico')), namespaceprefix_ , eol_))
        if self.nBomba is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snBomba>%s</%snBomba>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nBomba), input_name='nBomba')), namespaceprefix_ , eol_))
        if self.nTanque is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snTanque>%s</%snTanque>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nTanque), input_name='nTanque')), namespaceprefix_ , eol_))
        if self.vEncIni is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svEncIni>%s</%svEncIni>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vEncIni), input_name='vEncIni')), namespaceprefix_ , eol_))
        if self.vEncFin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svEncFin>%s</%svEncFin>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vEncFin), input_name='vEncFin')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nBico':
            nBico_ = child_.text
            nBico_ = self.gds_validate_string(nBico_, node, 'nBico')
            self.nBico = nBico_
            # validate type nBicoType
            self.validate_nBicoType(self.nBico)
        elif nodeName_ == 'nBomba':
            nBomba_ = child_.text
            nBomba_ = self.gds_validate_string(nBomba_, node, 'nBomba')
            self.nBomba = nBomba_
            # validate type nBombaType
            self.validate_nBombaType(self.nBomba)
        elif nodeName_ == 'nTanque':
            nTanque_ = child_.text
            nTanque_ = self.gds_validate_string(nTanque_, node, 'nTanque')
            self.nTanque = nTanque_
            # validate type nTanqueType
            self.validate_nTanqueType(self.nTanque)
        elif nodeName_ == 'vEncIni':
            vEncIni_ = child_.text
            vEncIni_ = self.gds_validate_string(vEncIni_, node, 'vEncIni')
            self.vEncIni = vEncIni_
            # validate type TDec_1203
            self.validate_TDec_1203(self.vEncIni)
        elif nodeName_ == 'vEncFin':
            vEncFin_ = child_.text
            vEncFin_ = self.gds_validate_string(vEncFin_, node, 'vEncFin')
            self.vEncFin = vEncFin_
            # validate type TDec_1203
            self.validate_TDec_1203(self.vEncFin)
# end class encerranteType


class impostoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vTotTrib=None, ICMS=None, II=None, IPI=None, ISSQN=None, PIS=None, PISST=None, COFINS=None, COFINSST=None, ICMSUFDest=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.vTotTrib = vTotTrib
        self.validate_TDec_1302(self.vTotTrib)
        self.ICMS = ICMS
        self.II = II
        self.IPI = IPI
        self.ISSQN = ISSQN
        self.PIS = PIS
        self.PISST = PISST
        self.COFINS = COFINS
        self.COFINSST = COFINSST
        self.ICMSUFDest = ICMSUFDest
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, impostoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if impostoType.subclass:
            return impostoType.subclass(*args_, **kwargs_)
        else:
            return impostoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vTotTrib(self):
        return self.vTotTrib
    def set_vTotTrib(self, vTotTrib):
        self.vTotTrib = vTotTrib
    def get_ICMS(self):
        return self.ICMS
    def set_ICMS(self, ICMS):
        self.ICMS = ICMS
    def get_II(self):
        return self.II
    def set_II(self, II):
        self.II = II
    def get_IPI(self):
        return self.IPI
    def set_IPI(self, IPI):
        self.IPI = IPI
    def get_ISSQN(self):
        return self.ISSQN
    def set_ISSQN(self, ISSQN):
        self.ISSQN = ISSQN
    def get_PIS(self):
        return self.PIS
    def set_PIS(self, PIS):
        self.PIS = PIS
    def get_PISST(self):
        return self.PISST
    def set_PISST(self, PISST):
        self.PISST = PISST
    def get_COFINS(self):
        return self.COFINS
    def set_COFINS(self, COFINS):
        self.COFINS = COFINS
    def get_COFINSST(self):
        return self.COFINSST
    def set_COFINSST(self, COFINSST):
        self.COFINSST = COFINSST
    def get_ICMSUFDest(self):
        return self.ICMSUFDest
    def set_ICMSUFDest(self, ICMSUFDest):
        self.ICMSUFDest = ICMSUFDest
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.vTotTrib is not None or
            self.ICMS is not None or
            self.II is not None or
            self.IPI is not None or
            self.ISSQN is not None or
            self.PIS is not None or
            self.PISST is not None or
            self.COFINS is not None or
            self.COFINSST is not None or
            self.ICMSUFDest is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='impostoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('impostoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='impostoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='impostoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='impostoType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='impostoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vTotTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svTotTrib>%s</%svTotTrib>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vTotTrib), input_name='vTotTrib')), namespaceprefix_ , eol_))
        if self.ICMS is not None:
            self.ICMS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS', pretty_print=pretty_print)
        if self.II is not None:
            self.II.export(outfile, level, namespaceprefix_, namespacedef_='', name_='II', pretty_print=pretty_print)
        if self.IPI is not None:
            self.IPI.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IPI', pretty_print=pretty_print)
        if self.ISSQN is not None:
            self.ISSQN.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ISSQN', pretty_print=pretty_print)
        if self.PIS is not None:
            self.PIS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PIS', pretty_print=pretty_print)
        if self.PISST is not None:
            self.PISST.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PISST', pretty_print=pretty_print)
        if self.COFINS is not None:
            self.COFINS.export(outfile, level, namespaceprefix_, namespacedef_='', name_='COFINS', pretty_print=pretty_print)
        if self.COFINSST is not None:
            self.COFINSST.export(outfile, level, namespaceprefix_, namespacedef_='', name_='COFINSST', pretty_print=pretty_print)
        if self.ICMSUFDest is not None:
            self.ICMSUFDest.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMSUFDest', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vTotTrib':
            vTotTrib_ = child_.text
            vTotTrib_ = self.gds_validate_string(vTotTrib_, node, 'vTotTrib')
            self.vTotTrib = vTotTrib_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vTotTrib)
        elif nodeName_ == 'ICMS':
            obj_ = ICMSType.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMS = obj_
            obj_.original_tagname_ = 'ICMS'
        elif nodeName_ == 'II':
            obj_ = IIType.factory(parent_object_=self)
            obj_.build(child_)
            self.II = obj_
            obj_.original_tagname_ = 'II'
        elif nodeName_ == 'IPI':
            obj_ = TIpi.factory(parent_object_=self)
            obj_.build(child_)
            self.IPI = obj_
            obj_.original_tagname_ = 'IPI'
        elif nodeName_ == 'ISSQN':
            obj_ = ISSQNType.factory(parent_object_=self)
            obj_.build(child_)
            self.ISSQN = obj_
            obj_.original_tagname_ = 'ISSQN'
        elif nodeName_ == 'PIS':
            obj_ = PISType.factory(parent_object_=self)
            obj_.build(child_)
            self.PIS = obj_
            obj_.original_tagname_ = 'PIS'
        elif nodeName_ == 'PISST':
            obj_ = PISSTType.factory(parent_object_=self)
            obj_.build(child_)
            self.PISST = obj_
            obj_.original_tagname_ = 'PISST'
        elif nodeName_ == 'COFINS':
            obj_ = COFINSType.factory(parent_object_=self)
            obj_.build(child_)
            self.COFINS = obj_
            obj_.original_tagname_ = 'COFINS'
        elif nodeName_ == 'COFINSST':
            obj_ = COFINSSTType.factory(parent_object_=self)
            obj_.build(child_)
            self.COFINSST = obj_
            obj_.original_tagname_ = 'COFINSST'
        elif nodeName_ == 'ICMSUFDest':
            obj_ = ICMSUFDestType.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMSUFDest = obj_
            obj_.original_tagname_ = 'ICMSUFDest'
# end class impostoType


class ICMSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ICMS00=None, ICMS10=None, ICMS20=None, ICMS30=None, ICMS40=None, ICMS51=None, ICMS60=None, ICMS70=None, ICMS90=None, ICMSPart=None, ICMSST=None, ICMSSN101=None, ICMSSN102=None, ICMSSN201=None, ICMSSN202=None, ICMSSN500=None, ICMSSN900=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ICMS00 = ICMS00
        self.ICMS10 = ICMS10
        self.ICMS20 = ICMS20
        self.ICMS30 = ICMS30
        self.ICMS40 = ICMS40
        self.ICMS51 = ICMS51
        self.ICMS60 = ICMS60
        self.ICMS70 = ICMS70
        self.ICMS90 = ICMS90
        self.ICMSPart = ICMSPart
        self.ICMSST = ICMSST
        self.ICMSSN101 = ICMSSN101
        self.ICMSSN102 = ICMSSN102
        self.ICMSSN201 = ICMSSN201
        self.ICMSSN202 = ICMSSN202
        self.ICMSSN500 = ICMSSN500
        self.ICMSSN900 = ICMSSN900
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSType.subclass:
            return ICMSType.subclass(*args_, **kwargs_)
        else:
            return ICMSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ICMS00(self):
        return self.ICMS00
    def set_ICMS00(self, ICMS00):
        self.ICMS00 = ICMS00
    def get_ICMS10(self):
        return self.ICMS10
    def set_ICMS10(self, ICMS10):
        self.ICMS10 = ICMS10
    def get_ICMS20(self):
        return self.ICMS20
    def set_ICMS20(self, ICMS20):
        self.ICMS20 = ICMS20
    def get_ICMS30(self):
        return self.ICMS30
    def set_ICMS30(self, ICMS30):
        self.ICMS30 = ICMS30
    def get_ICMS40(self):
        return self.ICMS40
    def set_ICMS40(self, ICMS40):
        self.ICMS40 = ICMS40
    def get_ICMS51(self):
        return self.ICMS51
    def set_ICMS51(self, ICMS51):
        self.ICMS51 = ICMS51
    def get_ICMS60(self):
        return self.ICMS60
    def set_ICMS60(self, ICMS60):
        self.ICMS60 = ICMS60
    def get_ICMS70(self):
        return self.ICMS70
    def set_ICMS70(self, ICMS70):
        self.ICMS70 = ICMS70
    def get_ICMS90(self):
        return self.ICMS90
    def set_ICMS90(self, ICMS90):
        self.ICMS90 = ICMS90
    def get_ICMSPart(self):
        return self.ICMSPart
    def set_ICMSPart(self, ICMSPart):
        self.ICMSPart = ICMSPart
    def get_ICMSST(self):
        return self.ICMSST
    def set_ICMSST(self, ICMSST):
        self.ICMSST = ICMSST
    def get_ICMSSN101(self):
        return self.ICMSSN101
    def set_ICMSSN101(self, ICMSSN101):
        self.ICMSSN101 = ICMSSN101
    def get_ICMSSN102(self):
        return self.ICMSSN102
    def set_ICMSSN102(self, ICMSSN102):
        self.ICMSSN102 = ICMSSN102
    def get_ICMSSN201(self):
        return self.ICMSSN201
    def set_ICMSSN201(self, ICMSSN201):
        self.ICMSSN201 = ICMSSN201
    def get_ICMSSN202(self):
        return self.ICMSSN202
    def set_ICMSSN202(self, ICMSSN202):
        self.ICMSSN202 = ICMSSN202
    def get_ICMSSN500(self):
        return self.ICMSSN500
    def set_ICMSSN500(self, ICMSSN500):
        self.ICMSSN500 = ICMSSN500
    def get_ICMSSN900(self):
        return self.ICMSSN900
    def set_ICMSSN900(self, ICMSSN900):
        self.ICMSSN900 = ICMSSN900
    def hasContent_(self):
        if (
            self.ICMS00 is not None or
            self.ICMS10 is not None or
            self.ICMS20 is not None or
            self.ICMS30 is not None or
            self.ICMS40 is not None or
            self.ICMS51 is not None or
            self.ICMS60 is not None or
            self.ICMS70 is not None or
            self.ICMS90 is not None or
            self.ICMSPart is not None or
            self.ICMSST is not None or
            self.ICMSSN101 is not None or
            self.ICMSSN102 is not None or
            self.ICMSSN201 is not None or
            self.ICMSSN202 is not None or
            self.ICMSSN500 is not None or
            self.ICMSSN900 is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ICMS00 is not None:
            self.ICMS00.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS00', pretty_print=pretty_print)
        if self.ICMS10 is not None:
            self.ICMS10.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS10', pretty_print=pretty_print)
        if self.ICMS20 is not None:
            self.ICMS20.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS20', pretty_print=pretty_print)
        if self.ICMS30 is not None:
            self.ICMS30.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS30', pretty_print=pretty_print)
        if self.ICMS40 is not None:
            self.ICMS40.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS40', pretty_print=pretty_print)
        if self.ICMS51 is not None:
            self.ICMS51.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS51', pretty_print=pretty_print)
        if self.ICMS60 is not None:
            self.ICMS60.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS60', pretty_print=pretty_print)
        if self.ICMS70 is not None:
            self.ICMS70.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS70', pretty_print=pretty_print)
        if self.ICMS90 is not None:
            self.ICMS90.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMS90', pretty_print=pretty_print)
        if self.ICMSPart is not None:
            self.ICMSPart.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMSPart', pretty_print=pretty_print)
        if self.ICMSST is not None:
            self.ICMSST.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMSST', pretty_print=pretty_print)
        if self.ICMSSN101 is not None:
            self.ICMSSN101.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMSSN101', pretty_print=pretty_print)
        if self.ICMSSN102 is not None:
            self.ICMSSN102.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMSSN102', pretty_print=pretty_print)
        if self.ICMSSN201 is not None:
            self.ICMSSN201.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMSSN201', pretty_print=pretty_print)
        if self.ICMSSN202 is not None:
            self.ICMSSN202.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMSSN202', pretty_print=pretty_print)
        if self.ICMSSN500 is not None:
            self.ICMSSN500.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMSSN500', pretty_print=pretty_print)
        if self.ICMSSN900 is not None:
            self.ICMSSN900.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMSSN900', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ICMS00':
            obj_ = ICMS00Type.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMS00 = obj_
            obj_.original_tagname_ = 'ICMS00'
        elif nodeName_ == 'ICMS10':
            obj_ = ICMS10Type.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMS10 = obj_
            obj_.original_tagname_ = 'ICMS10'
        elif nodeName_ == 'ICMS20':
            obj_ = ICMS20Type.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMS20 = obj_
            obj_.original_tagname_ = 'ICMS20'
        elif nodeName_ == 'ICMS30':
            obj_ = ICMS30Type.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMS30 = obj_
            obj_.original_tagname_ = 'ICMS30'
        elif nodeName_ == 'ICMS40':
            obj_ = ICMS40Type.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMS40 = obj_
            obj_.original_tagname_ = 'ICMS40'
        elif nodeName_ == 'ICMS51':
            obj_ = ICMS51Type.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMS51 = obj_
            obj_.original_tagname_ = 'ICMS51'
        elif nodeName_ == 'ICMS60':
            obj_ = ICMS60Type.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMS60 = obj_
            obj_.original_tagname_ = 'ICMS60'
        elif nodeName_ == 'ICMS70':
            obj_ = ICMS70Type.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMS70 = obj_
            obj_.original_tagname_ = 'ICMS70'
        elif nodeName_ == 'ICMS90':
            obj_ = ICMS90Type.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMS90 = obj_
            obj_.original_tagname_ = 'ICMS90'
        elif nodeName_ == 'ICMSPart':
            obj_ = ICMSPartType.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMSPart = obj_
            obj_.original_tagname_ = 'ICMSPart'
        elif nodeName_ == 'ICMSST':
            obj_ = ICMSSTType.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMSST = obj_
            obj_.original_tagname_ = 'ICMSST'
        elif nodeName_ == 'ICMSSN101':
            obj_ = ICMSSN101Type.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMSSN101 = obj_
            obj_.original_tagname_ = 'ICMSSN101'
        elif nodeName_ == 'ICMSSN102':
            obj_ = ICMSSN102Type.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMSSN102 = obj_
            obj_.original_tagname_ = 'ICMSSN102'
        elif nodeName_ == 'ICMSSN201':
            obj_ = ICMSSN201Type.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMSSN201 = obj_
            obj_.original_tagname_ = 'ICMSSN201'
        elif nodeName_ == 'ICMSSN202':
            obj_ = ICMSSN202Type.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMSSN202 = obj_
            obj_.original_tagname_ = 'ICMSSN202'
        elif nodeName_ == 'ICMSSN500':
            obj_ = ICMSSN500Type.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMSSN500 = obj_
            obj_.original_tagname_ = 'ICMSSN500'
        elif nodeName_ == 'ICMSSN900':
            obj_ = ICMSSN900Type.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMSSN900 = obj_
            obj_.original_tagname_ = 'ICMSSN900'
# end class ICMSType


class ICMS00Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, modBC=None, vBC=None, pICMS=None, vICMS=None, pFCP=None, vFCP=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType(self.CST)
        self.modBC = modBC
        self.validate_modBCType(self.modBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS00Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS00Type.subclass:
            return ICMS00Type.subclass(*args_, **kwargs_)
        else:
            return ICMS00Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_modBC(self):
        return self.modBC
    def set_modBC(self, modBC):
        self.modBC = modBC
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pICMS(self):
        return self.pICMS
    def set_pICMS(self, pICMS):
        self.pICMS = pICMS
    def get_vICMS(self):
        return self.vICMS
    def set_vICMS(self, vICMS):
        self.vICMS = vICMS
    def get_pFCP(self):
        return self.pFCP
    def set_pFCP(self, pFCP):
        self.pFCP = pFCP
    def get_vFCP(self):
        return self.vFCP
    def set_vFCP(self, vFCP):
        self.vFCP = vFCP
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType(self, value):
        # Validate type CSTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['00']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType' % {"value" : value.encode("utf-8")} )
    def validate_modBCType(self, value):
        # Validate type modBCType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCType' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [[u'^0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.pFCP is not None or
            self.vFCP is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS00Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS00Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS00Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS00Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS00Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS00Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodBC>%s</%smodBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modBC), input_name='modBC')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespaceprefix_ , eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespaceprefix_ , eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCP>%s</%spFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCP), input_name='pFCP')), namespaceprefix_ , eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCP>%s</%svFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCP), input_name='vFCP')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType
            self.validate_CSTType(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType
            self.validate_modBCType(self.modBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
# end class ICMS00Type


class ICMS10Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, modBC=None, vBC=None, pICMS=None, vICMS=None, vBCFCP=None, pFCP=None, vFCP=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType8(self.CST)
        self.modBC = modBC
        self.validate_modBCType9(self.modBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vBCFCP = vBCFCP
        self.validate_TDec_1302(self.vBCFCP)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
        self.modBCST = modBCST
        self.validate_modBCSTType(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS10Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS10Type.subclass:
            return ICMS10Type.subclass(*args_, **kwargs_)
        else:
            return ICMS10Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_modBC(self):
        return self.modBC
    def set_modBC(self, modBC):
        self.modBC = modBC
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pICMS(self):
        return self.pICMS
    def set_pICMS(self, pICMS):
        self.pICMS = pICMS
    def get_vICMS(self):
        return self.vICMS
    def set_vICMS(self, vICMS):
        self.vICMS = vICMS
    def get_vBCFCP(self):
        return self.vBCFCP
    def set_vBCFCP(self, vBCFCP):
        self.vBCFCP = vBCFCP
    def get_pFCP(self):
        return self.pFCP
    def set_pFCP(self, pFCP):
        self.pFCP = pFCP
    def get_vFCP(self):
        return self.vFCP
    def set_vFCP(self, vFCP):
        self.vFCP = vFCP
    def get_modBCST(self):
        return self.modBCST
    def set_modBCST(self, modBCST):
        self.modBCST = modBCST
    def get_pMVAST(self):
        return self.pMVAST
    def set_pMVAST(self, pMVAST):
        self.pMVAST = pMVAST
    def get_pRedBCST(self):
        return self.pRedBCST
    def set_pRedBCST(self, pRedBCST):
        self.pRedBCST = pRedBCST
    def get_vBCST(self):
        return self.vBCST
    def set_vBCST(self, vBCST):
        self.vBCST = vBCST
    def get_pICMSST(self):
        return self.pICMSST
    def set_pICMSST(self, pICMSST):
        self.pICMSST = pICMSST
    def get_vICMSST(self):
        return self.vICMSST
    def set_vICMSST(self, vICMSST):
        self.vICMSST = vICMSST
    def get_vBCFCPST(self):
        return self.vBCFCPST
    def set_vBCFCPST(self, vBCFCPST):
        self.vBCFCPST = vBCFCPST
    def get_pFCPST(self):
        return self.pFCPST
    def set_pFCPST(self, pFCPST):
        self.pFCPST = pFCPST
    def get_vFCPST(self):
        return self.vFCPST
    def set_vFCPST(self, vFCPST):
        self.vFCPST = vFCPST
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType8(self, value):
        # Validate type CSTType8, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['10']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType8' % {"value" : value.encode("utf-8")} )
    def validate_modBCType9(self, value):
        # Validate type modBCType9, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCType9' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [[u'^0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_modBCSTType(self, value):
        # Validate type modBCSTType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCSTType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.vBCFCP is not None or
            self.pFCP is not None or
            self.vFCP is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS10Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS10Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS10Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS10Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS10Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS10Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodBC>%s</%smodBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modBC), input_name='modBC')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespaceprefix_ , eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespaceprefix_ , eol_))
        if self.vBCFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCFCP>%s</%svBCFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCP), input_name='vBCFCP')), namespaceprefix_ , eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCP>%s</%spFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCP), input_name='pFCP')), namespaceprefix_ , eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCP>%s</%svFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCP), input_name='vFCP')), namespaceprefix_ , eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodBCST>%s</%smodBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modBCST), input_name='modBCST')), namespaceprefix_ , eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spMVAST>%s</%spMVAST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pMVAST), input_name='pMVAST')), namespaceprefix_ , eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBCST>%s</%spRedBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCST), input_name='pRedBCST')), namespaceprefix_ , eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCST>%s</%svBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), namespaceprefix_ , eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSST>%s</%spICMSST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSST), input_name='pICMSST')), namespaceprefix_ , eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSST>%s</%svICMSST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSST), input_name='vICMSST')), namespaceprefix_ , eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCFCPST>%s</%svBCFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPST), input_name='vBCFCPST')), namespaceprefix_ , eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCPST>%s</%spFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCPST), input_name='pFCPST')), namespaceprefix_ , eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCPST>%s</%svFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCPST), input_name='vFCPST')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType8
            self.validate_CSTType8(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType9
            self.validate_modBCType9(self.modBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vBCFCP':
            vBCFCP_ = child_.text
            vBCFCP_ = self.gds_validate_string(vBCFCP_, node, 'vBCFCP')
            self.vBCFCP = vBCFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCP)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType
            self.validate_modBCSTType(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
# end class ICMS10Type


class ICMS20Type(GeneratedsSuper):
    """Grupo desoneração"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, modBC=None, pRedBC=None, vBC=None, pICMS=None, vICMS=None, vBCFCP=None, pFCP=None, vFCP=None, vICMSDeson=None, motDesICMS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType10(self.CST)
        self.modBC = modBC
        self.validate_modBCType11(self.modBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04(self.pRedBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vBCFCP = vBCFCP
        self.validate_TDec_1302(self.vBCFCP)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.motDesICMS = motDesICMS
        self.validate_motDesICMSType(self.motDesICMS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS20Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS20Type.subclass:
            return ICMS20Type.subclass(*args_, **kwargs_)
        else:
            return ICMS20Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_modBC(self):
        return self.modBC
    def set_modBC(self, modBC):
        self.modBC = modBC
    def get_pRedBC(self):
        return self.pRedBC
    def set_pRedBC(self, pRedBC):
        self.pRedBC = pRedBC
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pICMS(self):
        return self.pICMS
    def set_pICMS(self, pICMS):
        self.pICMS = pICMS
    def get_vICMS(self):
        return self.vICMS
    def set_vICMS(self, vICMS):
        self.vICMS = vICMS
    def get_vBCFCP(self):
        return self.vBCFCP
    def set_vBCFCP(self, vBCFCP):
        self.vBCFCP = vBCFCP
    def get_pFCP(self):
        return self.pFCP
    def set_pFCP(self, pFCP):
        self.pFCP = pFCP
    def get_vFCP(self):
        return self.vFCP
    def set_vFCP(self, vFCP):
        self.vFCP = vFCP
    def get_vICMSDeson(self):
        return self.vICMSDeson
    def set_vICMSDeson(self, vICMSDeson):
        self.vICMSDeson = vICMSDeson
    def get_motDesICMS(self):
        return self.motDesICMS
    def set_motDesICMS(self, motDesICMS):
        self.motDesICMS = motDesICMS
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType10(self, value):
        # Validate type CSTType10, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['20']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType10' % {"value" : value.encode("utf-8")} )
    def validate_modBCType11(self, value):
        # Validate type modBCType11, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCType11' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [[u'^0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_motDesICMSType(self, value):
        # Validate type motDesICMSType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['3', '9', '12']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on motDesICMSType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.pRedBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.vBCFCP is not None or
            self.pFCP is not None or
            self.vFCP is not None or
            self.vICMSDeson is not None or
            self.motDesICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS20Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS20Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS20Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS20Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS20Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS20Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodBC>%s</%smodBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modBC), input_name='modBC')), namespaceprefix_ , eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBC>%s</%spRedBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespaceprefix_ , eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespaceprefix_ , eol_))
        if self.vBCFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCFCP>%s</%svBCFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCP), input_name='vBCFCP')), namespaceprefix_ , eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCP>%s</%spFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCP), input_name='pFCP')), namespaceprefix_ , eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCP>%s</%svFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCP), input_name='vFCP')), namespaceprefix_ , eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSDeson>%s</%svICMSDeson>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSDeson), input_name='vICMSDeson')), namespaceprefix_ , eol_))
        if self.motDesICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smotDesICMS>%s</%smotDesICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.motDesICMS), input_name='motDesICMS')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType10
            self.validate_CSTType10(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType11
            self.validate_modBCType11(self.modBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pRedBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vBCFCP':
            vBCFCP_ = child_.text
            vBCFCP_ = self.gds_validate_string(vBCFCP_, node, 'vBCFCP')
            self.vBCFCP = vBCFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCP)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'motDesICMS':
            motDesICMS_ = child_.text
            motDesICMS_ = self.gds_validate_string(motDesICMS_, node, 'motDesICMS')
            self.motDesICMS = motDesICMS_
            # validate type motDesICMSType
            self.validate_motDesICMSType(self.motDesICMS)
# end class ICMS20Type


class ICMS30Type(GeneratedsSuper):
    """Grupo desoneração"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, vICMSDeson=None, motDesICMS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType12(self.CST)
        self.modBCST = modBCST
        self.validate_modBCSTType13(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.motDesICMS = motDesICMS
        self.validate_motDesICMSType14(self.motDesICMS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS30Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS30Type.subclass:
            return ICMS30Type.subclass(*args_, **kwargs_)
        else:
            return ICMS30Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_modBCST(self):
        return self.modBCST
    def set_modBCST(self, modBCST):
        self.modBCST = modBCST
    def get_pMVAST(self):
        return self.pMVAST
    def set_pMVAST(self, pMVAST):
        self.pMVAST = pMVAST
    def get_pRedBCST(self):
        return self.pRedBCST
    def set_pRedBCST(self, pRedBCST):
        self.pRedBCST = pRedBCST
    def get_vBCST(self):
        return self.vBCST
    def set_vBCST(self, vBCST):
        self.vBCST = vBCST
    def get_pICMSST(self):
        return self.pICMSST
    def set_pICMSST(self, pICMSST):
        self.pICMSST = pICMSST
    def get_vICMSST(self):
        return self.vICMSST
    def set_vICMSST(self, vICMSST):
        self.vICMSST = vICMSST
    def get_vBCFCPST(self):
        return self.vBCFCPST
    def set_vBCFCPST(self, vBCFCPST):
        self.vBCFCPST = vBCFCPST
    def get_pFCPST(self):
        return self.pFCPST
    def set_pFCPST(self, pFCPST):
        self.pFCPST = pFCPST
    def get_vFCPST(self):
        return self.vFCPST
    def set_vFCPST(self, vFCPST):
        self.vFCPST = vFCPST
    def get_vICMSDeson(self):
        return self.vICMSDeson
    def set_vICMSDeson(self, vICMSDeson):
        self.vICMSDeson = vICMSDeson
    def get_motDesICMS(self):
        return self.motDesICMS
    def set_motDesICMS(self, motDesICMS):
        self.motDesICMS = motDesICMS
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType12(self, value):
        # Validate type CSTType12, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['30']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType12' % {"value" : value.encode("utf-8")} )
    def validate_modBCSTType13(self, value):
        # Validate type modBCSTType13, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCSTType13' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [[u'^0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_motDesICMSType14(self, value):
        # Validate type motDesICMSType14, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['6', '7', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on motDesICMSType14' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None or
            self.vICMSDeson is not None or
            self.motDesICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS30Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS30Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS30Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS30Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS30Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS30Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodBCST>%s</%smodBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modBCST), input_name='modBCST')), namespaceprefix_ , eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spMVAST>%s</%spMVAST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pMVAST), input_name='pMVAST')), namespaceprefix_ , eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBCST>%s</%spRedBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCST), input_name='pRedBCST')), namespaceprefix_ , eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCST>%s</%svBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), namespaceprefix_ , eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSST>%s</%spICMSST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSST), input_name='pICMSST')), namespaceprefix_ , eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSST>%s</%svICMSST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSST), input_name='vICMSST')), namespaceprefix_ , eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCFCPST>%s</%svBCFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPST), input_name='vBCFCPST')), namespaceprefix_ , eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCPST>%s</%spFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCPST), input_name='pFCPST')), namespaceprefix_ , eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCPST>%s</%svFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCPST), input_name='vFCPST')), namespaceprefix_ , eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSDeson>%s</%svICMSDeson>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSDeson), input_name='vICMSDeson')), namespaceprefix_ , eol_))
        if self.motDesICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smotDesICMS>%s</%smotDesICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.motDesICMS), input_name='motDesICMS')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType12
            self.validate_CSTType12(self.CST)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType13
            self.validate_modBCSTType13(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'motDesICMS':
            motDesICMS_ = child_.text
            motDesICMS_ = self.gds_validate_string(motDesICMS_, node, 'motDesICMS')
            self.motDesICMS = motDesICMS_
            # validate type motDesICMSType14
            self.validate_motDesICMSType14(self.motDesICMS)
# end class ICMS30Type


class ICMS40Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, vICMSDeson=None, motDesICMS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType15(self.CST)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.motDesICMS = motDesICMS
        self.validate_motDesICMSType16(self.motDesICMS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS40Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS40Type.subclass:
            return ICMS40Type.subclass(*args_, **kwargs_)
        else:
            return ICMS40Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_vICMSDeson(self):
        return self.vICMSDeson
    def set_vICMSDeson(self, vICMSDeson):
        self.vICMSDeson = vICMSDeson
    def get_motDesICMS(self):
        return self.motDesICMS
    def set_motDesICMS(self, motDesICMS):
        self.motDesICMS = motDesICMS
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType15(self, value):
        # Validate type CSTType15, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['40', '41', '50']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType15' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_motDesICMSType16(self, value):
        # Validate type motDesICMSType16, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '3', '4', '5', '6', '7', '8', '9', '10', '11', '16', '90']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on motDesICMSType16' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.vICMSDeson is not None or
            self.motDesICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS40Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS40Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS40Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS40Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS40Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS40Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSDeson>%s</%svICMSDeson>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSDeson), input_name='vICMSDeson')), namespaceprefix_ , eol_))
        if self.motDesICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smotDesICMS>%s</%smotDesICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.motDesICMS), input_name='motDesICMS')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType15
            self.validate_CSTType15(self.CST)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'motDesICMS':
            motDesICMS_ = child_.text
            motDesICMS_ = self.gds_validate_string(motDesICMS_, node, 'motDesICMS')
            self.motDesICMS = motDesICMS_
            # validate type motDesICMSType16
            self.validate_motDesICMSType16(self.motDesICMS)
# end class ICMS40Type


class ICMS51Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, modBC=None, pRedBC=None, vBC=None, pICMS=None, vICMSOp=None, pDif=None, vICMSDif=None, vICMS=None, vBCFCP=None, pFCP=None, vFCP=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType17(self.CST)
        self.modBC = modBC
        self.validate_modBCType18(self.modBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04(self.pRedBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMSOp = vICMSOp
        self.validate_TDec_1302(self.vICMSOp)
        self.pDif = pDif
        self.validate_TDec_0302a04Max100(self.pDif)
        self.vICMSDif = vICMSDif
        self.validate_TDec_1302(self.vICMSDif)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vBCFCP = vBCFCP
        self.validate_TDec_1302(self.vBCFCP)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS51Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS51Type.subclass:
            return ICMS51Type.subclass(*args_, **kwargs_)
        else:
            return ICMS51Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_modBC(self):
        return self.modBC
    def set_modBC(self, modBC):
        self.modBC = modBC
    def get_pRedBC(self):
        return self.pRedBC
    def set_pRedBC(self, pRedBC):
        self.pRedBC = pRedBC
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pICMS(self):
        return self.pICMS
    def set_pICMS(self, pICMS):
        self.pICMS = pICMS
    def get_vICMSOp(self):
        return self.vICMSOp
    def set_vICMSOp(self, vICMSOp):
        self.vICMSOp = vICMSOp
    def get_pDif(self):
        return self.pDif
    def set_pDif(self, pDif):
        self.pDif = pDif
    def get_vICMSDif(self):
        return self.vICMSDif
    def set_vICMSDif(self, vICMSDif):
        self.vICMSDif = vICMSDif
    def get_vICMS(self):
        return self.vICMS
    def set_vICMS(self, vICMS):
        self.vICMS = vICMS
    def get_vBCFCP(self):
        return self.vBCFCP
    def set_vBCFCP(self, vBCFCP):
        self.vBCFCP = vBCFCP
    def get_pFCP(self):
        return self.pFCP
    def set_pFCP(self, pFCP):
        self.pFCP = pFCP
    def get_vFCP(self):
        return self.vFCP
    def set_vFCP(self, vFCP):
        self.vFCP = vFCP
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType17(self, value):
        # Validate type CSTType17, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['51']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType17' % {"value" : value.encode("utf-8")} )
    def validate_modBCType18(self, value):
        # Validate type modBCType18, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCType18' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Max100(self, value):
        # Validate type TDec_0302a04Max100, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Max100_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Max100_patterns_, ))
    validate_TDec_0302a04Max100_patterns_ = [[u'^0(\\.[0-9]{2,4})?|[1-9]{1}[0-9]{0,1}(\\.[0-9]{2,4})?|100(\\.0{2,4})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [[u'^0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.pRedBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMSOp is not None or
            self.pDif is not None or
            self.vICMSDif is not None or
            self.vICMS is not None or
            self.vBCFCP is not None or
            self.pFCP is not None or
            self.vFCP is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS51Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS51Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS51Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS51Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS51Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS51Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodBC>%s</%smodBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modBC), input_name='modBC')), namespaceprefix_ , eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBC>%s</%spRedBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespaceprefix_ , eol_))
        if self.vICMSOp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSOp>%s</%svICMSOp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSOp), input_name='vICMSOp')), namespaceprefix_ , eol_))
        if self.pDif is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spDif>%s</%spDif>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pDif), input_name='pDif')), namespaceprefix_ , eol_))
        if self.vICMSDif is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSDif>%s</%svICMSDif>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSDif), input_name='vICMSDif')), namespaceprefix_ , eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespaceprefix_ , eol_))
        if self.vBCFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCFCP>%s</%svBCFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCP), input_name='vBCFCP')), namespaceprefix_ , eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCP>%s</%spFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCP), input_name='pFCP')), namespaceprefix_ , eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCP>%s</%svFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCP), input_name='vFCP')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType17
            self.validate_CSTType17(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType18
            self.validate_modBCType18(self.modBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pRedBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMSOp':
            vICMSOp_ = child_.text
            vICMSOp_ = self.gds_validate_string(vICMSOp_, node, 'vICMSOp')
            self.vICMSOp = vICMSOp_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSOp)
        elif nodeName_ == 'pDif':
            pDif_ = child_.text
            pDif_ = self.gds_validate_string(pDif_, node, 'pDif')
            self.pDif = pDif_
            # validate type TDec_0302a04Max100
            self.validate_TDec_0302a04Max100(self.pDif)
        elif nodeName_ == 'vICMSDif':
            vICMSDif_ = child_.text
            vICMSDif_ = self.gds_validate_string(vICMSDif_, node, 'vICMSDif')
            self.vICMSDif = vICMSDif_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDif)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vBCFCP':
            vBCFCP_ = child_.text
            vBCFCP_ = self.gds_validate_string(vBCFCP_, node, 'vBCFCP')
            self.vBCFCP = vBCFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCP)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
# end class ICMS51Type


class ICMS60Type(GeneratedsSuper):
    """NT2010/004"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, vBCSTRet=None, pST=None, vICMSSTRet=None, vBCFCPSTRet=None, pFCPSTRet=None, vFCPSTRet=None, pRedBCEfet=None, vBCEfet=None, pICMSEfet=None, vICMSEfet=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType19(self.CST)
        self.vBCSTRet = vBCSTRet
        self.validate_TDec_1302(self.vBCSTRet)
        self.pST = pST
        self.validate_TDec_0302a04Opc(self.pST)
        self.vICMSSTRet = vICMSSTRet
        self.validate_TDec_1302(self.vICMSSTRet)
        self.vBCFCPSTRet = vBCFCPSTRet
        self.validate_TDec_1302(self.vBCFCPSTRet)
        self.pFCPSTRet = pFCPSTRet
        self.validate_TDec_0302a04Opc(self.pFCPSTRet)
        self.vFCPSTRet = vFCPSTRet
        self.validate_TDec_1302(self.vFCPSTRet)
        self.pRedBCEfet = pRedBCEfet
        self.validate_TDec_0302a04Opc(self.pRedBCEfet)
        self.vBCEfet = vBCEfet
        self.validate_TDec_1302(self.vBCEfet)
        self.pICMSEfet = pICMSEfet
        self.validate_TDec_0302a04Opc(self.pICMSEfet)
        self.vICMSEfet = vICMSEfet
        self.validate_TDec_1302(self.vICMSEfet)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS60Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS60Type.subclass:
            return ICMS60Type.subclass(*args_, **kwargs_)
        else:
            return ICMS60Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_vBCSTRet(self):
        return self.vBCSTRet
    def set_vBCSTRet(self, vBCSTRet):
        self.vBCSTRet = vBCSTRet
    def get_pST(self):
        return self.pST
    def set_pST(self, pST):
        self.pST = pST
    def get_vICMSSTRet(self):
        return self.vICMSSTRet
    def set_vICMSSTRet(self, vICMSSTRet):
        self.vICMSSTRet = vICMSSTRet
    def get_vBCFCPSTRet(self):
        return self.vBCFCPSTRet
    def set_vBCFCPSTRet(self, vBCFCPSTRet):
        self.vBCFCPSTRet = vBCFCPSTRet
    def get_pFCPSTRet(self):
        return self.pFCPSTRet
    def set_pFCPSTRet(self, pFCPSTRet):
        self.pFCPSTRet = pFCPSTRet
    def get_vFCPSTRet(self):
        return self.vFCPSTRet
    def set_vFCPSTRet(self, vFCPSTRet):
        self.vFCPSTRet = vFCPSTRet
    def get_pRedBCEfet(self):
        return self.pRedBCEfet
    def set_pRedBCEfet(self, pRedBCEfet):
        self.pRedBCEfet = pRedBCEfet
    def get_vBCEfet(self):
        return self.vBCEfet
    def set_vBCEfet(self, vBCEfet):
        self.vBCEfet = vBCEfet
    def get_pICMSEfet(self):
        return self.pICMSEfet
    def set_pICMSEfet(self, pICMSEfet):
        self.pICMSEfet = pICMSEfet
    def get_vICMSEfet(self):
        return self.vICMSEfet
    def set_vICMSEfet(self, vICMSEfet):
        self.vICMSEfet = vICMSEfet
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType19(self, value):
        # Validate type CSTType19, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['60']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType19' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [[u'^0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.vBCSTRet is not None or
            self.pST is not None or
            self.vICMSSTRet is not None or
            self.vBCFCPSTRet is not None or
            self.pFCPSTRet is not None or
            self.vFCPSTRet is not None or
            self.pRedBCEfet is not None or
            self.vBCEfet is not None or
            self.pICMSEfet is not None or
            self.vICMSEfet is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS60Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS60Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS60Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS60Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS60Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS60Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.vBCSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCSTRet>%s</%svBCSTRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCSTRet), input_name='vBCSTRet')), namespaceprefix_ , eol_))
        if self.pST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spST>%s</%spST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pST), input_name='pST')), namespaceprefix_ , eol_))
        if self.vICMSSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSSTRet>%s</%svICMSSTRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSSTRet), input_name='vICMSSTRet')), namespaceprefix_ , eol_))
        if self.vBCFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCFCPSTRet>%s</%svBCFCPSTRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPSTRet), input_name='vBCFCPSTRet')), namespaceprefix_ , eol_))
        if self.pFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCPSTRet>%s</%spFCPSTRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCPSTRet), input_name='pFCPSTRet')), namespaceprefix_ , eol_))
        if self.vFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCPSTRet>%s</%svFCPSTRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCPSTRet), input_name='vFCPSTRet')), namespaceprefix_ , eol_))
        if self.pRedBCEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBCEfet>%s</%spRedBCEfet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCEfet), input_name='pRedBCEfet')), namespaceprefix_ , eol_))
        if self.vBCEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCEfet>%s</%svBCEfet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCEfet), input_name='vBCEfet')), namespaceprefix_ , eol_))
        if self.pICMSEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSEfet>%s</%spICMSEfet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSEfet), input_name='pICMSEfet')), namespaceprefix_ , eol_))
        if self.vICMSEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSEfet>%s</%svICMSEfet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSEfet), input_name='vICMSEfet')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType19
            self.validate_CSTType19(self.CST)
        elif nodeName_ == 'vBCSTRet':
            vBCSTRet_ = child_.text
            vBCSTRet_ = self.gds_validate_string(vBCSTRet_, node, 'vBCSTRet')
            self.vBCSTRet = vBCSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCSTRet)
        elif nodeName_ == 'pST':
            pST_ = child_.text
            pST_ = self.gds_validate_string(pST_, node, 'pST')
            self.pST = pST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pST)
        elif nodeName_ == 'vICMSSTRet':
            vICMSSTRet_ = child_.text
            vICMSSTRet_ = self.gds_validate_string(vICMSSTRet_, node, 'vICMSSTRet')
            self.vICMSSTRet = vICMSSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSSTRet)
        elif nodeName_ == 'vBCFCPSTRet':
            vBCFCPSTRet_ = child_.text
            vBCFCPSTRet_ = self.gds_validate_string(vBCFCPSTRet_, node, 'vBCFCPSTRet')
            self.vBCFCPSTRet = vBCFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPSTRet)
        elif nodeName_ == 'pFCPSTRet':
            pFCPSTRet_ = child_.text
            pFCPSTRet_ = self.gds_validate_string(pFCPSTRet_, node, 'pFCPSTRet')
            self.pFCPSTRet = pFCPSTRet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPSTRet)
        elif nodeName_ == 'vFCPSTRet':
            vFCPSTRet_ = child_.text
            vFCPSTRet_ = self.gds_validate_string(vFCPSTRet_, node, 'vFCPSTRet')
            self.vFCPSTRet = vFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPSTRet)
        elif nodeName_ == 'pRedBCEfet':
            pRedBCEfet_ = child_.text
            pRedBCEfet_ = self.gds_validate_string(pRedBCEfet_, node, 'pRedBCEfet')
            self.pRedBCEfet = pRedBCEfet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCEfet)
        elif nodeName_ == 'vBCEfet':
            vBCEfet_ = child_.text
            vBCEfet_ = self.gds_validate_string(vBCEfet_, node, 'vBCEfet')
            self.vBCEfet = vBCEfet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCEfet)
        elif nodeName_ == 'pICMSEfet':
            pICMSEfet_ = child_.text
            pICMSEfet_ = self.gds_validate_string(pICMSEfet_, node, 'pICMSEfet')
            self.pICMSEfet = pICMSEfet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pICMSEfet)
        elif nodeName_ == 'vICMSEfet':
            vICMSEfet_ = child_.text
            vICMSEfet_ = self.gds_validate_string(vICMSEfet_, node, 'vICMSEfet')
            self.vICMSEfet = vICMSEfet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSEfet)
# end class ICMS60Type


class ICMS70Type(GeneratedsSuper):
    """Grupo desoneração"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, modBC=None, pRedBC=None, vBC=None, pICMS=None, vICMS=None, vBCFCP=None, pFCP=None, vFCP=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, vICMSDeson=None, motDesICMS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType20(self.CST)
        self.modBC = modBC
        self.validate_modBCType21(self.modBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04(self.pRedBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vBCFCP = vBCFCP
        self.validate_TDec_1302(self.vBCFCP)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
        self.modBCST = modBCST
        self.validate_modBCSTType22(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.motDesICMS = motDesICMS
        self.validate_motDesICMSType23(self.motDesICMS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS70Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS70Type.subclass:
            return ICMS70Type.subclass(*args_, **kwargs_)
        else:
            return ICMS70Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_modBC(self):
        return self.modBC
    def set_modBC(self, modBC):
        self.modBC = modBC
    def get_pRedBC(self):
        return self.pRedBC
    def set_pRedBC(self, pRedBC):
        self.pRedBC = pRedBC
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pICMS(self):
        return self.pICMS
    def set_pICMS(self, pICMS):
        self.pICMS = pICMS
    def get_vICMS(self):
        return self.vICMS
    def set_vICMS(self, vICMS):
        self.vICMS = vICMS
    def get_vBCFCP(self):
        return self.vBCFCP
    def set_vBCFCP(self, vBCFCP):
        self.vBCFCP = vBCFCP
    def get_pFCP(self):
        return self.pFCP
    def set_pFCP(self, pFCP):
        self.pFCP = pFCP
    def get_vFCP(self):
        return self.vFCP
    def set_vFCP(self, vFCP):
        self.vFCP = vFCP
    def get_modBCST(self):
        return self.modBCST
    def set_modBCST(self, modBCST):
        self.modBCST = modBCST
    def get_pMVAST(self):
        return self.pMVAST
    def set_pMVAST(self, pMVAST):
        self.pMVAST = pMVAST
    def get_pRedBCST(self):
        return self.pRedBCST
    def set_pRedBCST(self, pRedBCST):
        self.pRedBCST = pRedBCST
    def get_vBCST(self):
        return self.vBCST
    def set_vBCST(self, vBCST):
        self.vBCST = vBCST
    def get_pICMSST(self):
        return self.pICMSST
    def set_pICMSST(self, pICMSST):
        self.pICMSST = pICMSST
    def get_vICMSST(self):
        return self.vICMSST
    def set_vICMSST(self, vICMSST):
        self.vICMSST = vICMSST
    def get_vBCFCPST(self):
        return self.vBCFCPST
    def set_vBCFCPST(self, vBCFCPST):
        self.vBCFCPST = vBCFCPST
    def get_pFCPST(self):
        return self.pFCPST
    def set_pFCPST(self, pFCPST):
        self.pFCPST = pFCPST
    def get_vFCPST(self):
        return self.vFCPST
    def set_vFCPST(self, vFCPST):
        self.vFCPST = vFCPST
    def get_vICMSDeson(self):
        return self.vICMSDeson
    def set_vICMSDeson(self, vICMSDeson):
        self.vICMSDeson = vICMSDeson
    def get_motDesICMS(self):
        return self.motDesICMS
    def set_motDesICMS(self, motDesICMS):
        self.motDesICMS = motDesICMS
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType20(self, value):
        # Validate type CSTType20, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['70']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType20' % {"value" : value.encode("utf-8")} )
    def validate_modBCType21(self, value):
        # Validate type modBCType21, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCType21' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [[u'^0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_modBCSTType22(self, value):
        # Validate type modBCSTType22, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCSTType22' % {"value" : value.encode("utf-8")} )
    def validate_motDesICMSType23(self, value):
        # Validate type motDesICMSType23, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['3', '9', '12']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on motDesICMSType23' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.pRedBC is not None or
            self.vBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.vBCFCP is not None or
            self.pFCP is not None or
            self.vFCP is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None or
            self.vICMSDeson is not None or
            self.motDesICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS70Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS70Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS70Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS70Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS70Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS70Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodBC>%s</%smodBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modBC), input_name='modBC')), namespaceprefix_ , eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBC>%s</%spRedBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespaceprefix_ , eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespaceprefix_ , eol_))
        if self.vBCFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCFCP>%s</%svBCFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCP), input_name='vBCFCP')), namespaceprefix_ , eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCP>%s</%spFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCP), input_name='pFCP')), namespaceprefix_ , eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCP>%s</%svFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCP), input_name='vFCP')), namespaceprefix_ , eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodBCST>%s</%smodBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modBCST), input_name='modBCST')), namespaceprefix_ , eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spMVAST>%s</%spMVAST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pMVAST), input_name='pMVAST')), namespaceprefix_ , eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBCST>%s</%spRedBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCST), input_name='pRedBCST')), namespaceprefix_ , eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCST>%s</%svBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), namespaceprefix_ , eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSST>%s</%spICMSST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSST), input_name='pICMSST')), namespaceprefix_ , eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSST>%s</%svICMSST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSST), input_name='vICMSST')), namespaceprefix_ , eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCFCPST>%s</%svBCFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPST), input_name='vBCFCPST')), namespaceprefix_ , eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCPST>%s</%spFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCPST), input_name='pFCPST')), namespaceprefix_ , eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCPST>%s</%svFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCPST), input_name='vFCPST')), namespaceprefix_ , eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSDeson>%s</%svICMSDeson>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSDeson), input_name='vICMSDeson')), namespaceprefix_ , eol_))
        if self.motDesICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smotDesICMS>%s</%smotDesICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.motDesICMS), input_name='motDesICMS')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType20
            self.validate_CSTType20(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType21
            self.validate_modBCType21(self.modBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pRedBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vBCFCP':
            vBCFCP_ = child_.text
            vBCFCP_ = self.gds_validate_string(vBCFCP_, node, 'vBCFCP')
            self.vBCFCP = vBCFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCP)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType22
            self.validate_modBCSTType22(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'motDesICMS':
            motDesICMS_ = child_.text
            motDesICMS_ = self.gds_validate_string(motDesICMS_, node, 'motDesICMS')
            self.motDesICMS = motDesICMS_
            # validate type motDesICMSType23
            self.validate_motDesICMSType23(self.motDesICMS)
# end class ICMS70Type


class ICMS90Type(GeneratedsSuper):
    """Grupo desoneração"""
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, modBC=None, vBC=None, pRedBC=None, pICMS=None, vICMS=None, vBCFCP=None, pFCP=None, vFCP=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, vICMSDeson=None, motDesICMS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType24(self.CST)
        self.modBC = modBC
        self.validate_modBCType25(self.modBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04Opc(self.pRedBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vBCFCP = vBCFCP
        self.validate_TDec_1302(self.vBCFCP)
        self.pFCP = pFCP
        self.validate_TDec_0302a04Opc(self.pFCP)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
        self.modBCST = modBCST
        self.validate_modBCSTType26(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.motDesICMS = motDesICMS
        self.validate_motDesICMSType27(self.motDesICMS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMS90Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMS90Type.subclass:
            return ICMS90Type.subclass(*args_, **kwargs_)
        else:
            return ICMS90Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_modBC(self):
        return self.modBC
    def set_modBC(self, modBC):
        self.modBC = modBC
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pRedBC(self):
        return self.pRedBC
    def set_pRedBC(self, pRedBC):
        self.pRedBC = pRedBC
    def get_pICMS(self):
        return self.pICMS
    def set_pICMS(self, pICMS):
        self.pICMS = pICMS
    def get_vICMS(self):
        return self.vICMS
    def set_vICMS(self, vICMS):
        self.vICMS = vICMS
    def get_vBCFCP(self):
        return self.vBCFCP
    def set_vBCFCP(self, vBCFCP):
        self.vBCFCP = vBCFCP
    def get_pFCP(self):
        return self.pFCP
    def set_pFCP(self, pFCP):
        self.pFCP = pFCP
    def get_vFCP(self):
        return self.vFCP
    def set_vFCP(self, vFCP):
        self.vFCP = vFCP
    def get_modBCST(self):
        return self.modBCST
    def set_modBCST(self, modBCST):
        self.modBCST = modBCST
    def get_pMVAST(self):
        return self.pMVAST
    def set_pMVAST(self, pMVAST):
        self.pMVAST = pMVAST
    def get_pRedBCST(self):
        return self.pRedBCST
    def set_pRedBCST(self, pRedBCST):
        self.pRedBCST = pRedBCST
    def get_vBCST(self):
        return self.vBCST
    def set_vBCST(self, vBCST):
        self.vBCST = vBCST
    def get_pICMSST(self):
        return self.pICMSST
    def set_pICMSST(self, pICMSST):
        self.pICMSST = pICMSST
    def get_vICMSST(self):
        return self.vICMSST
    def set_vICMSST(self, vICMSST):
        self.vICMSST = vICMSST
    def get_vBCFCPST(self):
        return self.vBCFCPST
    def set_vBCFCPST(self, vBCFCPST):
        self.vBCFCPST = vBCFCPST
    def get_pFCPST(self):
        return self.pFCPST
    def set_pFCPST(self, pFCPST):
        self.pFCPST = pFCPST
    def get_vFCPST(self):
        return self.vFCPST
    def set_vFCPST(self, vFCPST):
        self.vFCPST = vFCPST
    def get_vICMSDeson(self):
        return self.vICMSDeson
    def set_vICMSDeson(self, vICMSDeson):
        self.vICMSDeson = vICMSDeson
    def get_motDesICMS(self):
        return self.motDesICMS
    def set_motDesICMS(self, motDesICMS):
        self.motDesICMS = motDesICMS
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType24(self, value):
        # Validate type CSTType24, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['90']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType24' % {"value" : value.encode("utf-8")} )
    def validate_modBCType25(self, value):
        # Validate type modBCType25, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCType25' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [[u'^0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_modBCSTType26(self, value):
        # Validate type modBCSTType26, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCSTType26' % {"value" : value.encode("utf-8")} )
    def validate_motDesICMSType27(self, value):
        # Validate type motDesICMSType27, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['3', '9', '12']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on motDesICMSType27' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.vBC is not None or
            self.pRedBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.vBCFCP is not None or
            self.pFCP is not None or
            self.vFCP is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None or
            self.vICMSDeson is not None or
            self.motDesICMS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS90Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMS90Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMS90Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMS90Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMS90Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMS90Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodBC>%s</%smodBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modBC), input_name='modBC')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBC>%s</%spRedBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), namespaceprefix_ , eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespaceprefix_ , eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespaceprefix_ , eol_))
        if self.vBCFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCFCP>%s</%svBCFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCP), input_name='vBCFCP')), namespaceprefix_ , eol_))
        if self.pFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCP>%s</%spFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCP), input_name='pFCP')), namespaceprefix_ , eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCP>%s</%svFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCP), input_name='vFCP')), namespaceprefix_ , eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodBCST>%s</%smodBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modBCST), input_name='modBCST')), namespaceprefix_ , eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spMVAST>%s</%spMVAST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pMVAST), input_name='pMVAST')), namespaceprefix_ , eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBCST>%s</%spRedBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCST), input_name='pRedBCST')), namespaceprefix_ , eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCST>%s</%svBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), namespaceprefix_ , eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSST>%s</%spICMSST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSST), input_name='pICMSST')), namespaceprefix_ , eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSST>%s</%svICMSST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSST), input_name='vICMSST')), namespaceprefix_ , eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCFCPST>%s</%svBCFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPST), input_name='vBCFCPST')), namespaceprefix_ , eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCPST>%s</%spFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCPST), input_name='pFCPST')), namespaceprefix_ , eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCPST>%s</%svFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCPST), input_name='vFCPST')), namespaceprefix_ , eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSDeson>%s</%svICMSDeson>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSDeson), input_name='vICMSDeson')), namespaceprefix_ , eol_))
        if self.motDesICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smotDesICMS>%s</%smotDesICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.motDesICMS), input_name='motDesICMS')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType24
            self.validate_CSTType24(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType25
            self.validate_modBCType25(self.modBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vBCFCP':
            vBCFCP_ = child_.text
            vBCFCP_ = self.gds_validate_string(vBCFCP_, node, 'vBCFCP')
            self.vBCFCP = vBCFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCP)
        elif nodeName_ == 'pFCP':
            pFCP_ = child_.text
            pFCP_ = self.gds_validate_string(pFCP_, node, 'pFCP')
            self.pFCP = pFCP_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCP)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType26
            self.validate_modBCSTType26(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'motDesICMS':
            motDesICMS_ = child_.text
            motDesICMS_ = self.gds_validate_string(motDesICMS_, node, 'motDesICMS')
            self.motDesICMS = motDesICMS_
            # validate type motDesICMSType27
            self.validate_motDesICMSType27(self.motDesICMS)
# end class ICMS90Type


class ICMSPartType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, modBC=None, vBC=None, pRedBC=None, pICMS=None, vICMS=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, pBCOp=None, UFST=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType28(self.CST)
        self.modBC = modBC
        self.validate_modBCType29(self.modBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04Opc(self.pRedBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.modBCST = modBCST
        self.validate_modBCSTType30(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.pBCOp = pBCOp
        self.validate_TDec_0302a04Opc(self.pBCOp)
        self.UFST = UFST
        self.validate_TUf(self.UFST)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSPartType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSPartType.subclass:
            return ICMSPartType.subclass(*args_, **kwargs_)
        else:
            return ICMSPartType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_modBC(self):
        return self.modBC
    def set_modBC(self, modBC):
        self.modBC = modBC
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pRedBC(self):
        return self.pRedBC
    def set_pRedBC(self, pRedBC):
        self.pRedBC = pRedBC
    def get_pICMS(self):
        return self.pICMS
    def set_pICMS(self, pICMS):
        self.pICMS = pICMS
    def get_vICMS(self):
        return self.vICMS
    def set_vICMS(self, vICMS):
        self.vICMS = vICMS
    def get_modBCST(self):
        return self.modBCST
    def set_modBCST(self, modBCST):
        self.modBCST = modBCST
    def get_pMVAST(self):
        return self.pMVAST
    def set_pMVAST(self, pMVAST):
        self.pMVAST = pMVAST
    def get_pRedBCST(self):
        return self.pRedBCST
    def set_pRedBCST(self, pRedBCST):
        self.pRedBCST = pRedBCST
    def get_vBCST(self):
        return self.vBCST
    def set_vBCST(self, vBCST):
        self.vBCST = vBCST
    def get_pICMSST(self):
        return self.pICMSST
    def set_pICMSST(self, pICMSST):
        self.pICMSST = pICMSST
    def get_vICMSST(self):
        return self.vICMSST
    def set_vICMSST(self, vICMSST):
        self.vICMSST = vICMSST
    def get_pBCOp(self):
        return self.pBCOp
    def set_pBCOp(self, pBCOp):
        self.pBCOp = pBCOp
    def get_UFST(self):
        return self.UFST
    def set_UFST(self, UFST):
        self.UFST = UFST
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType28(self, value):
        # Validate type CSTType28, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['10', '90']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType28' % {"value" : value.encode("utf-8")} )
    def validate_modBCType29(self, value):
        # Validate type modBCType29, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCType29' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [[u'^0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_modBCSTType30(self, value):
        # Validate type modBCSTType30, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCSTType30' % {"value" : value.encode("utf-8")} )
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.modBC is not None or
            self.vBC is not None or
            self.pRedBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.pBCOp is not None or
            self.UFST is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSPartType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSPartType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSPartType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSPartType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSPartType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSPartType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodBC>%s</%smodBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modBC), input_name='modBC')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBC>%s</%spRedBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), namespaceprefix_ , eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespaceprefix_ , eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespaceprefix_ , eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodBCST>%s</%smodBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modBCST), input_name='modBCST')), namespaceprefix_ , eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spMVAST>%s</%spMVAST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pMVAST), input_name='pMVAST')), namespaceprefix_ , eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBCST>%s</%spRedBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCST), input_name='pRedBCST')), namespaceprefix_ , eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCST>%s</%svBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), namespaceprefix_ , eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSST>%s</%spICMSST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSST), input_name='pICMSST')), namespaceprefix_ , eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSST>%s</%svICMSST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSST), input_name='vICMSST')), namespaceprefix_ , eol_))
        if self.pBCOp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spBCOp>%s</%spBCOp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pBCOp), input_name='pBCOp')), namespaceprefix_ , eol_))
        if self.UFST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFST>%s</%sUFST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UFST), input_name='UFST')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType28
            self.validate_CSTType28(self.CST)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType29
            self.validate_modBCType29(self.modBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType30
            self.validate_modBCSTType30(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'pBCOp':
            pBCOp_ = child_.text
            pBCOp_ = self.gds_validate_string(pBCOp_, node, 'pBCOp')
            self.pBCOp = pBCOp_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pBCOp)
        elif nodeName_ == 'UFST':
            UFST_ = child_.text
            UFST_ = self.gds_validate_string(UFST_, node, 'UFST')
            self.UFST = UFST_
            # validate type TUf
            self.validate_TUf(self.UFST)
# end class ICMSPartType


class ICMSSTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orig=None, CST=None, vBCSTRet=None, vICMSSTRet=None, vBCSTDest=None, vICMSSTDest=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CST = CST
        self.validate_CSTType31(self.CST)
        self.vBCSTRet = vBCSTRet
        self.validate_TDec_1302(self.vBCSTRet)
        self.vICMSSTRet = vICMSSTRet
        self.validate_TDec_1302(self.vICMSSTRet)
        self.vBCSTDest = vBCSTDest
        self.validate_TDec_1302(self.vBCSTDest)
        self.vICMSSTDest = vICMSSTDest
        self.validate_TDec_1302(self.vICMSSTDest)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSTType.subclass:
            return ICMSSTType.subclass(*args_, **kwargs_)
        else:
            return ICMSSTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_vBCSTRet(self):
        return self.vBCSTRet
    def set_vBCSTRet(self, vBCSTRet):
        self.vBCSTRet = vBCSTRet
    def get_vICMSSTRet(self):
        return self.vICMSSTRet
    def set_vICMSSTRet(self, vICMSSTRet):
        self.vICMSSTRet = vICMSSTRet
    def get_vBCSTDest(self):
        return self.vBCSTDest
    def set_vBCSTDest(self, vBCSTDest):
        self.vBCSTDest = vBCSTDest
    def get_vICMSSTDest(self):
        return self.vICMSSTDest
    def set_vICMSSTDest(self, vICMSSTDest):
        self.vICMSSTDest = vICMSSTDest
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSTType31(self, value):
        # Validate type CSTType31, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['41', '60']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType31' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CST is not None or
            self.vBCSTRet is not None or
            self.vICMSSTRet is not None or
            self.vBCSTDest is not None or
            self.vICMSSTDest is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSSTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSSTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSSTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSSTType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSSTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.vBCSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCSTRet>%s</%svBCSTRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCSTRet), input_name='vBCSTRet')), namespaceprefix_ , eol_))
        if self.vICMSSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSSTRet>%s</%svICMSSTRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSSTRet), input_name='vICMSSTRet')), namespaceprefix_ , eol_))
        if self.vBCSTDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCSTDest>%s</%svBCSTDest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCSTDest), input_name='vBCSTDest')), namespaceprefix_ , eol_))
        if self.vICMSSTDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSSTDest>%s</%svICMSSTDest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSSTDest), input_name='vICMSSTDest')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType31
            self.validate_CSTType31(self.CST)
        elif nodeName_ == 'vBCSTRet':
            vBCSTRet_ = child_.text
            vBCSTRet_ = self.gds_validate_string(vBCSTRet_, node, 'vBCSTRet')
            self.vBCSTRet = vBCSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCSTRet)
        elif nodeName_ == 'vICMSSTRet':
            vICMSSTRet_ = child_.text
            vICMSSTRet_ = self.gds_validate_string(vICMSSTRet_, node, 'vICMSSTRet')
            self.vICMSSTRet = vICMSSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSSTRet)
        elif nodeName_ == 'vBCSTDest':
            vBCSTDest_ = child_.text
            vBCSTDest_ = self.gds_validate_string(vBCSTDest_, node, 'vBCSTDest')
            self.vBCSTDest = vBCSTDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCSTDest)
        elif nodeName_ == 'vICMSSTDest':
            vICMSSTDest_ = child_.text
            vICMSSTDest_ = self.gds_validate_string(vICMSSTDest_, node, 'vICMSSTDest')
            self.vICMSSTDest = vICMSSTDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSSTDest)
# end class ICMSSTType


class ICMSSN101Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orig=None, CSOSN=None, pCredSN=None, vCredICMSSN=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType(self.CSOSN)
        self.pCredSN = pCredSN
        self.validate_TDec_0302a04(self.pCredSN)
        self.vCredICMSSN = vCredICMSSN
        self.validate_TDec_1302(self.vCredICMSSN)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN101Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN101Type.subclass:
            return ICMSSN101Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN101Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CSOSN(self):
        return self.CSOSN
    def set_CSOSN(self, CSOSN):
        self.CSOSN = CSOSN
    def get_pCredSN(self):
        return self.pCredSN
    def set_pCredSN(self, pCredSN):
        self.pCredSN = pCredSN
    def get_vCredICMSSN(self):
        return self.vCredICMSSN
    def set_vCredICMSSN(self, vCredICMSSN):
        self.vCredICMSSN = vCredICMSSN
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSOSNType(self, value):
        # Validate type CSOSNType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['101']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSOSNType' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None or
            self.pCredSN is not None or
            self.vCredICMSSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSSN101Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN101Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSSN101Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSSN101Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSSN101Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSSN101Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCSOSN>%s</%sCSOSN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CSOSN), input_name='CSOSN')), namespaceprefix_ , eol_))
        if self.pCredSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spCredSN>%s</%spCredSN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pCredSN), input_name='pCredSN')), namespaceprefix_ , eol_))
        if self.vCredICMSSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCredICMSSN>%s</%svCredICMSSN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCredICMSSN), input_name='vCredICMSSN')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType
            self.validate_CSOSNType(self.CSOSN)
        elif nodeName_ == 'pCredSN':
            pCredSN_ = child_.text
            pCredSN_ = self.gds_validate_string(pCredSN_, node, 'pCredSN')
            self.pCredSN = pCredSN_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCredSN)
        elif nodeName_ == 'vCredICMSSN':
            vCredICMSSN_ = child_.text
            vCredICMSSN_ = self.gds_validate_string(vCredICMSSN_, node, 'vCredICMSSN')
            self.vCredICMSSN = vCredICMSSN_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCredICMSSN)
# end class ICMSSN101Type


class ICMSSN102Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orig=None, CSOSN=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType32(self.CSOSN)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN102Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN102Type.subclass:
            return ICMSSN102Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN102Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CSOSN(self):
        return self.CSOSN
    def set_CSOSN(self, CSOSN):
        self.CSOSN = CSOSN
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSOSNType32(self, value):
        # Validate type CSOSNType32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['102', '103', '300', '400']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSOSNType32' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSSN102Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN102Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSSN102Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSSN102Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSSN102Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSSN102Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCSOSN>%s</%sCSOSN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CSOSN), input_name='CSOSN')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType32
            self.validate_CSOSNType32(self.CSOSN)
# end class ICMSSN102Type


class ICMSSN201Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orig=None, CSOSN=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, pCredSN=None, vCredICMSSN=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType33(self.CSOSN)
        self.modBCST = modBCST
        self.validate_modBCSTType34(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.pCredSN = pCredSN
        self.validate_TDec_0302a04(self.pCredSN)
        self.vCredICMSSN = vCredICMSSN
        self.validate_TDec_1302(self.vCredICMSSN)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN201Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN201Type.subclass:
            return ICMSSN201Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN201Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CSOSN(self):
        return self.CSOSN
    def set_CSOSN(self, CSOSN):
        self.CSOSN = CSOSN
    def get_modBCST(self):
        return self.modBCST
    def set_modBCST(self, modBCST):
        self.modBCST = modBCST
    def get_pMVAST(self):
        return self.pMVAST
    def set_pMVAST(self, pMVAST):
        self.pMVAST = pMVAST
    def get_pRedBCST(self):
        return self.pRedBCST
    def set_pRedBCST(self, pRedBCST):
        self.pRedBCST = pRedBCST
    def get_vBCST(self):
        return self.vBCST
    def set_vBCST(self, vBCST):
        self.vBCST = vBCST
    def get_pICMSST(self):
        return self.pICMSST
    def set_pICMSST(self, pICMSST):
        self.pICMSST = pICMSST
    def get_vICMSST(self):
        return self.vICMSST
    def set_vICMSST(self, vICMSST):
        self.vICMSST = vICMSST
    def get_vBCFCPST(self):
        return self.vBCFCPST
    def set_vBCFCPST(self, vBCFCPST):
        self.vBCFCPST = vBCFCPST
    def get_pFCPST(self):
        return self.pFCPST
    def set_pFCPST(self, pFCPST):
        self.pFCPST = pFCPST
    def get_vFCPST(self):
        return self.vFCPST
    def set_vFCPST(self, vFCPST):
        self.vFCPST = vFCPST
    def get_pCredSN(self):
        return self.pCredSN
    def set_pCredSN(self, pCredSN):
        self.pCredSN = pCredSN
    def get_vCredICMSSN(self):
        return self.vCredICMSSN
    def set_vCredICMSSN(self, vCredICMSSN):
        self.vCredICMSSN = vCredICMSSN
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSOSNType33(self, value):
        # Validate type CSOSNType33, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['201']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSOSNType33' % {"value" : value.encode("utf-8")} )
    def validate_modBCSTType34(self, value):
        # Validate type modBCSTType34, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCSTType34' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [[u'^0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None or
            self.pCredSN is not None or
            self.vCredICMSSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSSN201Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN201Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSSN201Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSSN201Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSSN201Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSSN201Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCSOSN>%s</%sCSOSN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CSOSN), input_name='CSOSN')), namespaceprefix_ , eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodBCST>%s</%smodBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modBCST), input_name='modBCST')), namespaceprefix_ , eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spMVAST>%s</%spMVAST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pMVAST), input_name='pMVAST')), namespaceprefix_ , eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBCST>%s</%spRedBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCST), input_name='pRedBCST')), namespaceprefix_ , eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCST>%s</%svBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), namespaceprefix_ , eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSST>%s</%spICMSST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSST), input_name='pICMSST')), namespaceprefix_ , eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSST>%s</%svICMSST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSST), input_name='vICMSST')), namespaceprefix_ , eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCFCPST>%s</%svBCFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPST), input_name='vBCFCPST')), namespaceprefix_ , eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCPST>%s</%spFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCPST), input_name='pFCPST')), namespaceprefix_ , eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCPST>%s</%svFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCPST), input_name='vFCPST')), namespaceprefix_ , eol_))
        if self.pCredSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spCredSN>%s</%spCredSN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pCredSN), input_name='pCredSN')), namespaceprefix_ , eol_))
        if self.vCredICMSSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCredICMSSN>%s</%svCredICMSSN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCredICMSSN), input_name='vCredICMSSN')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType33
            self.validate_CSOSNType33(self.CSOSN)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType34
            self.validate_modBCSTType34(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'pCredSN':
            pCredSN_ = child_.text
            pCredSN_ = self.gds_validate_string(pCredSN_, node, 'pCredSN')
            self.pCredSN = pCredSN_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCredSN)
        elif nodeName_ == 'vCredICMSSN':
            vCredICMSSN_ = child_.text
            vCredICMSSN_ = self.gds_validate_string(vCredICMSSN_, node, 'vCredICMSSN')
            self.vCredICMSSN = vCredICMSSN_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCredICMSSN)
# end class ICMSSN201Type


class ICMSSN202Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orig=None, CSOSN=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType35(self.CSOSN)
        self.modBCST = modBCST
        self.validate_modBCSTType36(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN202Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN202Type.subclass:
            return ICMSSN202Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN202Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CSOSN(self):
        return self.CSOSN
    def set_CSOSN(self, CSOSN):
        self.CSOSN = CSOSN
    def get_modBCST(self):
        return self.modBCST
    def set_modBCST(self, modBCST):
        self.modBCST = modBCST
    def get_pMVAST(self):
        return self.pMVAST
    def set_pMVAST(self, pMVAST):
        self.pMVAST = pMVAST
    def get_pRedBCST(self):
        return self.pRedBCST
    def set_pRedBCST(self, pRedBCST):
        self.pRedBCST = pRedBCST
    def get_vBCST(self):
        return self.vBCST
    def set_vBCST(self, vBCST):
        self.vBCST = vBCST
    def get_pICMSST(self):
        return self.pICMSST
    def set_pICMSST(self, pICMSST):
        self.pICMSST = pICMSST
    def get_vICMSST(self):
        return self.vICMSST
    def set_vICMSST(self, vICMSST):
        self.vICMSST = vICMSST
    def get_vBCFCPST(self):
        return self.vBCFCPST
    def set_vBCFCPST(self, vBCFCPST):
        self.vBCFCPST = vBCFCPST
    def get_pFCPST(self):
        return self.pFCPST
    def set_pFCPST(self, pFCPST):
        self.pFCPST = pFCPST
    def get_vFCPST(self):
        return self.vFCPST
    def set_vFCPST(self, vFCPST):
        self.vFCPST = vFCPST
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSOSNType35(self, value):
        # Validate type CSOSNType35, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['202', '203']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSOSNType35' % {"value" : value.encode("utf-8")} )
    def validate_modBCSTType36(self, value):
        # Validate type modBCSTType36, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCSTType36' % {"value" : value.encode("utf-8")} )
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [[u'^0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSSN202Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN202Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSSN202Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSSN202Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSSN202Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSSN202Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCSOSN>%s</%sCSOSN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CSOSN), input_name='CSOSN')), namespaceprefix_ , eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodBCST>%s</%smodBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modBCST), input_name='modBCST')), namespaceprefix_ , eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spMVAST>%s</%spMVAST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pMVAST), input_name='pMVAST')), namespaceprefix_ , eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBCST>%s</%spRedBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCST), input_name='pRedBCST')), namespaceprefix_ , eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCST>%s</%svBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), namespaceprefix_ , eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSST>%s</%spICMSST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSST), input_name='pICMSST')), namespaceprefix_ , eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSST>%s</%svICMSST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSST), input_name='vICMSST')), namespaceprefix_ , eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCFCPST>%s</%svBCFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPST), input_name='vBCFCPST')), namespaceprefix_ , eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCPST>%s</%spFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCPST), input_name='pFCPST')), namespaceprefix_ , eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCPST>%s</%svFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCPST), input_name='vFCPST')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType35
            self.validate_CSOSNType35(self.CSOSN)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType36
            self.validate_modBCSTType36(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
# end class ICMSSN202Type


class ICMSSN500Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orig=None, CSOSN=None, vBCSTRet=None, pST=None, vICMSSTRet=None, vBCFCPSTRet=None, pFCPSTRet=None, vFCPSTRet=None, pRedBCEfet=None, vBCEfet=None, pICMSEfet=None, vICMSEfet=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType37(self.CSOSN)
        self.vBCSTRet = vBCSTRet
        self.validate_TDec_1302(self.vBCSTRet)
        self.pST = pST
        self.validate_TDec_0302a04Opc(self.pST)
        self.vICMSSTRet = vICMSSTRet
        self.validate_TDec_1302(self.vICMSSTRet)
        self.vBCFCPSTRet = vBCFCPSTRet
        self.validate_TDec_1302(self.vBCFCPSTRet)
        self.pFCPSTRet = pFCPSTRet
        self.validate_TDec_0302a04Opc(self.pFCPSTRet)
        self.vFCPSTRet = vFCPSTRet
        self.validate_TDec_1302(self.vFCPSTRet)
        self.pRedBCEfet = pRedBCEfet
        self.validate_TDec_0302a04Opc(self.pRedBCEfet)
        self.vBCEfet = vBCEfet
        self.validate_TDec_1302(self.vBCEfet)
        self.pICMSEfet = pICMSEfet
        self.validate_TDec_0302a04Opc(self.pICMSEfet)
        self.vICMSEfet = vICMSEfet
        self.validate_TDec_1302(self.vICMSEfet)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN500Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN500Type.subclass:
            return ICMSSN500Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN500Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CSOSN(self):
        return self.CSOSN
    def set_CSOSN(self, CSOSN):
        self.CSOSN = CSOSN
    def get_vBCSTRet(self):
        return self.vBCSTRet
    def set_vBCSTRet(self, vBCSTRet):
        self.vBCSTRet = vBCSTRet
    def get_pST(self):
        return self.pST
    def set_pST(self, pST):
        self.pST = pST
    def get_vICMSSTRet(self):
        return self.vICMSSTRet
    def set_vICMSSTRet(self, vICMSSTRet):
        self.vICMSSTRet = vICMSSTRet
    def get_vBCFCPSTRet(self):
        return self.vBCFCPSTRet
    def set_vBCFCPSTRet(self, vBCFCPSTRet):
        self.vBCFCPSTRet = vBCFCPSTRet
    def get_pFCPSTRet(self):
        return self.pFCPSTRet
    def set_pFCPSTRet(self, pFCPSTRet):
        self.pFCPSTRet = pFCPSTRet
    def get_vFCPSTRet(self):
        return self.vFCPSTRet
    def set_vFCPSTRet(self, vFCPSTRet):
        self.vFCPSTRet = vFCPSTRet
    def get_pRedBCEfet(self):
        return self.pRedBCEfet
    def set_pRedBCEfet(self, pRedBCEfet):
        self.pRedBCEfet = pRedBCEfet
    def get_vBCEfet(self):
        return self.vBCEfet
    def set_vBCEfet(self, vBCEfet):
        self.vBCEfet = vBCEfet
    def get_pICMSEfet(self):
        return self.pICMSEfet
    def set_pICMSEfet(self, pICMSEfet):
        self.pICMSEfet = pICMSEfet
    def get_vICMSEfet(self):
        return self.vICMSEfet
    def set_vICMSEfet(self, vICMSEfet):
        self.vICMSEfet = vICMSEfet
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSOSNType37(self, value):
        # Validate type CSOSNType37, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['500']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSOSNType37' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [[u'^0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None or
            self.vBCSTRet is not None or
            self.pST is not None or
            self.vICMSSTRet is not None or
            self.vBCFCPSTRet is not None or
            self.pFCPSTRet is not None or
            self.vFCPSTRet is not None or
            self.pRedBCEfet is not None or
            self.vBCEfet is not None or
            self.pICMSEfet is not None or
            self.vICMSEfet is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSSN500Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN500Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSSN500Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSSN500Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSSN500Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSSN500Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCSOSN>%s</%sCSOSN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CSOSN), input_name='CSOSN')), namespaceprefix_ , eol_))
        if self.vBCSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCSTRet>%s</%svBCSTRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCSTRet), input_name='vBCSTRet')), namespaceprefix_ , eol_))
        if self.pST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spST>%s</%spST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pST), input_name='pST')), namespaceprefix_ , eol_))
        if self.vICMSSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSSTRet>%s</%svICMSSTRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSSTRet), input_name='vICMSSTRet')), namespaceprefix_ , eol_))
        if self.vBCFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCFCPSTRet>%s</%svBCFCPSTRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPSTRet), input_name='vBCFCPSTRet')), namespaceprefix_ , eol_))
        if self.pFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCPSTRet>%s</%spFCPSTRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCPSTRet), input_name='pFCPSTRet')), namespaceprefix_ , eol_))
        if self.vFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCPSTRet>%s</%svFCPSTRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCPSTRet), input_name='vFCPSTRet')), namespaceprefix_ , eol_))
        if self.pRedBCEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBCEfet>%s</%spRedBCEfet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCEfet), input_name='pRedBCEfet')), namespaceprefix_ , eol_))
        if self.vBCEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCEfet>%s</%svBCEfet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCEfet), input_name='vBCEfet')), namespaceprefix_ , eol_))
        if self.pICMSEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSEfet>%s</%spICMSEfet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSEfet), input_name='pICMSEfet')), namespaceprefix_ , eol_))
        if self.vICMSEfet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSEfet>%s</%svICMSEfet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSEfet), input_name='vICMSEfet')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType37
            self.validate_CSOSNType37(self.CSOSN)
        elif nodeName_ == 'vBCSTRet':
            vBCSTRet_ = child_.text
            vBCSTRet_ = self.gds_validate_string(vBCSTRet_, node, 'vBCSTRet')
            self.vBCSTRet = vBCSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCSTRet)
        elif nodeName_ == 'pST':
            pST_ = child_.text
            pST_ = self.gds_validate_string(pST_, node, 'pST')
            self.pST = pST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pST)
        elif nodeName_ == 'vICMSSTRet':
            vICMSSTRet_ = child_.text
            vICMSSTRet_ = self.gds_validate_string(vICMSSTRet_, node, 'vICMSSTRet')
            self.vICMSSTRet = vICMSSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSSTRet)
        elif nodeName_ == 'vBCFCPSTRet':
            vBCFCPSTRet_ = child_.text
            vBCFCPSTRet_ = self.gds_validate_string(vBCFCPSTRet_, node, 'vBCFCPSTRet')
            self.vBCFCPSTRet = vBCFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPSTRet)
        elif nodeName_ == 'pFCPSTRet':
            pFCPSTRet_ = child_.text
            pFCPSTRet_ = self.gds_validate_string(pFCPSTRet_, node, 'pFCPSTRet')
            self.pFCPSTRet = pFCPSTRet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPSTRet)
        elif nodeName_ == 'vFCPSTRet':
            vFCPSTRet_ = child_.text
            vFCPSTRet_ = self.gds_validate_string(vFCPSTRet_, node, 'vFCPSTRet')
            self.vFCPSTRet = vFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPSTRet)
        elif nodeName_ == 'pRedBCEfet':
            pRedBCEfet_ = child_.text
            pRedBCEfet_ = self.gds_validate_string(pRedBCEfet_, node, 'pRedBCEfet')
            self.pRedBCEfet = pRedBCEfet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCEfet)
        elif nodeName_ == 'vBCEfet':
            vBCEfet_ = child_.text
            vBCEfet_ = self.gds_validate_string(vBCEfet_, node, 'vBCEfet')
            self.vBCEfet = vBCEfet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCEfet)
        elif nodeName_ == 'pICMSEfet':
            pICMSEfet_ = child_.text
            pICMSEfet_ = self.gds_validate_string(pICMSEfet_, node, 'pICMSEfet')
            self.pICMSEfet = pICMSEfet_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pICMSEfet)
        elif nodeName_ == 'vICMSEfet':
            vICMSEfet_ = child_.text
            vICMSEfet_ = self.gds_validate_string(vICMSEfet_, node, 'vICMSEfet')
            self.vICMSEfet = vICMSEfet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSEfet)
# end class ICMSSN500Type


class ICMSSN900Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, orig=None, CSOSN=None, modBC=None, vBC=None, pRedBC=None, pICMS=None, vICMS=None, modBCST=None, pMVAST=None, pRedBCST=None, vBCST=None, pICMSST=None, vICMSST=None, vBCFCPST=None, pFCPST=None, vFCPST=None, pCredSN=None, vCredICMSSN=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.orig = orig
        self.validate_Torig(self.orig)
        self.CSOSN = CSOSN
        self.validate_CSOSNType38(self.CSOSN)
        self.modBC = modBC
        self.validate_modBCType39(self.modBC)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pRedBC = pRedBC
        self.validate_TDec_0302a04Opc(self.pRedBC)
        self.pICMS = pICMS
        self.validate_TDec_0302a04(self.pICMS)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.modBCST = modBCST
        self.validate_modBCSTType40(self.modBCST)
        self.pMVAST = pMVAST
        self.validate_TDec_0302a04Opc(self.pMVAST)
        self.pRedBCST = pRedBCST
        self.validate_TDec_0302a04Opc(self.pRedBCST)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.pICMSST = pICMSST
        self.validate_TDec_0302a04(self.pICMSST)
        self.vICMSST = vICMSST
        self.validate_TDec_1302(self.vICMSST)
        self.vBCFCPST = vBCFCPST
        self.validate_TDec_1302(self.vBCFCPST)
        self.pFCPST = pFCPST
        self.validate_TDec_0302a04Opc(self.pFCPST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.pCredSN = pCredSN
        self.validate_TDec_0302a04(self.pCredSN)
        self.vCredICMSSN = vCredICMSSN
        self.validate_TDec_1302(self.vCredICMSSN)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSSN900Type)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSSN900Type.subclass:
            return ICMSSN900Type.subclass(*args_, **kwargs_)
        else:
            return ICMSSN900Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_orig(self):
        return self.orig
    def set_orig(self, orig):
        self.orig = orig
    def get_CSOSN(self):
        return self.CSOSN
    def set_CSOSN(self, CSOSN):
        self.CSOSN = CSOSN
    def get_modBC(self):
        return self.modBC
    def set_modBC(self, modBC):
        self.modBC = modBC
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pRedBC(self):
        return self.pRedBC
    def set_pRedBC(self, pRedBC):
        self.pRedBC = pRedBC
    def get_pICMS(self):
        return self.pICMS
    def set_pICMS(self, pICMS):
        self.pICMS = pICMS
    def get_vICMS(self):
        return self.vICMS
    def set_vICMS(self, vICMS):
        self.vICMS = vICMS
    def get_modBCST(self):
        return self.modBCST
    def set_modBCST(self, modBCST):
        self.modBCST = modBCST
    def get_pMVAST(self):
        return self.pMVAST
    def set_pMVAST(self, pMVAST):
        self.pMVAST = pMVAST
    def get_pRedBCST(self):
        return self.pRedBCST
    def set_pRedBCST(self, pRedBCST):
        self.pRedBCST = pRedBCST
    def get_vBCST(self):
        return self.vBCST
    def set_vBCST(self, vBCST):
        self.vBCST = vBCST
    def get_pICMSST(self):
        return self.pICMSST
    def set_pICMSST(self, pICMSST):
        self.pICMSST = pICMSST
    def get_vICMSST(self):
        return self.vICMSST
    def set_vICMSST(self, vICMSST):
        self.vICMSST = vICMSST
    def get_vBCFCPST(self):
        return self.vBCFCPST
    def set_vBCFCPST(self, vBCFCPST):
        self.vBCFCPST = vBCFCPST
    def get_pFCPST(self):
        return self.pFCPST
    def set_pFCPST(self, pFCPST):
        self.pFCPST = pFCPST
    def get_vFCPST(self):
        return self.vFCPST
    def set_vFCPST(self, vFCPST):
        self.vFCPST = vFCPST
    def get_pCredSN(self):
        return self.pCredSN
    def set_pCredSN(self, pCredSN):
        self.pCredSN = pCredSN
    def get_vCredICMSSN(self):
        return self.vCredICMSSN
    def set_vCredICMSSN(self, vCredICMSSN):
        self.vCredICMSSN = vCredICMSSN
    def validate_Torig(self, value):
        # Validate type Torig, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5', '6', '7', '8']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on Torig' % {"value" : value.encode("utf-8")} )
    def validate_CSOSNType38(self, value):
        # Validate type CSOSNType38, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['900']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSOSNType38' % {"value" : value.encode("utf-8")} )
    def validate_modBCType39(self, value):
        # Validate type modBCType39, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCType39' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04Opc(self, value):
        # Validate type TDec_0302a04Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04Opc_patterns_, ))
    validate_TDec_0302a04Opc_patterns_ = [[u'^0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_modBCSTType40(self, value):
        # Validate type modBCSTType40, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '5']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modBCSTType40' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.orig is not None or
            self.CSOSN is not None or
            self.modBC is not None or
            self.vBC is not None or
            self.pRedBC is not None or
            self.pICMS is not None or
            self.vICMS is not None or
            self.modBCST is not None or
            self.pMVAST is not None or
            self.pRedBCST is not None or
            self.vBCST is not None or
            self.pICMSST is not None or
            self.vICMSST is not None or
            self.vBCFCPST is not None or
            self.pFCPST is not None or
            self.vFCPST is not None or
            self.pCredSN is not None or
            self.vCredICMSSN is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSSN900Type', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSSN900Type')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSSN900Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSSN900Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSSN900Type'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSSN900Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.orig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sorig>%s</%sorig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.orig), input_name='orig')), namespaceprefix_ , eol_))
        if self.CSOSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCSOSN>%s</%sCSOSN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CSOSN), input_name='CSOSN')), namespaceprefix_ , eol_))
        if self.modBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodBC>%s</%smodBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modBC), input_name='modBC')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pRedBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBC>%s</%spRedBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBC), input_name='pRedBC')), namespaceprefix_ , eol_))
        if self.pICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMS>%s</%spICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMS), input_name='pICMS')), namespaceprefix_ , eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespaceprefix_ , eol_))
        if self.modBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodBCST>%s</%smodBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modBCST), input_name='modBCST')), namespaceprefix_ , eol_))
        if self.pMVAST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spMVAST>%s</%spMVAST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pMVAST), input_name='pMVAST')), namespaceprefix_ , eol_))
        if self.pRedBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spRedBCST>%s</%spRedBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pRedBCST), input_name='pRedBCST')), namespaceprefix_ , eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCST>%s</%svBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), namespaceprefix_ , eol_))
        if self.pICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSST>%s</%spICMSST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSST), input_name='pICMSST')), namespaceprefix_ , eol_))
        if self.vICMSST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSST>%s</%svICMSST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSST), input_name='vICMSST')), namespaceprefix_ , eol_))
        if self.vBCFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCFCPST>%s</%svBCFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPST), input_name='vBCFCPST')), namespaceprefix_ , eol_))
        if self.pFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCPST>%s</%spFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCPST), input_name='pFCPST')), namespaceprefix_ , eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCPST>%s</%svFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCPST), input_name='vFCPST')), namespaceprefix_ , eol_))
        if self.pCredSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spCredSN>%s</%spCredSN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pCredSN), input_name='pCredSN')), namespaceprefix_ , eol_))
        if self.vCredICMSSN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCredICMSSN>%s</%svCredICMSSN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCredICMSSN), input_name='vCredICMSSN')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'orig':
            orig_ = child_.text
            orig_ = self.gds_validate_string(orig_, node, 'orig')
            self.orig = orig_
            # validate type Torig
            self.validate_Torig(self.orig)
        elif nodeName_ == 'CSOSN':
            CSOSN_ = child_.text
            CSOSN_ = self.gds_validate_string(CSOSN_, node, 'CSOSN')
            self.CSOSN = CSOSN_
            # validate type CSOSNType38
            self.validate_CSOSNType38(self.CSOSN)
        elif nodeName_ == 'modBC':
            modBC_ = child_.text
            modBC_ = self.gds_validate_string(modBC_, node, 'modBC')
            self.modBC = modBC_
            # validate type modBCType39
            self.validate_modBCType39(self.modBC)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pRedBC':
            pRedBC_ = child_.text
            pRedBC_ = self.gds_validate_string(pRedBC_, node, 'pRedBC')
            self.pRedBC = pRedBC_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBC)
        elif nodeName_ == 'pICMS':
            pICMS_ = child_.text
            pICMS_ = self.gds_validate_string(pICMS_, node, 'pICMS')
            self.pICMS = pICMS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMS)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'modBCST':
            modBCST_ = child_.text
            modBCST_ = self.gds_validate_string(modBCST_, node, 'modBCST')
            self.modBCST = modBCST_
            # validate type modBCSTType40
            self.validate_modBCSTType40(self.modBCST)
        elif nodeName_ == 'pMVAST':
            pMVAST_ = child_.text
            pMVAST_ = self.gds_validate_string(pMVAST_, node, 'pMVAST')
            self.pMVAST = pMVAST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pMVAST)
        elif nodeName_ == 'pRedBCST':
            pRedBCST_ = child_.text
            pRedBCST_ = self.gds_validate_string(pRedBCST_, node, 'pRedBCST')
            self.pRedBCST = pRedBCST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pRedBCST)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'pICMSST':
            pICMSST_ = child_.text
            pICMSST_ = self.gds_validate_string(pICMSST_, node, 'pICMSST')
            self.pICMSST = pICMSST_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSST)
        elif nodeName_ == 'vICMSST':
            vICMSST_ = child_.text
            vICMSST_ = self.gds_validate_string(vICMSST_, node, 'vICMSST')
            self.vICMSST = vICMSST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSST)
        elif nodeName_ == 'vBCFCPST':
            vBCFCPST_ = child_.text
            vBCFCPST_ = self.gds_validate_string(vBCFCPST_, node, 'vBCFCPST')
            self.vBCFCPST = vBCFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPST)
        elif nodeName_ == 'pFCPST':
            pFCPST_ = child_.text
            pFCPST_ = self.gds_validate_string(pFCPST_, node, 'pFCPST')
            self.pFCPST = pFCPST_
            # validate type TDec_0302a04Opc
            self.validate_TDec_0302a04Opc(self.pFCPST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'pCredSN':
            pCredSN_ = child_.text
            pCredSN_ = self.gds_validate_string(pCredSN_, node, 'pCredSN')
            self.pCredSN = pCredSN_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCredSN)
        elif nodeName_ == 'vCredICMSSN':
            vCredICMSSN_ = child_.text
            vCredICMSSN_ = self.gds_validate_string(vCredICMSSN_, node, 'vCredICMSSN')
            self.vCredICMSSN = vCredICMSSN_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCredICMSSN)
# end class ICMSSN900Type


class IIType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vBC=None, vDespAdu=None, vII=None, vIOF=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.vDespAdu = vDespAdu
        self.validate_TDec_1302(self.vDespAdu)
        self.vII = vII
        self.validate_TDec_1302(self.vII)
        self.vIOF = vIOF
        self.validate_TDec_1302(self.vIOF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IIType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IIType.subclass:
            return IIType.subclass(*args_, **kwargs_)
        else:
            return IIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_vDespAdu(self):
        return self.vDespAdu
    def set_vDespAdu(self, vDespAdu):
        self.vDespAdu = vDespAdu
    def get_vII(self):
        return self.vII
    def set_vII(self, vII):
        self.vII = vII
    def get_vIOF(self):
        return self.vIOF
    def set_vIOF(self, vIOF):
        self.vIOF = vIOF
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.vBC is not None or
            self.vDespAdu is not None or
            self.vII is not None or
            self.vIOF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IIType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IIType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IIType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IIType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IIType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IIType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.vDespAdu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDespAdu>%s</%svDespAdu>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDespAdu), input_name='vDespAdu')), namespaceprefix_ , eol_))
        if self.vII is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svII>%s</%svII>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vII), input_name='vII')), namespaceprefix_ , eol_))
        if self.vIOF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svIOF>%s</%svIOF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vIOF), input_name='vIOF')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'vDespAdu':
            vDespAdu_ = child_.text
            vDespAdu_ = self.gds_validate_string(vDespAdu_, node, 'vDespAdu')
            self.vDespAdu = vDespAdu_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vDespAdu)
        elif nodeName_ == 'vII':
            vII_ = child_.text
            vII_ = self.gds_validate_string(vII_, node, 'vII')
            self.vII = vII_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vII)
        elif nodeName_ == 'vIOF':
            vIOF_ = child_.text
            vIOF_ = self.gds_validate_string(vIOF_, node, 'vIOF')
            self.vIOF = vIOF_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vIOF)
# end class IIType


class ISSQNType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vBC=None, vAliq=None, vISSQN=None, cMunFG=None, cListServ=None, vDeducao=None, vOutro=None, vDescIncond=None, vDescCond=None, vISSRet=None, indISS=None, cServico=None, cMun=None, cPais=None, nProcesso=None, indIncentivo=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.vAliq = vAliq
        self.validate_TDec_0302a04(self.vAliq)
        self.vISSQN = vISSQN
        self.validate_TDec_1302(self.vISSQN)
        self.cMunFG = cMunFG
        self.validate_TCodMunIBGE(self.cMunFG)
        self.cListServ = cListServ
        self.validate_TCListServ(self.cListServ)
        self.vDeducao = vDeducao
        self.validate_TDec_1302Opc(self.vDeducao)
        self.vOutro = vOutro
        self.validate_TDec_1302Opc(self.vOutro)
        self.vDescIncond = vDescIncond
        self.validate_TDec_1302Opc(self.vDescIncond)
        self.vDescCond = vDescCond
        self.validate_TDec_1302Opc(self.vDescCond)
        self.vISSRet = vISSRet
        self.validate_TDec_1302Opc(self.vISSRet)
        self.indISS = indISS
        self.validate_indISSType(self.indISS)
        self.cServico = cServico
        self.validate_cServicoType(self.cServico)
        self.cMun = cMun
        self.validate_TCodMunIBGE(self.cMun)
        self.cPais = cPais
        self.validate_cPaisType(self.cPais)
        self.nProcesso = nProcesso
        self.validate_nProcessoType(self.nProcesso)
        self.indIncentivo = indIncentivo
        self.validate_indIncentivoType(self.indIncentivo)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ISSQNType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ISSQNType.subclass:
            return ISSQNType.subclass(*args_, **kwargs_)
        else:
            return ISSQNType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_vAliq(self):
        return self.vAliq
    def set_vAliq(self, vAliq):
        self.vAliq = vAliq
    def get_vISSQN(self):
        return self.vISSQN
    def set_vISSQN(self, vISSQN):
        self.vISSQN = vISSQN
    def get_cMunFG(self):
        return self.cMunFG
    def set_cMunFG(self, cMunFG):
        self.cMunFG = cMunFG
    def get_cListServ(self):
        return self.cListServ
    def set_cListServ(self, cListServ):
        self.cListServ = cListServ
    def get_vDeducao(self):
        return self.vDeducao
    def set_vDeducao(self, vDeducao):
        self.vDeducao = vDeducao
    def get_vOutro(self):
        return self.vOutro
    def set_vOutro(self, vOutro):
        self.vOutro = vOutro
    def get_vDescIncond(self):
        return self.vDescIncond
    def set_vDescIncond(self, vDescIncond):
        self.vDescIncond = vDescIncond
    def get_vDescCond(self):
        return self.vDescCond
    def set_vDescCond(self, vDescCond):
        self.vDescCond = vDescCond
    def get_vISSRet(self):
        return self.vISSRet
    def set_vISSRet(self, vISSRet):
        self.vISSRet = vISSRet
    def get_indISS(self):
        return self.indISS
    def set_indISS(self, indISS):
        self.indISS = indISS
    def get_cServico(self):
        return self.cServico
    def set_cServico(self, cServico):
        self.cServico = cServico
    def get_cMun(self):
        return self.cMun
    def set_cMun(self, cMun):
        self.cMun = cMun
    def get_cPais(self):
        return self.cPais
    def set_cPais(self, cPais):
        self.cPais = cPais
    def get_nProcesso(self):
        return self.nProcesso
    def set_nProcesso(self, nProcesso):
        self.nProcesso = nProcesso
    def get_indIncentivo(self):
        return self.indIncentivo
    def set_indIncentivo(self, indIncentivo):
        self.indIncentivo = indIncentivo
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [[u'^[0-9]{7}$']]
    def validate_TCListServ(self, value):
        # Validate type TCListServ, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01.01', '01.02', '01.03', '01.04', '01.05', '01.06', '01.07', '01.08', '02.01', '03.02', '03.03', '03.04', '03.05', '04.01', '04.02', '04.03', '04.04', '04.05', '04.06', '04.07', '04.08', '04.09', '04.10', '04.11', '04.12', '04.13', '04.14', '04.15', '04.16', '04.17', '04.18', '04.19', '04.20', '04.21', '04.22', '04.23', '05.01', '05.02', '05.03', '05.04', '05.05', '05.06', '05.07', '05.08', '05.09', '06.01', '06.02', '06.03', '06.04', '06.05', '07.01', '07.02', '07.03', '07.04', '07.05', '07.06', '07.07', '07.08', '07.09', '07.10', '07.11', '07.12', '07.13', '07.16', '07.17', '07.18', '07.19', '07.20', '07.21', '07.22', '08.01', '08.02', '09.01', '09.02', '09.03', '10.01', '10.02', '10.03', '10.04', '10.05', '10.06', '10.07', '10.08', '10.09', '10.10', '11.01', '11.02', '11.03', '11.04', '12.01', '12.02', '12.03', '12.04', '12.05', '12.06', '12.07', '12.08', '12.09', '12.10', '12.11', '12.12', '12.13', '12.14', '12.15', '12.16', '12.17', '13.02', '13.03', '13.04', '13.05', '14.01', '14.02', '14.03', '14.04', '14.05', '14.06', '14.07', '14.08', '14.09', '14.10', '14.11', '14.12', '14.13', '15.01', '15.02', '15.03', '15.04', '15.05', '15.06', '15.07', '15.08', '15.09', '15.10', '15.11', '15.12', '15.13', '15.14', '15.15', '15.16', '15.17', '15.18', '16.01', '17.01', '17.02', '17.03', '17.04', '17.05', '17.06', '17.08', '17.09', '17.10', '17.11', '17.12', '17.13', '17.14', '17.15', '17.16', '17.17', '17.18', '17.19', '17.20', '17.21', '17.22', '17.23', '17.24', '17.25', '18.01', '19.01', '20.01', '20.02', '20.03', '21.01', '22.01', '23.01', '24.01', '25.01', '25.02', '25.03', '25.04', '26.01', '27.01', '28.01', '29.01', '30.01', '31.01', '32.01', '33.01', '34.01', '35.01', '36.01', '37.01', '38.01', '39.01', '40.01']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TCListServ' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [[u'^0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_indISSType(self, value):
        # Validate type indISSType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6', '7']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indISSType' % {"value" : value.encode("utf-8")} )
    def validate_cServicoType(self, value):
        # Validate type cServicoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cServicoType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cServicoType' % {"value" : value.encode("utf-8")} )
    def validate_cPaisType(self, value):
        # Validate type cPaisType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_cPaisType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cPaisType_patterns_, ))
    validate_cPaisType_patterns_ = [[u'^[0-9]{1,4}$']]
    def validate_nProcessoType(self, value):
        # Validate type nProcessoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 30:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nProcessoType' % {"value" : value.encode("utf-8")} )
            if len(value) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nProcessoType' % {"value" : value.encode("utf-8")} )
    def validate_indIncentivoType(self, value):
        # Validate type indIncentivoType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indIncentivoType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.vBC is not None or
            self.vAliq is not None or
            self.vISSQN is not None or
            self.cMunFG is not None or
            self.cListServ is not None or
            self.vDeducao is not None or
            self.vOutro is not None or
            self.vDescIncond is not None or
            self.vDescCond is not None or
            self.vISSRet is not None or
            self.indISS is not None or
            self.cServico is not None or
            self.cMun is not None or
            self.cPais is not None or
            self.nProcesso is not None or
            self.indIncentivo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ISSQNType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ISSQNType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ISSQNType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ISSQNType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ISSQNType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ISSQNType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.vAliq is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svAliq>%s</%svAliq>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vAliq), input_name='vAliq')), namespaceprefix_ , eol_))
        if self.vISSQN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svISSQN>%s</%svISSQN>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vISSQN), input_name='vISSQN')), namespaceprefix_ , eol_))
        if self.cMunFG is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMunFG>%s</%scMunFG>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMunFG), input_name='cMunFG')), namespaceprefix_ , eol_))
        if self.cListServ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scListServ>%s</%scListServ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cListServ), input_name='cListServ')), namespaceprefix_ , eol_))
        if self.vDeducao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDeducao>%s</%svDeducao>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDeducao), input_name='vDeducao')), namespaceprefix_ , eol_))
        if self.vOutro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svOutro>%s</%svOutro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vOutro), input_name='vOutro')), namespaceprefix_ , eol_))
        if self.vDescIncond is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDescIncond>%s</%svDescIncond>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDescIncond), input_name='vDescIncond')), namespaceprefix_ , eol_))
        if self.vDescCond is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDescCond>%s</%svDescCond>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDescCond), input_name='vDescCond')), namespaceprefix_ , eol_))
        if self.vISSRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svISSRet>%s</%svISSRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vISSRet), input_name='vISSRet')), namespaceprefix_ , eol_))
        if self.indISS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindISS>%s</%sindISS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indISS), input_name='indISS')), namespaceprefix_ , eol_))
        if self.cServico is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scServico>%s</%scServico>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cServico), input_name='cServico')), namespaceprefix_ , eol_))
        if self.cMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMun>%s</%scMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMun), input_name='cMun')), namespaceprefix_ , eol_))
        if self.cPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scPais>%s</%scPais>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cPais), input_name='cPais')), namespaceprefix_ , eol_))
        if self.nProcesso is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snProcesso>%s</%snProcesso>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nProcesso), input_name='nProcesso')), namespaceprefix_ , eol_))
        if self.indIncentivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindIncentivo>%s</%sindIncentivo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indIncentivo), input_name='indIncentivo')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'vAliq':
            vAliq_ = child_.text
            vAliq_ = self.gds_validate_string(vAliq_, node, 'vAliq')
            self.vAliq = vAliq_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.vAliq)
        elif nodeName_ == 'vISSQN':
            vISSQN_ = child_.text
            vISSQN_ = self.gds_validate_string(vISSQN_, node, 'vISSQN')
            self.vISSQN = vISSQN_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vISSQN)
        elif nodeName_ == 'cMunFG':
            cMunFG_ = child_.text
            cMunFG_ = self.gds_validate_string(cMunFG_, node, 'cMunFG')
            self.cMunFG = cMunFG_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunFG)
        elif nodeName_ == 'cListServ':
            cListServ_ = child_.text
            cListServ_ = self.gds_validate_string(cListServ_, node, 'cListServ')
            self.cListServ = cListServ_
            # validate type TCListServ
            self.validate_TCListServ(self.cListServ)
        elif nodeName_ == 'vDeducao':
            vDeducao_ = child_.text
            vDeducao_ = self.gds_validate_string(vDeducao_, node, 'vDeducao')
            self.vDeducao = vDeducao_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDeducao)
        elif nodeName_ == 'vOutro':
            vOutro_ = child_.text
            vOutro_ = self.gds_validate_string(vOutro_, node, 'vOutro')
            self.vOutro = vOutro_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vOutro)
        elif nodeName_ == 'vDescIncond':
            vDescIncond_ = child_.text
            vDescIncond_ = self.gds_validate_string(vDescIncond_, node, 'vDescIncond')
            self.vDescIncond = vDescIncond_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDescIncond)
        elif nodeName_ == 'vDescCond':
            vDescCond_ = child_.text
            vDescCond_ = self.gds_validate_string(vDescCond_, node, 'vDescCond')
            self.vDescCond = vDescCond_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDescCond)
        elif nodeName_ == 'vISSRet':
            vISSRet_ = child_.text
            vISSRet_ = self.gds_validate_string(vISSRet_, node, 'vISSRet')
            self.vISSRet = vISSRet_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vISSRet)
        elif nodeName_ == 'indISS':
            indISS_ = child_.text
            indISS_ = self.gds_validate_string(indISS_, node, 'indISS')
            self.indISS = indISS_
            # validate type indISSType
            self.validate_indISSType(self.indISS)
        elif nodeName_ == 'cServico':
            cServico_ = child_.text
            cServico_ = self.gds_validate_string(cServico_, node, 'cServico')
            self.cServico = cServico_
            # validate type cServicoType
            self.validate_cServicoType(self.cServico)
        elif nodeName_ == 'cMun':
            cMun_ = child_.text
            cMun_ = self.gds_validate_string(cMun_, node, 'cMun')
            self.cMun = cMun_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMun)
        elif nodeName_ == 'cPais':
            cPais_ = child_.text
            cPais_ = self.gds_validate_string(cPais_, node, 'cPais')
            self.cPais = cPais_
            # validate type cPaisType
            self.validate_cPaisType(self.cPais)
        elif nodeName_ == 'nProcesso':
            nProcesso_ = child_.text
            nProcesso_ = self.gds_validate_string(nProcesso_, node, 'nProcesso')
            self.nProcesso = nProcesso_
            # validate type nProcessoType
            self.validate_nProcessoType(self.nProcesso)
        elif nodeName_ == 'indIncentivo':
            indIncentivo_ = child_.text
            indIncentivo_ = self.gds_validate_string(indIncentivo_, node, 'indIncentivo')
            self.indIncentivo = indIncentivo_
            # validate type indIncentivoType
            self.validate_indIncentivoType(self.indIncentivo)
# end class ISSQNType


class PISType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PISAliq=None, PISQtde=None, PISNT=None, PISOutr=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.PISAliq = PISAliq
        self.PISQtde = PISQtde
        self.PISNT = PISNT
        self.PISOutr = PISOutr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISType.subclass:
            return PISType.subclass(*args_, **kwargs_)
        else:
            return PISType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PISAliq(self):
        return self.PISAliq
    def set_PISAliq(self, PISAliq):
        self.PISAliq = PISAliq
    def get_PISQtde(self):
        return self.PISQtde
    def set_PISQtde(self, PISQtde):
        self.PISQtde = PISQtde
    def get_PISNT(self):
        return self.PISNT
    def set_PISNT(self, PISNT):
        self.PISNT = PISNT
    def get_PISOutr(self):
        return self.PISOutr
    def set_PISOutr(self, PISOutr):
        self.PISOutr = PISOutr
    def hasContent_(self):
        if (
            self.PISAliq is not None or
            self.PISQtde is not None or
            self.PISNT is not None or
            self.PISOutr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PISType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PISType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PISType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PISType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PISType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PISAliq is not None:
            self.PISAliq.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PISAliq', pretty_print=pretty_print)
        if self.PISQtde is not None:
            self.PISQtde.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PISQtde', pretty_print=pretty_print)
        if self.PISNT is not None:
            self.PISNT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PISNT', pretty_print=pretty_print)
        if self.PISOutr is not None:
            self.PISOutr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PISOutr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PISAliq':
            obj_ = PISAliqType.factory(parent_object_=self)
            obj_.build(child_)
            self.PISAliq = obj_
            obj_.original_tagname_ = 'PISAliq'
        elif nodeName_ == 'PISQtde':
            obj_ = PISQtdeType.factory(parent_object_=self)
            obj_.build(child_)
            self.PISQtde = obj_
            obj_.original_tagname_ = 'PISQtde'
        elif nodeName_ == 'PISNT':
            obj_ = PISNTType.factory(parent_object_=self)
            obj_.build(child_)
            self.PISNT = obj_
            obj_.original_tagname_ = 'PISNT'
        elif nodeName_ == 'PISOutr':
            obj_ = PISOutrType.factory(parent_object_=self)
            obj_.build(child_)
            self.PISOutr = obj_
            obj_.original_tagname_ = 'PISOutr'
# end class PISType


class PISAliqType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CST=None, vBC=None, pPIS=None, vPIS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CST = CST
        self.validate_CSTType41(self.CST)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pPIS = pPIS
        self.validate_TDec_0302a04(self.pPIS)
        self.vPIS = vPIS
        self.validate_TDec_1302(self.vPIS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISAliqType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISAliqType.subclass:
            return PISAliqType.subclass(*args_, **kwargs_)
        else:
            return PISAliqType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pPIS(self):
        return self.pPIS
    def set_pPIS(self, pPIS):
        self.pPIS = pPIS
    def get_vPIS(self):
        return self.vPIS
    def set_vPIS(self, vPIS):
        self.vPIS = vPIS
    def validate_CSTType41(self, value):
        # Validate type CSTType41, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType41' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pPIS is not None or
            self.vPIS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PISAliqType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISAliqType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PISAliqType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PISAliqType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PISAliqType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PISAliqType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spPIS>%s</%spPIS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pPIS), input_name='pPIS')), namespaceprefix_ , eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svPIS>%s</%svPIS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vPIS), input_name='vPIS')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType41
            self.validate_CSTType41(self.CST)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pPIS':
            pPIS_ = child_.text
            pPIS_ = self.gds_validate_string(pPIS_, node, 'pPIS')
            self.pPIS = pPIS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pPIS)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPIS)
# end class PISAliqType


class PISQtdeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CST=None, qBCProd=None, vAliqProd=None, vPIS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CST = CST
        self.validate_CSTType42(self.CST)
        self.qBCProd = qBCProd
        self.validate_TDec_1204v(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104v(self.vAliqProd)
        self.vPIS = vPIS
        self.validate_TDec_1302(self.vPIS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISQtdeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISQtdeType.subclass:
            return PISQtdeType.subclass(*args_, **kwargs_)
        else:
            return PISQtdeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_qBCProd(self):
        return self.qBCProd
    def set_qBCProd(self, qBCProd):
        self.qBCProd = qBCProd
    def get_vAliqProd(self):
        return self.vAliqProd
    def set_vAliqProd(self, vAliqProd):
        self.vAliqProd = vAliqProd
    def get_vPIS(self):
        return self.vPIS
    def set_vPIS(self, vPIS):
        self.vPIS = vPIS
    def validate_CSTType42(self, value):
        # Validate type CSTType42, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['03']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType42' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [[u'^0|0\\.[0-9]{1,4}|[1-9]{1}[0-9]{0,11}|[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [[u'^0|0\\.[0-9]{1,4}|[1-9]{1}[0-9]{0,10}|[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.CST is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vPIS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PISQtdeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISQtdeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PISQtdeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PISQtdeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PISQtdeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PISQtdeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqBCProd>%s</%sqBCProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qBCProd), input_name='qBCProd')), namespaceprefix_ , eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svAliqProd>%s</%svAliqProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vAliqProd), input_name='vAliqProd')), namespaceprefix_ , eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svPIS>%s</%svPIS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vPIS), input_name='vPIS')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType42
            self.validate_CSTType42(self.CST)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.vAliqProd)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPIS)
# end class PISQtdeType


class PISNTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CST=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CST = CST
        self.validate_CSTType43(self.CST)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISNTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISNTType.subclass:
            return PISNTType.subclass(*args_, **kwargs_)
        else:
            return PISNTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def validate_CSTType43(self, value):
        # Validate type CSTType43, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['04', '05', '06', '07', '08', '09']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType43' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CST is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PISNTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISNTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PISNTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PISNTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PISNTType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PISNTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType43
            self.validate_CSTType43(self.CST)
# end class PISNTType


class PISOutrType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CST=None, vBC=None, pPIS=None, qBCProd=None, vAliqProd=None, vPIS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CST = CST
        self.validate_CSTType44(self.CST)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pPIS = pPIS
        self.validate_TDec_0302a04(self.pPIS)
        self.qBCProd = qBCProd
        self.validate_TDec_1204v(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104v(self.vAliqProd)
        self.vPIS = vPIS
        self.validate_TDec_1302(self.vPIS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISOutrType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISOutrType.subclass:
            return PISOutrType.subclass(*args_, **kwargs_)
        else:
            return PISOutrType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pPIS(self):
        return self.pPIS
    def set_pPIS(self, pPIS):
        self.pPIS = pPIS
    def get_qBCProd(self):
        return self.qBCProd
    def set_qBCProd(self, qBCProd):
        self.qBCProd = qBCProd
    def get_vAliqProd(self):
        return self.vAliqProd
    def set_vAliqProd(self, vAliqProd):
        self.vAliqProd = vAliqProd
    def get_vPIS(self):
        return self.vPIS
    def set_vPIS(self, vPIS):
        self.vPIS = vPIS
    def validate_CSTType44(self, value):
        # Validate type CSTType44, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['49', '50', '51', '52', '53', '54', '55', '56', '60', '61', '62', '63', '64', '65', '66', '67', '70', '71', '72', '73', '74', '75', '98', '99']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType44' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [[u'^0|0\\.[0-9]{1,4}|[1-9]{1}[0-9]{0,11}|[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [[u'^0|0\\.[0-9]{1,4}|[1-9]{1}[0-9]{0,10}|[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]
    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pPIS is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vPIS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PISOutrType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISOutrType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PISOutrType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PISOutrType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PISOutrType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PISOutrType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spPIS>%s</%spPIS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pPIS), input_name='pPIS')), namespaceprefix_ , eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqBCProd>%s</%sqBCProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qBCProd), input_name='qBCProd')), namespaceprefix_ , eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svAliqProd>%s</%svAliqProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vAliqProd), input_name='vAliqProd')), namespaceprefix_ , eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svPIS>%s</%svPIS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vPIS), input_name='vPIS')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType44
            self.validate_CSTType44(self.CST)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pPIS':
            pPIS_ = child_.text
            pPIS_ = self.gds_validate_string(pPIS_, node, 'pPIS')
            self.pPIS = pPIS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pPIS)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.vAliqProd)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPIS)
# end class PISOutrType


class PISSTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vBC=None, pPIS=None, qBCProd=None, vAliqProd=None, vPIS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.vBC = vBC
        self.validate_TDec_1302Opc(self.vBC)
        self.pPIS = pPIS
        self.validate_TDec_0302a04(self.pPIS)
        self.qBCProd = qBCProd
        self.validate_TDec_1204(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104(self.vAliqProd)
        self.vPIS = vPIS
        self.validate_TDec_1302(self.vPIS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PISSTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PISSTType.subclass:
            return PISSTType.subclass(*args_, **kwargs_)
        else:
            return PISSTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pPIS(self):
        return self.pPIS
    def set_pPIS(self, pPIS):
        self.pPIS = pPIS
    def get_qBCProd(self):
        return self.qBCProd
    def set_qBCProd(self, qBCProd):
        self.qBCProd = qBCProd
    def get_vAliqProd(self):
        return self.vAliqProd
    def set_vAliqProd(self, vAliqProd):
        self.vAliqProd = vAliqProd
    def get_vPIS(self):
        return self.vPIS
    def set_vPIS(self, vPIS):
        self.vPIS = vPIS
    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [[u'^0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1204(self, value):
        # Validate type TDec_1204, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204_patterns_, ))
    validate_TDec_1204_patterns_ = [[u'^0|0\\.[0-9]{1,4}|[1-9]{1}[0-9]{0,11}|[1-9]{1}[0-9]{0,11}(\\.[0-9]{4})?$']]
    def validate_TDec_1104(self, value):
        # Validate type TDec_1104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104_patterns_, ))
    validate_TDec_1104_patterns_ = [[u'^0|0\\.[0-9]{4}|[1-9]{1}[0-9]{0,10}(\\.[0-9]{4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.vBC is not None or
            self.pPIS is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vPIS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PISSTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PISSTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PISSTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PISSTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PISSTType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PISSTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spPIS>%s</%spPIS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pPIS), input_name='pPIS')), namespaceprefix_ , eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqBCProd>%s</%sqBCProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qBCProd), input_name='qBCProd')), namespaceprefix_ , eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svAliqProd>%s</%svAliqProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vAliqProd), input_name='vAliqProd')), namespaceprefix_ , eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svPIS>%s</%svPIS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vPIS), input_name='vPIS')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vBC)
        elif nodeName_ == 'pPIS':
            pPIS_ = child_.text
            pPIS_ = self.gds_validate_string(pPIS_, node, 'pPIS')
            self.pPIS = pPIS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pPIS)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204
            self.validate_TDec_1204(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104
            self.validate_TDec_1104(self.vAliqProd)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPIS)
# end class PISSTType


class COFINSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, COFINSAliq=None, COFINSQtde=None, COFINSNT=None, COFINSOutr=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.COFINSAliq = COFINSAliq
        self.COFINSQtde = COFINSQtde
        self.COFINSNT = COFINSNT
        self.COFINSOutr = COFINSOutr
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSType.subclass:
            return COFINSType.subclass(*args_, **kwargs_)
        else:
            return COFINSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_COFINSAliq(self):
        return self.COFINSAliq
    def set_COFINSAliq(self, COFINSAliq):
        self.COFINSAliq = COFINSAliq
    def get_COFINSQtde(self):
        return self.COFINSQtde
    def set_COFINSQtde(self, COFINSQtde):
        self.COFINSQtde = COFINSQtde
    def get_COFINSNT(self):
        return self.COFINSNT
    def set_COFINSNT(self, COFINSNT):
        self.COFINSNT = COFINSNT
    def get_COFINSOutr(self):
        return self.COFINSOutr
    def set_COFINSOutr(self, COFINSOutr):
        self.COFINSOutr = COFINSOutr
    def hasContent_(self):
        if (
            self.COFINSAliq is not None or
            self.COFINSQtde is not None or
            self.COFINSNT is not None or
            self.COFINSOutr is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COFINSType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COFINSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COFINSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='COFINSType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COFINSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.COFINSAliq is not None:
            self.COFINSAliq.export(outfile, level, namespaceprefix_, namespacedef_='', name_='COFINSAliq', pretty_print=pretty_print)
        if self.COFINSQtde is not None:
            self.COFINSQtde.export(outfile, level, namespaceprefix_, namespacedef_='', name_='COFINSQtde', pretty_print=pretty_print)
        if self.COFINSNT is not None:
            self.COFINSNT.export(outfile, level, namespaceprefix_, namespacedef_='', name_='COFINSNT', pretty_print=pretty_print)
        if self.COFINSOutr is not None:
            self.COFINSOutr.export(outfile, level, namespaceprefix_, namespacedef_='', name_='COFINSOutr', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'COFINSAliq':
            obj_ = COFINSAliqType.factory(parent_object_=self)
            obj_.build(child_)
            self.COFINSAliq = obj_
            obj_.original_tagname_ = 'COFINSAliq'
        elif nodeName_ == 'COFINSQtde':
            obj_ = COFINSQtdeType.factory(parent_object_=self)
            obj_.build(child_)
            self.COFINSQtde = obj_
            obj_.original_tagname_ = 'COFINSQtde'
        elif nodeName_ == 'COFINSNT':
            obj_ = COFINSNTType.factory(parent_object_=self)
            obj_.build(child_)
            self.COFINSNT = obj_
            obj_.original_tagname_ = 'COFINSNT'
        elif nodeName_ == 'COFINSOutr':
            obj_ = COFINSOutrType.factory(parent_object_=self)
            obj_.build(child_)
            self.COFINSOutr = obj_
            obj_.original_tagname_ = 'COFINSOutr'
# end class COFINSType


class COFINSAliqType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CST=None, vBC=None, pCOFINS=None, vCOFINS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CST = CST
        self.validate_CSTType45(self.CST)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pCOFINS = pCOFINS
        self.validate_TDec_0302a04(self.pCOFINS)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302(self.vCOFINS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSAliqType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSAliqType.subclass:
            return COFINSAliqType.subclass(*args_, **kwargs_)
        else:
            return COFINSAliqType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pCOFINS(self):
        return self.pCOFINS
    def set_pCOFINS(self, pCOFINS):
        self.pCOFINS = pCOFINS
    def get_vCOFINS(self):
        return self.vCOFINS
    def set_vCOFINS(self, vCOFINS):
        self.vCOFINS = vCOFINS
    def validate_CSTType45(self, value):
        # Validate type CSTType45, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType45' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pCOFINS is not None or
            self.vCOFINS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COFINSAliqType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSAliqType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COFINSAliqType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COFINSAliqType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='COFINSAliqType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COFINSAliqType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spCOFINS>%s</%spCOFINS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pCOFINS), input_name='pCOFINS')), namespaceprefix_ , eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCOFINS>%s</%svCOFINS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCOFINS), input_name='vCOFINS')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType45
            self.validate_CSTType45(self.CST)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pCOFINS':
            pCOFINS_ = child_.text
            pCOFINS_ = self.gds_validate_string(pCOFINS_, node, 'pCOFINS')
            self.pCOFINS = pCOFINS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCOFINS)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCOFINS)
# end class COFINSAliqType


class COFINSQtdeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CST=None, qBCProd=None, vAliqProd=None, vCOFINS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CST = CST
        self.validate_CSTType46(self.CST)
        self.qBCProd = qBCProd
        self.validate_TDec_1204v(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104v(self.vAliqProd)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302(self.vCOFINS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSQtdeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSQtdeType.subclass:
            return COFINSQtdeType.subclass(*args_, **kwargs_)
        else:
            return COFINSQtdeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_qBCProd(self):
        return self.qBCProd
    def set_qBCProd(self, qBCProd):
        self.qBCProd = qBCProd
    def get_vAliqProd(self):
        return self.vAliqProd
    def set_vAliqProd(self, vAliqProd):
        self.vAliqProd = vAliqProd
    def get_vCOFINS(self):
        return self.vCOFINS
    def set_vCOFINS(self, vCOFINS):
        self.vCOFINS = vCOFINS
    def validate_CSTType46(self, value):
        # Validate type CSTType46, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['03']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType46' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [[u'^0|0\\.[0-9]{1,4}|[1-9]{1}[0-9]{0,11}|[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [[u'^0|0\\.[0-9]{1,4}|[1-9]{1}[0-9]{0,10}|[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.CST is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vCOFINS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COFINSQtdeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSQtdeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COFINSQtdeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COFINSQtdeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='COFINSQtdeType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COFINSQtdeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqBCProd>%s</%sqBCProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qBCProd), input_name='qBCProd')), namespaceprefix_ , eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svAliqProd>%s</%svAliqProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vAliqProd), input_name='vAliqProd')), namespaceprefix_ , eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCOFINS>%s</%svCOFINS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCOFINS), input_name='vCOFINS')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType46
            self.validate_CSTType46(self.CST)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.vAliqProd)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCOFINS)
# end class COFINSQtdeType


class COFINSNTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CST=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CST = CST
        self.validate_CSTType47(self.CST)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSNTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSNTType.subclass:
            return COFINSNTType.subclass(*args_, **kwargs_)
        else:
            return COFINSNTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def validate_CSTType47(self, value):
        # Validate type CSTType47, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['04', '05', '06', '07', '08', '09']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType47' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CST is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COFINSNTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSNTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COFINSNTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COFINSNTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='COFINSNTType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COFINSNTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType47
            self.validate_CSTType47(self.CST)
# end class COFINSNTType


class COFINSOutrType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CST=None, vBC=None, pCOFINS=None, qBCProd=None, vAliqProd=None, vCOFINS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CST = CST
        self.validate_CSTType48(self.CST)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pCOFINS = pCOFINS
        self.validate_TDec_0302a04(self.pCOFINS)
        self.qBCProd = qBCProd
        self.validate_TDec_1204v(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104v(self.vAliqProd)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302(self.vCOFINS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSOutrType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSOutrType.subclass:
            return COFINSOutrType.subclass(*args_, **kwargs_)
        else:
            return COFINSOutrType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pCOFINS(self):
        return self.pCOFINS
    def set_pCOFINS(self, pCOFINS):
        self.pCOFINS = pCOFINS
    def get_qBCProd(self):
        return self.qBCProd
    def set_qBCProd(self, qBCProd):
        self.qBCProd = qBCProd
    def get_vAliqProd(self):
        return self.vAliqProd
    def set_vAliqProd(self, vAliqProd):
        self.vAliqProd = vAliqProd
    def get_vCOFINS(self):
        return self.vCOFINS
    def set_vCOFINS(self, vCOFINS):
        self.vCOFINS = vCOFINS
    def validate_CSTType48(self, value):
        # Validate type CSTType48, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['49', '50', '51', '52', '53', '54', '55', '56', '60', '61', '62', '63', '64', '65', '66', '67', '70', '71', '72', '73', '74', '75', '98', '99']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType48' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [[u'^0|0\\.[0-9]{1,4}|[1-9]{1}[0-9]{0,11}|[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1104v(self, value):
        # Validate type TDec_1104v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104v_patterns_, ))
    validate_TDec_1104v_patterns_ = [[u'^0|0\\.[0-9]{1,4}|[1-9]{1}[0-9]{0,10}|[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,4})?$']]
    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pCOFINS is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vCOFINS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COFINSOutrType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSOutrType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COFINSOutrType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COFINSOutrType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='COFINSOutrType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COFINSOutrType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spCOFINS>%s</%spCOFINS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pCOFINS), input_name='pCOFINS')), namespaceprefix_ , eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqBCProd>%s</%sqBCProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qBCProd), input_name='qBCProd')), namespaceprefix_ , eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svAliqProd>%s</%svAliqProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vAliqProd), input_name='vAliqProd')), namespaceprefix_ , eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCOFINS>%s</%svCOFINS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCOFINS), input_name='vCOFINS')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType48
            self.validate_CSTType48(self.CST)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pCOFINS':
            pCOFINS_ = child_.text
            pCOFINS_ = self.gds_validate_string(pCOFINS_, node, 'pCOFINS')
            self.pCOFINS = pCOFINS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCOFINS)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104v
            self.validate_TDec_1104v(self.vAliqProd)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCOFINS)
# end class COFINSOutrType


class COFINSSTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vBC=None, pCOFINS=None, qBCProd=None, vAliqProd=None, vCOFINS=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pCOFINS = pCOFINS
        self.validate_TDec_0302a04(self.pCOFINS)
        self.qBCProd = qBCProd
        self.validate_TDec_1204(self.qBCProd)
        self.vAliqProd = vAliqProd
        self.validate_TDec_1104(self.vAliqProd)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302(self.vCOFINS)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, COFINSSTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if COFINSSTType.subclass:
            return COFINSSTType.subclass(*args_, **kwargs_)
        else:
            return COFINSSTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pCOFINS(self):
        return self.pCOFINS
    def set_pCOFINS(self, pCOFINS):
        self.pCOFINS = pCOFINS
    def get_qBCProd(self):
        return self.qBCProd
    def set_qBCProd(self, qBCProd):
        self.qBCProd = qBCProd
    def get_vAliqProd(self):
        return self.vAliqProd
    def set_vAliqProd(self, vAliqProd):
        self.vAliqProd = vAliqProd
    def get_vCOFINS(self):
        return self.vCOFINS
    def set_vCOFINS(self, vCOFINS):
        self.vCOFINS = vCOFINS
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1204(self, value):
        # Validate type TDec_1204, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204_patterns_, ))
    validate_TDec_1204_patterns_ = [[u'^0|0\\.[0-9]{1,4}|[1-9]{1}[0-9]{0,11}|[1-9]{1}[0-9]{0,11}(\\.[0-9]{4})?$']]
    def validate_TDec_1104(self, value):
        # Validate type TDec_1104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104_patterns_, ))
    validate_TDec_1104_patterns_ = [[u'^0|0\\.[0-9]{4}|[1-9]{1}[0-9]{0,10}(\\.[0-9]{4})?$']]
    def hasContent_(self):
        if (
            self.vBC is not None or
            self.pCOFINS is not None or
            self.qBCProd is not None or
            self.vAliqProd is not None or
            self.vCOFINS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COFINSSTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('COFINSSTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='COFINSSTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='COFINSSTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='COFINSSTType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='COFINSSTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spCOFINS>%s</%spCOFINS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pCOFINS), input_name='pCOFINS')), namespaceprefix_ , eol_))
        if self.qBCProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqBCProd>%s</%sqBCProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qBCProd), input_name='qBCProd')), namespaceprefix_ , eol_))
        if self.vAliqProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svAliqProd>%s</%svAliqProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vAliqProd), input_name='vAliqProd')), namespaceprefix_ , eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCOFINS>%s</%svCOFINS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCOFINS), input_name='vCOFINS')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pCOFINS':
            pCOFINS_ = child_.text
            pCOFINS_ = self.gds_validate_string(pCOFINS_, node, 'pCOFINS')
            self.pCOFINS = pCOFINS_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pCOFINS)
        elif nodeName_ == 'qBCProd':
            qBCProd_ = child_.text
            qBCProd_ = self.gds_validate_string(qBCProd_, node, 'qBCProd')
            self.qBCProd = qBCProd_
            # validate type TDec_1204
            self.validate_TDec_1204(self.qBCProd)
        elif nodeName_ == 'vAliqProd':
            vAliqProd_ = child_.text
            vAliqProd_ = self.gds_validate_string(vAliqProd_, node, 'vAliqProd')
            self.vAliqProd = vAliqProd_
            # validate type TDec_1104
            self.validate_TDec_1104(self.vAliqProd)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCOFINS)
# end class COFINSSTType


class ICMSUFDestType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vBCUFDest=None, vBCFCPUFDest=None, pFCPUFDest=None, pICMSUFDest=None, pICMSInter=None, pICMSInterPart=None, vFCPUFDest=None, vICMSUFDest=None, vICMSUFRemet=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.vBCUFDest = vBCUFDest
        self.validate_TDec_1302(self.vBCUFDest)
        self.vBCFCPUFDest = vBCFCPUFDest
        self.validate_TDec_1302(self.vBCFCPUFDest)
        self.pFCPUFDest = pFCPUFDest
        self.validate_TDec_0302a04(self.pFCPUFDest)
        self.pICMSUFDest = pICMSUFDest
        self.validate_TDec_0302a04(self.pICMSUFDest)
        self.pICMSInter = pICMSInter
        self.validate_pICMSInterType(self.pICMSInter)
        self.pICMSInterPart = pICMSInterPart
        self.validate_TDec_0302a04(self.pICMSInterPart)
        self.vFCPUFDest = vFCPUFDest
        self.validate_TDec_1302(self.vFCPUFDest)
        self.vICMSUFDest = vICMSUFDest
        self.validate_TDec_1302(self.vICMSUFDest)
        self.vICMSUFRemet = vICMSUFRemet
        self.validate_TDec_1302(self.vICMSUFRemet)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSUFDestType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSUFDestType.subclass:
            return ICMSUFDestType.subclass(*args_, **kwargs_)
        else:
            return ICMSUFDestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vBCUFDest(self):
        return self.vBCUFDest
    def set_vBCUFDest(self, vBCUFDest):
        self.vBCUFDest = vBCUFDest
    def get_vBCFCPUFDest(self):
        return self.vBCFCPUFDest
    def set_vBCFCPUFDest(self, vBCFCPUFDest):
        self.vBCFCPUFDest = vBCFCPUFDest
    def get_pFCPUFDest(self):
        return self.pFCPUFDest
    def set_pFCPUFDest(self, pFCPUFDest):
        self.pFCPUFDest = pFCPUFDest
    def get_pICMSUFDest(self):
        return self.pICMSUFDest
    def set_pICMSUFDest(self, pICMSUFDest):
        self.pICMSUFDest = pICMSUFDest
    def get_pICMSInter(self):
        return self.pICMSInter
    def set_pICMSInter(self, pICMSInter):
        self.pICMSInter = pICMSInter
    def get_pICMSInterPart(self):
        return self.pICMSInterPart
    def set_pICMSInterPart(self, pICMSInterPart):
        self.pICMSInterPart = pICMSInterPart
    def get_vFCPUFDest(self):
        return self.vFCPUFDest
    def set_vFCPUFDest(self, vFCPUFDest):
        self.vFCPUFDest = vFCPUFDest
    def get_vICMSUFDest(self):
        return self.vICMSUFDest
    def set_vICMSUFDest(self, vICMSUFDest):
        self.vICMSUFDest = vICMSUFDest
    def get_vICMSUFRemet(self):
        return self.vICMSUFRemet
    def set_vICMSUFRemet(self, vICMSUFRemet):
        self.vICMSUFRemet = vICMSUFRemet
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_pICMSInterType(self, value):
        # Validate type pICMSInterType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['4.00', '7.00', '12.00']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on pICMSInterType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.vBCUFDest is not None or
            self.vBCFCPUFDest is not None or
            self.pFCPUFDest is not None or
            self.pICMSUFDest is not None or
            self.pICMSInter is not None or
            self.pICMSInterPart is not None or
            self.vFCPUFDest is not None or
            self.vICMSUFDest is not None or
            self.vICMSUFRemet is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSUFDestType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSUFDestType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSUFDestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSUFDestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSUFDestType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSUFDestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBCUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCUFDest>%s</%svBCUFDest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCUFDest), input_name='vBCUFDest')), namespaceprefix_ , eol_))
        if self.vBCFCPUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCFCPUFDest>%s</%svBCFCPUFDest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCFCPUFDest), input_name='vBCFCPUFDest')), namespaceprefix_ , eol_))
        if self.pFCPUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spFCPUFDest>%s</%spFCPUFDest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pFCPUFDest), input_name='pFCPUFDest')), namespaceprefix_ , eol_))
        if self.pICMSUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSUFDest>%s</%spICMSUFDest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSUFDest), input_name='pICMSUFDest')), namespaceprefix_ , eol_))
        if self.pICMSInter is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSInter>%s</%spICMSInter>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSInter), input_name='pICMSInter')), namespaceprefix_ , eol_))
        if self.pICMSInterPart is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSInterPart>%s</%spICMSInterPart>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSInterPart), input_name='pICMSInterPart')), namespaceprefix_ , eol_))
        if self.vFCPUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCPUFDest>%s</%svFCPUFDest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCPUFDest), input_name='vFCPUFDest')), namespaceprefix_ , eol_))
        if self.vICMSUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSUFDest>%s</%svICMSUFDest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSUFDest), input_name='vICMSUFDest')), namespaceprefix_ , eol_))
        if self.vICMSUFRemet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSUFRemet>%s</%svICMSUFRemet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSUFRemet), input_name='vICMSUFRemet')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBCUFDest':
            vBCUFDest_ = child_.text
            vBCUFDest_ = self.gds_validate_string(vBCUFDest_, node, 'vBCUFDest')
            self.vBCUFDest = vBCUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCUFDest)
        elif nodeName_ == 'vBCFCPUFDest':
            vBCFCPUFDest_ = child_.text
            vBCFCPUFDest_ = self.gds_validate_string(vBCFCPUFDest_, node, 'vBCFCPUFDest')
            self.vBCFCPUFDest = vBCFCPUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCFCPUFDest)
        elif nodeName_ == 'pFCPUFDest':
            pFCPUFDest_ = child_.text
            pFCPUFDest_ = self.gds_validate_string(pFCPUFDest_, node, 'pFCPUFDest')
            self.pFCPUFDest = pFCPUFDest_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pFCPUFDest)
        elif nodeName_ == 'pICMSUFDest':
            pICMSUFDest_ = child_.text
            pICMSUFDest_ = self.gds_validate_string(pICMSUFDest_, node, 'pICMSUFDest')
            self.pICMSUFDest = pICMSUFDest_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSUFDest)
        elif nodeName_ == 'pICMSInter':
            pICMSInter_ = child_.text
            pICMSInter_ = self.gds_validate_string(pICMSInter_, node, 'pICMSInter')
            self.pICMSInter = pICMSInter_
            # validate type pICMSInterType
            self.validate_pICMSInterType(self.pICMSInter)
        elif nodeName_ == 'pICMSInterPart':
            pICMSInterPart_ = child_.text
            pICMSInterPart_ = self.gds_validate_string(pICMSInterPart_, node, 'pICMSInterPart')
            self.pICMSInterPart = pICMSInterPart_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSInterPart)
        elif nodeName_ == 'vFCPUFDest':
            vFCPUFDest_ = child_.text
            vFCPUFDest_ = self.gds_validate_string(vFCPUFDest_, node, 'vFCPUFDest')
            self.vFCPUFDest = vFCPUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPUFDest)
        elif nodeName_ == 'vICMSUFDest':
            vICMSUFDest_ = child_.text
            vICMSUFDest_ = self.gds_validate_string(vICMSUFDest_, node, 'vICMSUFDest')
            self.vICMSUFDest = vICMSUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSUFDest)
        elif nodeName_ == 'vICMSUFRemet':
            vICMSUFRemet_ = child_.text
            vICMSUFRemet_ = self.gds_validate_string(vICMSUFRemet_, node, 'vICMSUFRemet')
            self.vICMSUFRemet = vICMSUFRemet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSUFRemet)
# end class ICMSUFDestType


class impostoDevolType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, pDevol=None, IPI=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.pDevol = pDevol
        self.validate_TDec_0302Max100(self.pDevol)
        self.IPI = IPI
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, impostoDevolType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if impostoDevolType.subclass:
            return impostoDevolType.subclass(*args_, **kwargs_)
        else:
            return impostoDevolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_pDevol(self):
        return self.pDevol
    def set_pDevol(self, pDevol):
        self.pDevol = pDevol
    def get_IPI(self):
        return self.IPI
    def set_IPI(self, IPI):
        self.IPI = IPI
    def validate_TDec_0302Max100(self, value):
        # Validate type TDec_0302Max100, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302Max100_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302Max100_patterns_, ))
    validate_TDec_0302Max100_patterns_ = [[u'^0(\\.[0-9]{2})?|100(\\.00)?|[1-9]{1}[0-9]{0,1}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.pDevol is not None or
            self.IPI is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='impostoDevolType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('impostoDevolType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='impostoDevolType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='impostoDevolType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='impostoDevolType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='impostoDevolType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.pDevol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spDevol>%s</%spDevol>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pDevol), input_name='pDevol')), namespaceprefix_ , eol_))
        if self.IPI is not None:
            self.IPI.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IPI', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'pDevol':
            pDevol_ = child_.text
            pDevol_ = self.gds_validate_string(pDevol_, node, 'pDevol')
            self.pDevol = pDevol_
            # validate type TDec_0302Max100
            self.validate_TDec_0302Max100(self.pDevol)
        elif nodeName_ == 'IPI':
            obj_ = IPIType.factory(parent_object_=self)
            obj_.build(child_)
            self.IPI = obj_
            obj_.original_tagname_ = 'IPI'
# end class impostoDevolType


class IPIType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vIPIDevol=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.vIPIDevol = vIPIDevol
        self.validate_TDec_1302(self.vIPIDevol)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPIType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPIType.subclass:
            return IPIType.subclass(*args_, **kwargs_)
        else:
            return IPIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vIPIDevol(self):
        return self.vIPIDevol
    def set_vIPIDevol(self, vIPIDevol):
        self.vIPIDevol = vIPIDevol
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.vIPIDevol is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IPIType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IPIType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IPIType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IPIType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IPIType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IPIType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vIPIDevol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svIPIDevol>%s</%svIPIDevol>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vIPIDevol), input_name='vIPIDevol')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vIPIDevol':
            vIPIDevol_ = child_.text
            vIPIDevol_ = self.gds_validate_string(vIPIDevol_, node, 'vIPIDevol')
            self.vIPIDevol = vIPIDevol_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vIPIDevol)
# end class IPIType


class totalType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ICMSTot=None, ISSQNtot=None, retTrib=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ICMSTot = ICMSTot
        self.ISSQNtot = ISSQNtot
        self.retTrib = retTrib
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, totalType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if totalType.subclass:
            return totalType.subclass(*args_, **kwargs_)
        else:
            return totalType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ICMSTot(self):
        return self.ICMSTot
    def set_ICMSTot(self, ICMSTot):
        self.ICMSTot = ICMSTot
    def get_ISSQNtot(self):
        return self.ISSQNtot
    def set_ISSQNtot(self, ISSQNtot):
        self.ISSQNtot = ISSQNtot
    def get_retTrib(self):
        return self.retTrib
    def set_retTrib(self, retTrib):
        self.retTrib = retTrib
    def hasContent_(self):
        if (
            self.ICMSTot is not None or
            self.ISSQNtot is not None or
            self.retTrib is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='totalType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('totalType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='totalType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='totalType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='totalType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='totalType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ICMSTot is not None:
            self.ICMSTot.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ICMSTot', pretty_print=pretty_print)
        if self.ISSQNtot is not None:
            self.ISSQNtot.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ISSQNtot', pretty_print=pretty_print)
        if self.retTrib is not None:
            self.retTrib.export(outfile, level, namespaceprefix_, namespacedef_='', name_='retTrib', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ICMSTot':
            obj_ = ICMSTotType.factory(parent_object_=self)
            obj_.build(child_)
            self.ICMSTot = obj_
            obj_.original_tagname_ = 'ICMSTot'
        elif nodeName_ == 'ISSQNtot':
            obj_ = ISSQNtotType.factory(parent_object_=self)
            obj_.build(child_)
            self.ISSQNtot = obj_
            obj_.original_tagname_ = 'ISSQNtot'
        elif nodeName_ == 'retTrib':
            obj_ = retTribType.factory(parent_object_=self)
            obj_.build(child_)
            self.retTrib = obj_
            obj_.original_tagname_ = 'retTrib'
# end class totalType


class ICMSTotType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vBC=None, vICMS=None, vICMSDeson=None, vFCPUFDest=None, vICMSUFDest=None, vICMSUFRemet=None, vFCP=None, vBCST=None, vST=None, vFCPST=None, vFCPSTRet=None, vProd=None, vFrete=None, vSeg=None, vDesc=None, vII=None, vIPI=None, vIPIDevol=None, vPIS=None, vCOFINS=None, vOutro=None, vNF=None, vTotTrib=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.vICMS = vICMS
        self.validate_TDec_1302(self.vICMS)
        self.vICMSDeson = vICMSDeson
        self.validate_TDec_1302(self.vICMSDeson)
        self.vFCPUFDest = vFCPUFDest
        self.validate_TDec_1302(self.vFCPUFDest)
        self.vICMSUFDest = vICMSUFDest
        self.validate_TDec_1302(self.vICMSUFDest)
        self.vICMSUFRemet = vICMSUFRemet
        self.validate_TDec_1302(self.vICMSUFRemet)
        self.vFCP = vFCP
        self.validate_TDec_1302(self.vFCP)
        self.vBCST = vBCST
        self.validate_TDec_1302(self.vBCST)
        self.vST = vST
        self.validate_TDec_1302(self.vST)
        self.vFCPST = vFCPST
        self.validate_TDec_1302(self.vFCPST)
        self.vFCPSTRet = vFCPSTRet
        self.validate_TDec_1302(self.vFCPSTRet)
        self.vProd = vProd
        self.validate_TDec_1302(self.vProd)
        self.vFrete = vFrete
        self.validate_TDec_1302(self.vFrete)
        self.vSeg = vSeg
        self.validate_TDec_1302(self.vSeg)
        self.vDesc = vDesc
        self.validate_TDec_1302(self.vDesc)
        self.vII = vII
        self.validate_TDec_1302(self.vII)
        self.vIPI = vIPI
        self.validate_TDec_1302(self.vIPI)
        self.vIPIDevol = vIPIDevol
        self.validate_TDec_1302(self.vIPIDevol)
        self.vPIS = vPIS
        self.validate_TDec_1302(self.vPIS)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302(self.vCOFINS)
        self.vOutro = vOutro
        self.validate_TDec_1302(self.vOutro)
        self.vNF = vNF
        self.validate_TDec_1302(self.vNF)
        self.vTotTrib = vTotTrib
        self.validate_TDec_1302(self.vTotTrib)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ICMSTotType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ICMSTotType.subclass:
            return ICMSTotType.subclass(*args_, **kwargs_)
        else:
            return ICMSTotType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_vICMS(self):
        return self.vICMS
    def set_vICMS(self, vICMS):
        self.vICMS = vICMS
    def get_vICMSDeson(self):
        return self.vICMSDeson
    def set_vICMSDeson(self, vICMSDeson):
        self.vICMSDeson = vICMSDeson
    def get_vFCPUFDest(self):
        return self.vFCPUFDest
    def set_vFCPUFDest(self, vFCPUFDest):
        self.vFCPUFDest = vFCPUFDest
    def get_vICMSUFDest(self):
        return self.vICMSUFDest
    def set_vICMSUFDest(self, vICMSUFDest):
        self.vICMSUFDest = vICMSUFDest
    def get_vICMSUFRemet(self):
        return self.vICMSUFRemet
    def set_vICMSUFRemet(self, vICMSUFRemet):
        self.vICMSUFRemet = vICMSUFRemet
    def get_vFCP(self):
        return self.vFCP
    def set_vFCP(self, vFCP):
        self.vFCP = vFCP
    def get_vBCST(self):
        return self.vBCST
    def set_vBCST(self, vBCST):
        self.vBCST = vBCST
    def get_vST(self):
        return self.vST
    def set_vST(self, vST):
        self.vST = vST
    def get_vFCPST(self):
        return self.vFCPST
    def set_vFCPST(self, vFCPST):
        self.vFCPST = vFCPST
    def get_vFCPSTRet(self):
        return self.vFCPSTRet
    def set_vFCPSTRet(self, vFCPSTRet):
        self.vFCPSTRet = vFCPSTRet
    def get_vProd(self):
        return self.vProd
    def set_vProd(self, vProd):
        self.vProd = vProd
    def get_vFrete(self):
        return self.vFrete
    def set_vFrete(self, vFrete):
        self.vFrete = vFrete
    def get_vSeg(self):
        return self.vSeg
    def set_vSeg(self, vSeg):
        self.vSeg = vSeg
    def get_vDesc(self):
        return self.vDesc
    def set_vDesc(self, vDesc):
        self.vDesc = vDesc
    def get_vII(self):
        return self.vII
    def set_vII(self, vII):
        self.vII = vII
    def get_vIPI(self):
        return self.vIPI
    def set_vIPI(self, vIPI):
        self.vIPI = vIPI
    def get_vIPIDevol(self):
        return self.vIPIDevol
    def set_vIPIDevol(self, vIPIDevol):
        self.vIPIDevol = vIPIDevol
    def get_vPIS(self):
        return self.vPIS
    def set_vPIS(self, vPIS):
        self.vPIS = vPIS
    def get_vCOFINS(self):
        return self.vCOFINS
    def set_vCOFINS(self, vCOFINS):
        self.vCOFINS = vCOFINS
    def get_vOutro(self):
        return self.vOutro
    def set_vOutro(self, vOutro):
        self.vOutro = vOutro
    def get_vNF(self):
        return self.vNF
    def set_vNF(self, vNF):
        self.vNF = vNF
    def get_vTotTrib(self):
        return self.vTotTrib
    def set_vTotTrib(self, vTotTrib):
        self.vTotTrib = vTotTrib
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.vBC is not None or
            self.vICMS is not None or
            self.vICMSDeson is not None or
            self.vFCPUFDest is not None or
            self.vICMSUFDest is not None or
            self.vICMSUFRemet is not None or
            self.vFCP is not None or
            self.vBCST is not None or
            self.vST is not None or
            self.vFCPST is not None or
            self.vFCPSTRet is not None or
            self.vProd is not None or
            self.vFrete is not None or
            self.vSeg is not None or
            self.vDesc is not None or
            self.vII is not None or
            self.vIPI is not None or
            self.vIPIDevol is not None or
            self.vPIS is not None or
            self.vCOFINS is not None or
            self.vOutro is not None or
            self.vNF is not None or
            self.vTotTrib is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSTotType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ICMSTotType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ICMSTotType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ICMSTotType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ICMSTotType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ICMSTotType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.vICMS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMS>%s</%svICMS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMS), input_name='vICMS')), namespaceprefix_ , eol_))
        if self.vICMSDeson is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSDeson>%s</%svICMSDeson>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSDeson), input_name='vICMSDeson')), namespaceprefix_ , eol_))
        if self.vFCPUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCPUFDest>%s</%svFCPUFDest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCPUFDest), input_name='vFCPUFDest')), namespaceprefix_ , eol_))
        if self.vICMSUFDest is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSUFDest>%s</%svICMSUFDest>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSUFDest), input_name='vICMSUFDest')), namespaceprefix_ , eol_))
        if self.vICMSUFRemet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSUFRemet>%s</%svICMSUFRemet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSUFRemet), input_name='vICMSUFRemet')), namespaceprefix_ , eol_))
        if self.vFCP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCP>%s</%svFCP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCP), input_name='vFCP')), namespaceprefix_ , eol_))
        if self.vBCST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCST>%s</%svBCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCST), input_name='vBCST')), namespaceprefix_ , eol_))
        if self.vST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svST>%s</%svST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vST), input_name='vST')), namespaceprefix_ , eol_))
        if self.vFCPST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCPST>%s</%svFCPST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCPST), input_name='vFCPST')), namespaceprefix_ , eol_))
        if self.vFCPSTRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFCPSTRet>%s</%svFCPSTRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFCPSTRet), input_name='vFCPSTRet')), namespaceprefix_ , eol_))
        if self.vProd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svProd>%s</%svProd>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vProd), input_name='vProd')), namespaceprefix_ , eol_))
        if self.vFrete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFrete>%s</%svFrete>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFrete), input_name='vFrete')), namespaceprefix_ , eol_))
        if self.vSeg is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svSeg>%s</%svSeg>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vSeg), input_name='vSeg')), namespaceprefix_ , eol_))
        if self.vDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDesc>%s</%svDesc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDesc), input_name='vDesc')), namespaceprefix_ , eol_))
        if self.vII is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svII>%s</%svII>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vII), input_name='vII')), namespaceprefix_ , eol_))
        if self.vIPI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svIPI>%s</%svIPI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vIPI), input_name='vIPI')), namespaceprefix_ , eol_))
        if self.vIPIDevol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svIPIDevol>%s</%svIPIDevol>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vIPIDevol), input_name='vIPIDevol')), namespaceprefix_ , eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svPIS>%s</%svPIS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vPIS), input_name='vPIS')), namespaceprefix_ , eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCOFINS>%s</%svCOFINS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCOFINS), input_name='vCOFINS')), namespaceprefix_ , eol_))
        if self.vOutro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svOutro>%s</%svOutro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vOutro), input_name='vOutro')), namespaceprefix_ , eol_))
        if self.vNF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svNF>%s</%svNF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vNF), input_name='vNF')), namespaceprefix_ , eol_))
        if self.vTotTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svTotTrib>%s</%svTotTrib>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vTotTrib), input_name='vTotTrib')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'vICMS':
            vICMS_ = child_.text
            vICMS_ = self.gds_validate_string(vICMS_, node, 'vICMS')
            self.vICMS = vICMS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMS)
        elif nodeName_ == 'vICMSDeson':
            vICMSDeson_ = child_.text
            vICMSDeson_ = self.gds_validate_string(vICMSDeson_, node, 'vICMSDeson')
            self.vICMSDeson = vICMSDeson_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSDeson)
        elif nodeName_ == 'vFCPUFDest':
            vFCPUFDest_ = child_.text
            vFCPUFDest_ = self.gds_validate_string(vFCPUFDest_, node, 'vFCPUFDest')
            self.vFCPUFDest = vFCPUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPUFDest)
        elif nodeName_ == 'vICMSUFDest':
            vICMSUFDest_ = child_.text
            vICMSUFDest_ = self.gds_validate_string(vICMSUFDest_, node, 'vICMSUFDest')
            self.vICMSUFDest = vICMSUFDest_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSUFDest)
        elif nodeName_ == 'vICMSUFRemet':
            vICMSUFRemet_ = child_.text
            vICMSUFRemet_ = self.gds_validate_string(vICMSUFRemet_, node, 'vICMSUFRemet')
            self.vICMSUFRemet = vICMSUFRemet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSUFRemet)
        elif nodeName_ == 'vFCP':
            vFCP_ = child_.text
            vFCP_ = self.gds_validate_string(vFCP_, node, 'vFCP')
            self.vFCP = vFCP_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCP)
        elif nodeName_ == 'vBCST':
            vBCST_ = child_.text
            vBCST_ = self.gds_validate_string(vBCST_, node, 'vBCST')
            self.vBCST = vBCST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCST)
        elif nodeName_ == 'vST':
            vST_ = child_.text
            vST_ = self.gds_validate_string(vST_, node, 'vST')
            self.vST = vST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vST)
        elif nodeName_ == 'vFCPST':
            vFCPST_ = child_.text
            vFCPST_ = self.gds_validate_string(vFCPST_, node, 'vFCPST')
            self.vFCPST = vFCPST_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPST)
        elif nodeName_ == 'vFCPSTRet':
            vFCPSTRet_ = child_.text
            vFCPSTRet_ = self.gds_validate_string(vFCPSTRet_, node, 'vFCPSTRet')
            self.vFCPSTRet = vFCPSTRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFCPSTRet)
        elif nodeName_ == 'vProd':
            vProd_ = child_.text
            vProd_ = self.gds_validate_string(vProd_, node, 'vProd')
            self.vProd = vProd_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vProd)
        elif nodeName_ == 'vFrete':
            vFrete_ = child_.text
            vFrete_ = self.gds_validate_string(vFrete_, node, 'vFrete')
            self.vFrete = vFrete_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFrete)
        elif nodeName_ == 'vSeg':
            vSeg_ = child_.text
            vSeg_ = self.gds_validate_string(vSeg_, node, 'vSeg')
            self.vSeg = vSeg_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vSeg)
        elif nodeName_ == 'vDesc':
            vDesc_ = child_.text
            vDesc_ = self.gds_validate_string(vDesc_, node, 'vDesc')
            self.vDesc = vDesc_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vDesc)
        elif nodeName_ == 'vII':
            vII_ = child_.text
            vII_ = self.gds_validate_string(vII_, node, 'vII')
            self.vII = vII_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vII)
        elif nodeName_ == 'vIPI':
            vIPI_ = child_.text
            vIPI_ = self.gds_validate_string(vIPI_, node, 'vIPI')
            self.vIPI = vIPI_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vIPI)
        elif nodeName_ == 'vIPIDevol':
            vIPIDevol_ = child_.text
            vIPIDevol_ = self.gds_validate_string(vIPIDevol_, node, 'vIPIDevol')
            self.vIPIDevol = vIPIDevol_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vIPIDevol)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPIS)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vCOFINS)
        elif nodeName_ == 'vOutro':
            vOutro_ = child_.text
            vOutro_ = self.gds_validate_string(vOutro_, node, 'vOutro')
            self.vOutro = vOutro_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vOutro)
        elif nodeName_ == 'vNF':
            vNF_ = child_.text
            vNF_ = self.gds_validate_string(vNF_, node, 'vNF')
            self.vNF = vNF_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vNF)
        elif nodeName_ == 'vTotTrib':
            vTotTrib_ = child_.text
            vTotTrib_ = self.gds_validate_string(vTotTrib_, node, 'vTotTrib')
            self.vTotTrib = vTotTrib_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vTotTrib)
# end class ICMSTotType


class ISSQNtotType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vServ=None, vBC=None, vISS=None, vPIS=None, vCOFINS=None, dCompet=None, vDeducao=None, vOutro=None, vDescIncond=None, vDescCond=None, vISSRet=None, cRegTrib=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.vServ = vServ
        self.validate_TDec_1302Opc(self.vServ)
        self.vBC = vBC
        self.validate_TDec_1302Opc(self.vBC)
        self.vISS = vISS
        self.validate_TDec_1302Opc(self.vISS)
        self.vPIS = vPIS
        self.validate_TDec_1302Opc(self.vPIS)
        self.vCOFINS = vCOFINS
        self.validate_TDec_1302Opc(self.vCOFINS)
        self.dCompet = dCompet
        self.validate_TData(self.dCompet)
        self.vDeducao = vDeducao
        self.validate_TDec_1302Opc(self.vDeducao)
        self.vOutro = vOutro
        self.validate_TDec_1302Opc(self.vOutro)
        self.vDescIncond = vDescIncond
        self.validate_TDec_1302Opc(self.vDescIncond)
        self.vDescCond = vDescCond
        self.validate_TDec_1302Opc(self.vDescCond)
        self.vISSRet = vISSRet
        self.validate_TDec_1302Opc(self.vISSRet)
        self.cRegTrib = cRegTrib
        self.validate_cRegTribType(self.cRegTrib)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ISSQNtotType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ISSQNtotType.subclass:
            return ISSQNtotType.subclass(*args_, **kwargs_)
        else:
            return ISSQNtotType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vServ(self):
        return self.vServ
    def set_vServ(self, vServ):
        self.vServ = vServ
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_vISS(self):
        return self.vISS
    def set_vISS(self, vISS):
        self.vISS = vISS
    def get_vPIS(self):
        return self.vPIS
    def set_vPIS(self, vPIS):
        self.vPIS = vPIS
    def get_vCOFINS(self):
        return self.vCOFINS
    def set_vCOFINS(self, vCOFINS):
        self.vCOFINS = vCOFINS
    def get_dCompet(self):
        return self.dCompet
    def set_dCompet(self, dCompet):
        self.dCompet = dCompet
    def get_vDeducao(self):
        return self.vDeducao
    def set_vDeducao(self, vDeducao):
        self.vDeducao = vDeducao
    def get_vOutro(self):
        return self.vOutro
    def set_vOutro(self, vOutro):
        self.vOutro = vOutro
    def get_vDescIncond(self):
        return self.vDescIncond
    def set_vDescIncond(self, vDescIncond):
        self.vDescIncond = vDescIncond
    def get_vDescCond(self):
        return self.vDescCond
    def set_vDescCond(self, vDescCond):
        self.vDescCond = vDescCond
    def get_vISSRet(self):
        return self.vISSRet
    def set_vISSRet(self, vISSRet):
        self.vISSRet = vISSRet
    def get_cRegTrib(self):
        return self.cRegTrib
    def set_cRegTrib(self, cRegTrib):
        self.cRegTrib = cRegTrib
    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [[u'^0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [[u'^(((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))$']]
    def validate_cRegTribType(self, value):
        # Validate type cRegTribType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2', '3', '4', '5', '6']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on cRegTribType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.vServ is not None or
            self.vBC is not None or
            self.vISS is not None or
            self.vPIS is not None or
            self.vCOFINS is not None or
            self.dCompet is not None or
            self.vDeducao is not None or
            self.vOutro is not None or
            self.vDescIncond is not None or
            self.vDescCond is not None or
            self.vISSRet is not None or
            self.cRegTrib is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ISSQNtotType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ISSQNtotType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ISSQNtotType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ISSQNtotType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ISSQNtotType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ISSQNtotType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vServ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svServ>%s</%svServ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vServ), input_name='vServ')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.vISS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svISS>%s</%svISS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vISS), input_name='vISS')), namespaceprefix_ , eol_))
        if self.vPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svPIS>%s</%svPIS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vPIS), input_name='vPIS')), namespaceprefix_ , eol_))
        if self.vCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svCOFINS>%s</%svCOFINS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vCOFINS), input_name='vCOFINS')), namespaceprefix_ , eol_))
        if self.dCompet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdCompet>%s</%sdCompet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dCompet), input_name='dCompet')), namespaceprefix_ , eol_))
        if self.vDeducao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDeducao>%s</%svDeducao>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDeducao), input_name='vDeducao')), namespaceprefix_ , eol_))
        if self.vOutro is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svOutro>%s</%svOutro>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vOutro), input_name='vOutro')), namespaceprefix_ , eol_))
        if self.vDescIncond is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDescIncond>%s</%svDescIncond>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDescIncond), input_name='vDescIncond')), namespaceprefix_ , eol_))
        if self.vDescCond is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDescCond>%s</%svDescCond>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDescCond), input_name='vDescCond')), namespaceprefix_ , eol_))
        if self.vISSRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svISSRet>%s</%svISSRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vISSRet), input_name='vISSRet')), namespaceprefix_ , eol_))
        if self.cRegTrib is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scRegTrib>%s</%scRegTrib>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cRegTrib), input_name='cRegTrib')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vServ':
            vServ_ = child_.text
            vServ_ = self.gds_validate_string(vServ_, node, 'vServ')
            self.vServ = vServ_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vServ)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vBC)
        elif nodeName_ == 'vISS':
            vISS_ = child_.text
            vISS_ = self.gds_validate_string(vISS_, node, 'vISS')
            self.vISS = vISS_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vISS)
        elif nodeName_ == 'vPIS':
            vPIS_ = child_.text
            vPIS_ = self.gds_validate_string(vPIS_, node, 'vPIS')
            self.vPIS = vPIS_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vPIS)
        elif nodeName_ == 'vCOFINS':
            vCOFINS_ = child_.text
            vCOFINS_ = self.gds_validate_string(vCOFINS_, node, 'vCOFINS')
            self.vCOFINS = vCOFINS_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vCOFINS)
        elif nodeName_ == 'dCompet':
            dCompet_ = child_.text
            dCompet_ = self.gds_validate_string(dCompet_, node, 'dCompet')
            self.dCompet = dCompet_
            # validate type TData
            self.validate_TData(self.dCompet)
        elif nodeName_ == 'vDeducao':
            vDeducao_ = child_.text
            vDeducao_ = self.gds_validate_string(vDeducao_, node, 'vDeducao')
            self.vDeducao = vDeducao_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDeducao)
        elif nodeName_ == 'vOutro':
            vOutro_ = child_.text
            vOutro_ = self.gds_validate_string(vOutro_, node, 'vOutro')
            self.vOutro = vOutro_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vOutro)
        elif nodeName_ == 'vDescIncond':
            vDescIncond_ = child_.text
            vDescIncond_ = self.gds_validate_string(vDescIncond_, node, 'vDescIncond')
            self.vDescIncond = vDescIncond_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDescIncond)
        elif nodeName_ == 'vDescCond':
            vDescCond_ = child_.text
            vDescCond_ = self.gds_validate_string(vDescCond_, node, 'vDescCond')
            self.vDescCond = vDescCond_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDescCond)
        elif nodeName_ == 'vISSRet':
            vISSRet_ = child_.text
            vISSRet_ = self.gds_validate_string(vISSRet_, node, 'vISSRet')
            self.vISSRet = vISSRet_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vISSRet)
        elif nodeName_ == 'cRegTrib':
            cRegTrib_ = child_.text
            cRegTrib_ = self.gds_validate_string(cRegTrib_, node, 'cRegTrib')
            self.cRegTrib = cRegTrib_
            # validate type cRegTribType
            self.validate_cRegTribType(self.cRegTrib)
# end class ISSQNtotType


class retTribType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vRetPIS=None, vRetCOFINS=None, vRetCSLL=None, vBCIRRF=None, vIRRF=None, vBCRetPrev=None, vRetPrev=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.vRetPIS = vRetPIS
        self.validate_TDec_1302Opc(self.vRetPIS)
        self.vRetCOFINS = vRetCOFINS
        self.validate_TDec_1302Opc(self.vRetCOFINS)
        self.vRetCSLL = vRetCSLL
        self.validate_TDec_1302Opc(self.vRetCSLL)
        self.vBCIRRF = vBCIRRF
        self.validate_TDec_1302Opc(self.vBCIRRF)
        self.vIRRF = vIRRF
        self.validate_TDec_1302Opc(self.vIRRF)
        self.vBCRetPrev = vBCRetPrev
        self.validate_TDec_1302Opc(self.vBCRetPrev)
        self.vRetPrev = vRetPrev
        self.validate_TDec_1302Opc(self.vRetPrev)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, retTribType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if retTribType.subclass:
            return retTribType.subclass(*args_, **kwargs_)
        else:
            return retTribType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vRetPIS(self):
        return self.vRetPIS
    def set_vRetPIS(self, vRetPIS):
        self.vRetPIS = vRetPIS
    def get_vRetCOFINS(self):
        return self.vRetCOFINS
    def set_vRetCOFINS(self, vRetCOFINS):
        self.vRetCOFINS = vRetCOFINS
    def get_vRetCSLL(self):
        return self.vRetCSLL
    def set_vRetCSLL(self, vRetCSLL):
        self.vRetCSLL = vRetCSLL
    def get_vBCIRRF(self):
        return self.vBCIRRF
    def set_vBCIRRF(self, vBCIRRF):
        self.vBCIRRF = vBCIRRF
    def get_vIRRF(self):
        return self.vIRRF
    def set_vIRRF(self, vIRRF):
        self.vIRRF = vIRRF
    def get_vBCRetPrev(self):
        return self.vBCRetPrev
    def set_vBCRetPrev(self, vBCRetPrev):
        self.vBCRetPrev = vBCRetPrev
    def get_vRetPrev(self):
        return self.vRetPrev
    def set_vRetPrev(self, vRetPrev):
        self.vRetPrev = vRetPrev
    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [[u'^0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.vRetPIS is not None or
            self.vRetCOFINS is not None or
            self.vRetCSLL is not None or
            self.vBCIRRF is not None or
            self.vIRRF is not None or
            self.vBCRetPrev is not None or
            self.vRetPrev is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='retTribType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('retTribType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='retTribType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='retTribType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='retTribType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='retTribType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vRetPIS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svRetPIS>%s</%svRetPIS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vRetPIS), input_name='vRetPIS')), namespaceprefix_ , eol_))
        if self.vRetCOFINS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svRetCOFINS>%s</%svRetCOFINS>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vRetCOFINS), input_name='vRetCOFINS')), namespaceprefix_ , eol_))
        if self.vRetCSLL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svRetCSLL>%s</%svRetCSLL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vRetCSLL), input_name='vRetCSLL')), namespaceprefix_ , eol_))
        if self.vBCIRRF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCIRRF>%s</%svBCIRRF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCIRRF), input_name='vBCIRRF')), namespaceprefix_ , eol_))
        if self.vIRRF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svIRRF>%s</%svIRRF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vIRRF), input_name='vIRRF')), namespaceprefix_ , eol_))
        if self.vBCRetPrev is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCRetPrev>%s</%svBCRetPrev>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCRetPrev), input_name='vBCRetPrev')), namespaceprefix_ , eol_))
        if self.vRetPrev is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svRetPrev>%s</%svRetPrev>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vRetPrev), input_name='vRetPrev')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vRetPIS':
            vRetPIS_ = child_.text
            vRetPIS_ = self.gds_validate_string(vRetPIS_, node, 'vRetPIS')
            self.vRetPIS = vRetPIS_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vRetPIS)
        elif nodeName_ == 'vRetCOFINS':
            vRetCOFINS_ = child_.text
            vRetCOFINS_ = self.gds_validate_string(vRetCOFINS_, node, 'vRetCOFINS')
            self.vRetCOFINS = vRetCOFINS_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vRetCOFINS)
        elif nodeName_ == 'vRetCSLL':
            vRetCSLL_ = child_.text
            vRetCSLL_ = self.gds_validate_string(vRetCSLL_, node, 'vRetCSLL')
            self.vRetCSLL = vRetCSLL_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vRetCSLL)
        elif nodeName_ == 'vBCIRRF':
            vBCIRRF_ = child_.text
            vBCIRRF_ = self.gds_validate_string(vBCIRRF_, node, 'vBCIRRF')
            self.vBCIRRF = vBCIRRF_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vBCIRRF)
        elif nodeName_ == 'vIRRF':
            vIRRF_ = child_.text
            vIRRF_ = self.gds_validate_string(vIRRF_, node, 'vIRRF')
            self.vIRRF = vIRRF_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vIRRF)
        elif nodeName_ == 'vBCRetPrev':
            vBCRetPrev_ = child_.text
            vBCRetPrev_ = self.gds_validate_string(vBCRetPrev_, node, 'vBCRetPrev')
            self.vBCRetPrev = vBCRetPrev_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vBCRetPrev)
        elif nodeName_ == 'vRetPrev':
            vRetPrev_ = child_.text
            vRetPrev_ = self.gds_validate_string(vRetPrev_, node, 'vRetPrev')
            self.vRetPrev = vRetPrev_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vRetPrev)
# end class retTribType


class transpType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, modFrete=None, transporta=None, retTransp=None, veicTransp=None, reboque=None, vagao=None, balsa=None, vol=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.modFrete = modFrete
        self.validate_modFreteType(self.modFrete)
        self.transporta = transporta
        self.retTransp = retTransp
        self.veicTransp = veicTransp
        if reboque is None:
            self.reboque = []
        else:
            self.reboque = reboque
        self.vagao = vagao
        self.validate_vagaoType(self.vagao)
        self.balsa = balsa
        self.validate_balsaType(self.balsa)
        if vol is None:
            self.vol = []
        else:
            self.vol = vol
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transpType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transpType.subclass:
            return transpType.subclass(*args_, **kwargs_)
        else:
            return transpType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_modFrete(self):
        return self.modFrete
    def set_modFrete(self, modFrete):
        self.modFrete = modFrete
    def get_transporta(self):
        return self.transporta
    def set_transporta(self, transporta):
        self.transporta = transporta
    def get_retTransp(self):
        return self.retTransp
    def set_retTransp(self, retTransp):
        self.retTransp = retTransp
    def get_veicTransp(self):
        return self.veicTransp
    def set_veicTransp(self, veicTransp):
        self.veicTransp = veicTransp
    def get_reboque(self):
        return self.reboque
    def set_reboque(self, reboque):
        self.reboque = reboque
    def add_reboque(self, value):
        self.reboque.append(value)
    def add_reboque(self, value):
        self.reboque.append(value)
    def insert_reboque_at(self, index, value):
        self.reboque.insert(index, value)
    def replace_reboque_at(self, index, value):
        self.reboque[index] = value
    def get_vagao(self):
        return self.vagao
    def set_vagao(self, vagao):
        self.vagao = vagao
    def get_balsa(self):
        return self.balsa
    def set_balsa(self, balsa):
        self.balsa = balsa
    def get_vol(self):
        return self.vol
    def set_vol(self, vol):
        self.vol = vol
    def add_vol(self, value):
        self.vol.append(value)
    def add_vol(self, value):
        self.vol.append(value)
    def insert_vol_at(self, index, value):
        self.vol.insert(index, value)
    def replace_vol_at(self, index, value):
        self.vol[index] = value
    def validate_modFreteType(self, value):
        # Validate type modFreteType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '4', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on modFreteType' % {"value" : value.encode("utf-8")} )
    def validate_vagaoType(self, value):
        # Validate type vagaoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on vagaoType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on vagaoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_vagaoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_vagaoType_patterns_, ))
    validate_vagaoType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_balsaType(self, value):
        # Validate type balsaType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on balsaType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on balsaType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_balsaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_balsaType_patterns_, ))
    validate_balsaType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.modFrete is not None or
            self.transporta is not None or
            self.retTransp is not None or
            self.veicTransp is not None or
            self.reboque or
            self.vagao is not None or
            self.balsa is not None or
            self.vol
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='transpType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transpType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='transpType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='transpType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='transpType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='transpType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.modFrete is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smodFrete>%s</%smodFrete>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.modFrete), input_name='modFrete')), namespaceprefix_ , eol_))
        if self.transporta is not None:
            self.transporta.export(outfile, level, namespaceprefix_, namespacedef_='', name_='transporta', pretty_print=pretty_print)
        if self.retTransp is not None:
            self.retTransp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='retTransp', pretty_print=pretty_print)
        if self.veicTransp is not None:
            self.veicTransp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='veicTransp', pretty_print=pretty_print)
        for reboque_ in self.reboque:
            reboque_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reboque', pretty_print=pretty_print)
        if self.vagao is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svagao>%s</%svagao>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vagao), input_name='vagao')), namespaceprefix_ , eol_))
        if self.balsa is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbalsa>%s</%sbalsa>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.balsa), input_name='balsa')), namespaceprefix_ , eol_))
        for vol_ in self.vol:
            vol_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vol', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'modFrete':
            modFrete_ = child_.text
            modFrete_ = self.gds_validate_string(modFrete_, node, 'modFrete')
            self.modFrete = modFrete_
            # validate type modFreteType
            self.validate_modFreteType(self.modFrete)
        elif nodeName_ == 'transporta':
            obj_ = transportaType.factory(parent_object_=self)
            obj_.build(child_)
            self.transporta = obj_
            obj_.original_tagname_ = 'transporta'
        elif nodeName_ == 'retTransp':
            obj_ = retTranspType.factory(parent_object_=self)
            obj_.build(child_)
            self.retTransp = obj_
            obj_.original_tagname_ = 'retTransp'
        elif nodeName_ == 'veicTransp':
            obj_ = TVeiculo.factory(parent_object_=self)
            obj_.build(child_)
            self.veicTransp = obj_
            obj_.original_tagname_ = 'veicTransp'
        elif nodeName_ == 'reboque':
            obj_ = TVeiculo.factory(parent_object_=self)
            obj_.build(child_)
            self.reboque.append(obj_)
            obj_.original_tagname_ = 'reboque'
        elif nodeName_ == 'vagao':
            vagao_ = child_.text
            vagao_ = self.gds_validate_string(vagao_, node, 'vagao')
            self.vagao = vagao_
            # validate type vagaoType
            self.validate_vagaoType(self.vagao)
        elif nodeName_ == 'balsa':
            balsa_ = child_.text
            balsa_ = self.gds_validate_string(balsa_, node, 'balsa')
            self.balsa = balsa_
            # validate type balsaType
            self.validate_balsaType(self.balsa)
        elif nodeName_ == 'vol':
            obj_ = volType.factory(parent_object_=self)
            obj_.build(child_)
            self.vol.append(obj_)
            obj_.original_tagname_ = 'vol'
# end class transpType


class transportaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CNPJ=None, CPF=None, xNome=None, IE=None, xEnder=None, xMun=None, UF=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.CPF = CPF
        self.validate_TCpf(self.CPF)
        self.xNome = xNome
        self.validate_xNomeType49(self.xNome)
        self.IE = IE
        self.validate_TIeDest(self.IE)
        self.xEnder = xEnder
        self.validate_xEnderType(self.xEnder)
        self.xMun = xMun
        self.validate_xMunType(self.xMun)
        self.UF = UF
        self.validate_TUf(self.UF)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, transportaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if transportaType.subclass:
            return transportaType.subclass(*args_, **kwargs_)
        else:
            return transportaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_CPF(self):
        return self.CPF
    def set_CPF(self, CPF):
        self.CPF = CPF
    def get_xNome(self):
        return self.xNome
    def set_xNome(self, xNome):
        self.xNome = xNome
    def get_IE(self):
        return self.IE
    def set_IE(self, IE):
        self.IE = IE
    def get_xEnder(self):
        return self.xEnder
    def set_xEnder(self, xEnder):
        self.xEnder = xEnder
    def get_xMun(self):
        return self.xMun
    def set_xMun(self, xMun):
        self.xMun = xMun
    def get_UF(self):
        return self.UF
    def set_UF(self, UF):
        self.UF = UF
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [[u'^[0-9]{14}$']]
    def validate_TCpf(self, value):
        # Validate type TCpf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 11:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCpf' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCpf_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCpf_patterns_, ))
    validate_TCpf_patterns_ = [[u'^[0-9]{11}$']]
    def validate_xNomeType49(self, value):
        # Validate type xNomeType49, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xNomeType49' % {"value" : value} )
            if len(str(value)) < 2:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xNomeType49' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xNomeType49_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xNomeType49_patterns_, ))
    validate_xNomeType49_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TIeDest(self, value):
        # Validate type TIeDest, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TIeDest' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TIeDest_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TIeDest_patterns_, ))
    validate_TIeDest_patterns_ = [[u'^ISENTO|[0-9]{2,14}$']]
    def validate_xEnderType(self, value):
        # Validate type xEnderType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xEnderType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xEnderType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xEnderType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xEnderType_patterns_, ))
    validate_xEnderType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_xMunType(self, value):
        # Validate type xMunType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xMunType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xMunType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xMunType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xMunType_patterns_, ))
    validate_xMunType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TUf(self, value):
        # Validate type TUf, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO', 'EX']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUf' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CNPJ is not None or
            self.CPF is not None or
            self.xNome is not None or
            self.IE is not None or
            self.xEnder is not None or
            self.xMun is not None or
            self.UF is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='transportaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('transportaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='transportaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='transportaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='transportaType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='transportaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.CPF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCPF>%s</%sCPF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CPF), input_name='CPF')), namespaceprefix_ , eol_))
        if self.xNome is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNome>%s</%sxNome>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNome), input_name='xNome')), namespaceprefix_ , eol_))
        if self.IE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIE>%s</%sIE>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.IE), input_name='IE')), namespaceprefix_ , eol_))
        if self.xEnder is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxEnder>%s</%sxEnder>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xEnder), input_name='xEnder')), namespaceprefix_ , eol_))
        if self.xMun is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMun>%s</%sxMun>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMun), input_name='xMun')), namespaceprefix_ , eol_))
        if self.UF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUF>%s</%sUF>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UF), input_name='UF')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'CPF':
            CPF_ = child_.text
            CPF_ = self.gds_validate_string(CPF_, node, 'CPF')
            self.CPF = CPF_
            # validate type TCpf
            self.validate_TCpf(self.CPF)
        elif nodeName_ == 'xNome':
            xNome_ = child_.text
            xNome_ = self.gds_validate_string(xNome_, node, 'xNome')
            self.xNome = xNome_
            # validate type xNomeType49
            self.validate_xNomeType49(self.xNome)
        elif nodeName_ == 'IE':
            IE_ = child_.text
            IE_ = self.gds_validate_string(IE_, node, 'IE')
            self.IE = IE_
            # validate type TIeDest
            self.validate_TIeDest(self.IE)
        elif nodeName_ == 'xEnder':
            xEnder_ = child_.text
            xEnder_ = self.gds_validate_string(xEnder_, node, 'xEnder')
            self.xEnder = xEnder_
            # validate type xEnderType
            self.validate_xEnderType(self.xEnder)
        elif nodeName_ == 'xMun':
            xMun_ = child_.text
            xMun_ = self.gds_validate_string(xMun_, node, 'xMun')
            self.xMun = xMun_
            # validate type xMunType
            self.validate_xMunType(self.xMun)
        elif nodeName_ == 'UF':
            UF_ = child_.text
            UF_ = self.gds_validate_string(UF_, node, 'UF')
            self.UF = UF_
            # validate type TUf
            self.validate_TUf(self.UF)
# end class transportaType


class retTranspType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, vServ=None, vBCRet=None, pICMSRet=None, vICMSRet=None, CFOP=None, cMunFG=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.vServ = vServ
        self.validate_TDec_1302(self.vServ)
        self.vBCRet = vBCRet
        self.validate_TDec_1302(self.vBCRet)
        self.pICMSRet = pICMSRet
        self.validate_TDec_0302a04(self.pICMSRet)
        self.vICMSRet = vICMSRet
        self.validate_TDec_1302(self.vICMSRet)
        self.CFOP = CFOP
        self.validate_CFOPType50(self.CFOP)
        self.cMunFG = cMunFG
        self.validate_TCodMunIBGE(self.cMunFG)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, retTranspType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if retTranspType.subclass:
            return retTranspType.subclass(*args_, **kwargs_)
        else:
            return retTranspType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vServ(self):
        return self.vServ
    def set_vServ(self, vServ):
        self.vServ = vServ
    def get_vBCRet(self):
        return self.vBCRet
    def set_vBCRet(self, vBCRet):
        self.vBCRet = vBCRet
    def get_pICMSRet(self):
        return self.pICMSRet
    def set_pICMSRet(self, pICMSRet):
        self.pICMSRet = pICMSRet
    def get_vICMSRet(self):
        return self.vICMSRet
    def set_vICMSRet(self, vICMSRet):
        self.vICMSRet = vICMSRet
    def get_CFOP(self):
        return self.CFOP
    def set_CFOP(self, CFOP):
        self.CFOP = CFOP
    def get_cMunFG(self):
        return self.cMunFG
    def set_cMunFG(self, cMunFG):
        self.cMunFG = cMunFG
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_CFOPType50(self, value):
        # Validate type CFOPType50, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_CFOPType50_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_CFOPType50_patterns_, ))
    validate_CFOPType50_patterns_ = [[u'^[1,2,3,5,6,7]{1}[0-9]{3}$']]
    def validate_TCodMunIBGE(self, value):
        # Validate type TCodMunIBGE, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TCodMunIBGE_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCodMunIBGE_patterns_, ))
    validate_TCodMunIBGE_patterns_ = [[u'^[0-9]{7}$']]
    def hasContent_(self):
        if (
            self.vServ is not None or
            self.vBCRet is not None or
            self.pICMSRet is not None or
            self.vICMSRet is not None or
            self.CFOP is not None or
            self.cMunFG is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='retTranspType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('retTranspType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='retTranspType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='retTranspType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='retTranspType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='retTranspType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.vServ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svServ>%s</%svServ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vServ), input_name='vServ')), namespaceprefix_ , eol_))
        if self.vBCRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBCRet>%s</%svBCRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBCRet), input_name='vBCRet')), namespaceprefix_ , eol_))
        if self.pICMSRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spICMSRet>%s</%spICMSRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pICMSRet), input_name='pICMSRet')), namespaceprefix_ , eol_))
        if self.vICMSRet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svICMSRet>%s</%svICMSRet>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vICMSRet), input_name='vICMSRet')), namespaceprefix_ , eol_))
        if self.CFOP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCFOP>%s</%sCFOP>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CFOP), input_name='CFOP')), namespaceprefix_ , eol_))
        if self.cMunFG is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scMunFG>%s</%scMunFG>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cMunFG), input_name='cMunFG')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'vServ':
            vServ_ = child_.text
            vServ_ = self.gds_validate_string(vServ_, node, 'vServ')
            self.vServ = vServ_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vServ)
        elif nodeName_ == 'vBCRet':
            vBCRet_ = child_.text
            vBCRet_ = self.gds_validate_string(vBCRet_, node, 'vBCRet')
            self.vBCRet = vBCRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBCRet)
        elif nodeName_ == 'pICMSRet':
            pICMSRet_ = child_.text
            pICMSRet_ = self.gds_validate_string(pICMSRet_, node, 'pICMSRet')
            self.pICMSRet = pICMSRet_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pICMSRet)
        elif nodeName_ == 'vICMSRet':
            vICMSRet_ = child_.text
            vICMSRet_ = self.gds_validate_string(vICMSRet_, node, 'vICMSRet')
            self.vICMSRet = vICMSRet_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vICMSRet)
        elif nodeName_ == 'CFOP':
            CFOP_ = child_.text
            CFOP_ = self.gds_validate_string(CFOP_, node, 'CFOP')
            self.CFOP = CFOP_
            # validate type CFOPType50
            self.validate_CFOPType50(self.CFOP)
        elif nodeName_ == 'cMunFG':
            cMunFG_ = child_.text
            cMunFG_ = self.gds_validate_string(cMunFG_, node, 'cMunFG')
            self.cMunFG = cMunFG_
            # validate type TCodMunIBGE
            self.validate_TCodMunIBGE(self.cMunFG)
# end class retTranspType


class volType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, qVol=None, esp=None, marca=None, nVol=None, pesoL=None, pesoB=None, lacres=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.qVol = qVol
        self.validate_qVolType(self.qVol)
        self.esp = esp
        self.validate_espType(self.esp)
        self.marca = marca
        self.validate_marcaType(self.marca)
        self.nVol = nVol
        self.validate_nVolType(self.nVol)
        self.pesoL = pesoL
        self.validate_TDec_1203(self.pesoL)
        self.pesoB = pesoB
        self.validate_TDec_1203(self.pesoB)
        if lacres is None:
            self.lacres = []
        else:
            self.lacres = lacres
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, volType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if volType.subclass:
            return volType.subclass(*args_, **kwargs_)
        else:
            return volType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qVol(self):
        return self.qVol
    def set_qVol(self, qVol):
        self.qVol = qVol
    def get_esp(self):
        return self.esp
    def set_esp(self, esp):
        self.esp = esp
    def get_marca(self):
        return self.marca
    def set_marca(self, marca):
        self.marca = marca
    def get_nVol(self):
        return self.nVol
    def set_nVol(self, nVol):
        self.nVol = nVol
    def get_pesoL(self):
        return self.pesoL
    def set_pesoL(self, pesoL):
        self.pesoL = pesoL
    def get_pesoB(self):
        return self.pesoB
    def set_pesoB(self, pesoB):
        self.pesoB = pesoB
    def get_lacres(self):
        return self.lacres
    def set_lacres(self, lacres):
        self.lacres = lacres
    def add_lacres(self, value):
        self.lacres.append(value)
    def add_lacres(self, value):
        self.lacres.append(value)
    def insert_lacres_at(self, index, value):
        self.lacres.insert(index, value)
    def replace_lacres_at(self, index, value):
        self.lacres[index] = value
    def validate_qVolType(self, value):
        # Validate type qVolType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_qVolType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_qVolType_patterns_, ))
    validate_qVolType_patterns_ = [[u'^[0-9]{1,15}$']]
    def validate_espType(self, value):
        # Validate type espType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on espType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on espType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_espType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_espType_patterns_, ))
    validate_espType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_marcaType(self, value):
        # Validate type marcaType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on marcaType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on marcaType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_marcaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_marcaType_patterns_, ))
    validate_marcaType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_nVolType(self, value):
        # Validate type nVolType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nVolType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nVolType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nVolType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nVolType_patterns_, ))
    validate_nVolType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TDec_1203(self, value):
        # Validate type TDec_1203, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1203_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1203_patterns_, ))
    validate_TDec_1203_patterns_ = [[u'^0|0\\.[0-9]{3}|[1-9]{1}[0-9]{0,11}(\\.[0-9]{3})?$']]
    def hasContent_(self):
        if (
            self.qVol is not None or
            self.esp is not None or
            self.marca is not None or
            self.nVol is not None or
            self.pesoL is not None or
            self.pesoB is not None or
            self.lacres
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='volType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('volType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='volType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='volType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='volType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='volType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qVol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqVol>%s</%sqVol>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qVol), input_name='qVol')), namespaceprefix_ , eol_))
        if self.esp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sesp>%s</%sesp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.esp), input_name='esp')), namespaceprefix_ , eol_))
        if self.marca is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smarca>%s</%smarca>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.marca), input_name='marca')), namespaceprefix_ , eol_))
        if self.nVol is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snVol>%s</%snVol>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nVol), input_name='nVol')), namespaceprefix_ , eol_))
        if self.pesoL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spesoL>%s</%spesoL>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pesoL), input_name='pesoL')), namespaceprefix_ , eol_))
        if self.pesoB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spesoB>%s</%spesoB>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pesoB), input_name='pesoB')), namespaceprefix_ , eol_))
        for lacres_ in self.lacres:
            lacres_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lacres', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qVol':
            qVol_ = child_.text
            qVol_ = self.gds_validate_string(qVol_, node, 'qVol')
            self.qVol = qVol_
            # validate type qVolType
            self.validate_qVolType(self.qVol)
        elif nodeName_ == 'esp':
            esp_ = child_.text
            esp_ = self.gds_validate_string(esp_, node, 'esp')
            self.esp = esp_
            # validate type espType
            self.validate_espType(self.esp)
        elif nodeName_ == 'marca':
            marca_ = child_.text
            marca_ = self.gds_validate_string(marca_, node, 'marca')
            self.marca = marca_
            # validate type marcaType
            self.validate_marcaType(self.marca)
        elif nodeName_ == 'nVol':
            nVol_ = child_.text
            nVol_ = self.gds_validate_string(nVol_, node, 'nVol')
            self.nVol = nVol_
            # validate type nVolType
            self.validate_nVolType(self.nVol)
        elif nodeName_ == 'pesoL':
            pesoL_ = child_.text
            pesoL_ = self.gds_validate_string(pesoL_, node, 'pesoL')
            self.pesoL = pesoL_
            # validate type TDec_1203
            self.validate_TDec_1203(self.pesoL)
        elif nodeName_ == 'pesoB':
            pesoB_ = child_.text
            pesoB_ = self.gds_validate_string(pesoB_, node, 'pesoB')
            self.pesoB = pesoB_
            # validate type TDec_1203
            self.validate_TDec_1203(self.pesoB)
        elif nodeName_ == 'lacres':
            obj_ = lacresType.factory(parent_object_=self)
            obj_.build(child_)
            self.lacres.append(obj_)
            obj_.original_tagname_ = 'lacres'
# end class volType


class lacresType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nLacre=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.nLacre = nLacre
        self.validate_nLacreType(self.nLacre)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, lacresType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if lacresType.subclass:
            return lacresType.subclass(*args_, **kwargs_)
        else:
            return lacresType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nLacre(self):
        return self.nLacre
    def set_nLacre(self, nLacre):
        self.nLacre = nLacre
    def validate_nLacreType(self, value):
        # Validate type nLacreType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nLacreType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nLacreType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nLacreType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nLacreType_patterns_, ))
    validate_nLacreType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.nLacre is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lacresType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('lacresType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='lacresType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='lacresType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='lacresType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='lacresType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nLacre is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snLacre>%s</%snLacre>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nLacre), input_name='nLacre')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nLacre':
            nLacre_ = child_.text
            nLacre_ = self.gds_validate_string(nLacre_, node, 'nLacre')
            self.nLacre = nLacre_
            # validate type nLacreType
            self.validate_nLacreType(self.nLacre)
# end class lacresType


class cobrType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, fat=None, dup=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.fat = fat
        if dup is None:
            self.dup = []
        else:
            self.dup = dup
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cobrType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cobrType.subclass:
            return cobrType.subclass(*args_, **kwargs_)
        else:
            return cobrType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_fat(self):
        return self.fat
    def set_fat(self, fat):
        self.fat = fat
    def get_dup(self):
        return self.dup
    def set_dup(self, dup):
        self.dup = dup
    def add_dup(self, value):
        self.dup.append(value)
    def add_dup(self, value):
        self.dup.append(value)
    def insert_dup_at(self, index, value):
        self.dup.insert(index, value)
    def replace_dup_at(self, index, value):
        self.dup[index] = value
    def hasContent_(self):
        if (
            self.fat is not None or
            self.dup
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cobrType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cobrType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cobrType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cobrType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cobrType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cobrType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.fat is not None:
            self.fat.export(outfile, level, namespaceprefix_, namespacedef_='', name_='fat', pretty_print=pretty_print)
        for dup_ in self.dup:
            dup_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dup', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'fat':
            obj_ = fatType.factory(parent_object_=self)
            obj_.build(child_)
            self.fat = obj_
            obj_.original_tagname_ = 'fat'
        elif nodeName_ == 'dup':
            obj_ = dupType.factory(parent_object_=self)
            obj_.build(child_)
            self.dup.append(obj_)
            obj_.original_tagname_ = 'dup'
# end class cobrType


class fatType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nFat=None, vOrig=None, vDesc=None, vLiq=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.nFat = nFat
        self.validate_nFatType(self.nFat)
        self.vOrig = vOrig
        self.validate_TDec_1302(self.vOrig)
        self.vDesc = vDesc
        self.validate_TDec_1302(self.vDesc)
        self.vLiq = vLiq
        self.validate_TDec_1302(self.vLiq)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, fatType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if fatType.subclass:
            return fatType.subclass(*args_, **kwargs_)
        else:
            return fatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nFat(self):
        return self.nFat
    def set_nFat(self, nFat):
        self.nFat = nFat
    def get_vOrig(self):
        return self.vOrig
    def set_vOrig(self, vOrig):
        self.vOrig = vOrig
    def get_vDesc(self):
        return self.vDesc
    def set_vDesc(self, vDesc):
        self.vDesc = vDesc
    def get_vLiq(self):
        return self.vLiq
    def set_vLiq(self, vLiq):
        self.vLiq = vLiq
    def validate_nFatType(self, value):
        # Validate type nFatType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nFatType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nFatType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nFatType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nFatType_patterns_, ))
    validate_nFatType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.nFat is not None or
            self.vOrig is not None or
            self.vDesc is not None or
            self.vLiq is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fatType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('fatType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='fatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='fatType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='fatType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='fatType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nFat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snFat>%s</%snFat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nFat), input_name='nFat')), namespaceprefix_ , eol_))
        if self.vOrig is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svOrig>%s</%svOrig>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vOrig), input_name='vOrig')), namespaceprefix_ , eol_))
        if self.vDesc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDesc>%s</%svDesc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDesc), input_name='vDesc')), namespaceprefix_ , eol_))
        if self.vLiq is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svLiq>%s</%svLiq>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vLiq), input_name='vLiq')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nFat':
            nFat_ = child_.text
            nFat_ = self.gds_validate_string(nFat_, node, 'nFat')
            self.nFat = nFat_
            # validate type nFatType
            self.validate_nFatType(self.nFat)
        elif nodeName_ == 'vOrig':
            vOrig_ = child_.text
            vOrig_ = self.gds_validate_string(vOrig_, node, 'vOrig')
            self.vOrig = vOrig_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vOrig)
        elif nodeName_ == 'vDesc':
            vDesc_ = child_.text
            vDesc_ = self.gds_validate_string(vDesc_, node, 'vDesc')
            self.vDesc = vDesc_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vDesc)
        elif nodeName_ == 'vLiq':
            vLiq_ = child_.text
            vLiq_ = self.gds_validate_string(vLiq_, node, 'vLiq')
            self.vLiq = vLiq_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vLiq)
# end class fatType


class dupType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nDup=None, dVenc=None, vDup=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.nDup = nDup
        self.validate_nDupType(self.nDup)
        self.dVenc = dVenc
        self.validate_TData(self.dVenc)
        self.vDup = vDup
        self.validate_TDec_1302Opc(self.vDup)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, dupType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if dupType.subclass:
            return dupType.subclass(*args_, **kwargs_)
        else:
            return dupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nDup(self):
        return self.nDup
    def set_nDup(self, nDup):
        self.nDup = nDup
    def get_dVenc(self):
        return self.dVenc
    def set_dVenc(self, dVenc):
        self.dVenc = dVenc
    def get_vDup(self):
        return self.vDup
    def set_vDup(self, vDup):
        self.vDup = vDup
    def validate_nDupType(self, value):
        # Validate type nDupType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nDupType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nDupType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nDupType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nDupType_patterns_, ))
    validate_nDupType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TData(self, value):
        # Validate type TData, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TData_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TData_patterns_, ))
    validate_TData_patterns_ = [[u'^(((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))$']]
    def validate_TDec_1302Opc(self, value):
        # Validate type TDec_1302Opc, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302Opc_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302Opc_patterns_, ))
    validate_TDec_1302Opc_patterns_ = [[u'^0\\.[0-9]{1}[1-9]{1}|0\\.[1-9]{1}[0-9]{1}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.nDup is not None or
            self.dVenc is not None or
            self.vDup is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='dupType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('dupType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='dupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='dupType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='dupType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='dupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nDup is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snDup>%s</%snDup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nDup), input_name='nDup')), namespaceprefix_ , eol_))
        if self.dVenc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdVenc>%s</%sdVenc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dVenc), input_name='dVenc')), namespaceprefix_ , eol_))
        if self.vDup is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDup>%s</%svDup>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDup), input_name='vDup')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nDup':
            nDup_ = child_.text
            nDup_ = self.gds_validate_string(nDup_, node, 'nDup')
            self.nDup = nDup_
            # validate type nDupType
            self.validate_nDupType(self.nDup)
        elif nodeName_ == 'dVenc':
            dVenc_ = child_.text
            dVenc_ = self.gds_validate_string(dVenc_, node, 'dVenc')
            self.dVenc = dVenc_
            # validate type TData
            self.validate_TData(self.dVenc)
        elif nodeName_ == 'vDup':
            vDup_ = child_.text
            vDup_ = self.gds_validate_string(vDup_, node, 'vDup')
            self.vDup = vDup_
            # validate type TDec_1302Opc
            self.validate_TDec_1302Opc(self.vDup)
# end class dupType


class pagType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, detPag=None, vTroco=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        if detPag is None:
            self.detPag = []
        else:
            self.detPag = detPag
        self.vTroco = vTroco
        self.validate_TDec_1302(self.vTroco)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, pagType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if pagType.subclass:
            return pagType.subclass(*args_, **kwargs_)
        else:
            return pagType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_detPag(self):
        return self.detPag
    def set_detPag(self, detPag):
        self.detPag = detPag
    def add_detPag(self, value):
        self.detPag.append(value)
    def add_detPag(self, value):
        self.detPag.append(value)
    def insert_detPag_at(self, index, value):
        self.detPag.insert(index, value)
    def replace_detPag_at(self, index, value):
        self.detPag[index] = value
    def get_vTroco(self):
        return self.vTroco
    def set_vTroco(self, vTroco):
        self.vTroco = vTroco
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.detPag or
            self.vTroco is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='pagType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('pagType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='pagType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='pagType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='pagType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='pagType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for detPag_ in self.detPag:
            detPag_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='detPag', pretty_print=pretty_print)
        if self.vTroco is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svTroco>%s</%svTroco>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vTroco), input_name='vTroco')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'detPag':
            obj_ = detPagType.factory(parent_object_=self)
            obj_.build(child_)
            self.detPag.append(obj_)
            obj_.original_tagname_ = 'detPag'
        elif nodeName_ == 'vTroco':
            vTroco_ = child_.text
            vTroco_ = self.gds_validate_string(vTroco_, node, 'vTroco')
            self.vTroco = vTroco_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vTroco)
# end class pagType


class detPagType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, indPag=None, tPag=None, vPag=None, card=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.indPag = indPag
        self.validate_indPagType(self.indPag)
        self.tPag = tPag
        self.validate_tPagType(self.tPag)
        self.vPag = vPag
        self.validate_TDec_1302(self.vPag)
        self.card = card
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, detPagType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if detPagType.subclass:
            return detPagType.subclass(*args_, **kwargs_)
        else:
            return detPagType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_indPag(self):
        return self.indPag
    def set_indPag(self, indPag):
        self.indPag = indPag
    def get_tPag(self):
        return self.tPag
    def set_tPag(self, tPag):
        self.tPag = tPag
    def get_vPag(self):
        return self.vPag
    def set_vPag(self, vPag):
        self.vPag = vPag
    def get_card(self):
        return self.card
    def set_card(self, card):
        self.card = card
    def validate_indPagType(self, value):
        # Validate type indPagType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indPagType' % {"value" : value.encode("utf-8")} )
    def validate_tPagType(self, value):
        # Validate type tPagType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02', '03', '04', '05', '10', '11', '12', '13', '14', '15', '90', '99']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tPagType' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.indPag is not None or
            self.tPag is not None or
            self.vPag is not None or
            self.card is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='detPagType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('detPagType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='detPagType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='detPagType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='detPagType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='detPagType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.indPag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindPag>%s</%sindPag>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indPag), input_name='indPag')), namespaceprefix_ , eol_))
        if self.tPag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stPag>%s</%stPag>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tPag), input_name='tPag')), namespaceprefix_ , eol_))
        if self.vPag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svPag>%s</%svPag>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vPag), input_name='vPag')), namespaceprefix_ , eol_))
        if self.card is not None:
            self.card.export(outfile, level, namespaceprefix_, namespacedef_='', name_='card', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'indPag':
            indPag_ = child_.text
            indPag_ = self.gds_validate_string(indPag_, node, 'indPag')
            self.indPag = indPag_
            # validate type indPagType
            self.validate_indPagType(self.indPag)
        elif nodeName_ == 'tPag':
            tPag_ = child_.text
            tPag_ = self.gds_validate_string(tPag_, node, 'tPag')
            self.tPag = tPag_
            # validate type tPagType
            self.validate_tPagType(self.tPag)
        elif nodeName_ == 'vPag':
            vPag_ = child_.text
            vPag_ = self.gds_validate_string(vPag_, node, 'vPag')
            self.vPag = vPag_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vPag)
        elif nodeName_ == 'card':
            obj_ = cardType.factory(parent_object_=self)
            obj_.build(child_)
            self.card = obj_
            obj_.original_tagname_ = 'card'
# end class detPagType


class cardType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tpIntegra=None, CNPJ=None, tBand=None, cAut=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.tpIntegra = tpIntegra
        self.validate_tpIntegraType(self.tpIntegra)
        self.CNPJ = CNPJ
        self.validate_TCnpj(self.CNPJ)
        self.tBand = tBand
        self.validate_tBandType(self.tBand)
        self.cAut = cAut
        self.validate_cAutType(self.cAut)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, cardType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if cardType.subclass:
            return cardType.subclass(*args_, **kwargs_)
        else:
            return cardType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpIntegra(self):
        return self.tpIntegra
    def set_tpIntegra(self, tpIntegra):
        self.tpIntegra = tpIntegra
    def get_CNPJ(self):
        return self.CNPJ
    def set_CNPJ(self, CNPJ):
        self.CNPJ = CNPJ
    def get_tBand(self):
        return self.tBand
    def set_tBand(self, tBand):
        self.tBand = tBand
    def get_cAut(self):
        return self.cAut
    def set_cAut(self, cAut):
        self.cAut = cAut
    def validate_tpIntegraType(self, value):
        # Validate type tpIntegraType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tpIntegraType' % {"value" : value.encode("utf-8")} )
    def validate_TCnpj(self, value):
        # Validate type TCnpj, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 14:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TCnpj' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TCnpj_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TCnpj_patterns_, ))
    validate_TCnpj_patterns_ = [[u'^[0-9]{14}$']]
    def validate_tBandType(self, value):
        # Validate type tBandType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02', '03', '04', '05', '06', '07', '08', '09', '99']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on tBandType' % {"value" : value.encode("utf-8")} )
    def validate_cAutType(self, value):
        # Validate type cAutType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on cAutType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on cAutType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_cAutType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_cAutType_patterns_, ))
    validate_cAutType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.tpIntegra is not None or
            self.CNPJ is not None or
            self.tBand is not None or
            self.cAut is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cardType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('cardType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='cardType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='cardType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='cardType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='cardType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpIntegra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpIntegra>%s</%stpIntegra>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpIntegra), input_name='tpIntegra')), namespaceprefix_ , eol_))
        if self.CNPJ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCNPJ>%s</%sCNPJ>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CNPJ), input_name='CNPJ')), namespaceprefix_ , eol_))
        if self.tBand is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stBand>%s</%stBand>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tBand), input_name='tBand')), namespaceprefix_ , eol_))
        if self.cAut is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scAut>%s</%scAut>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cAut), input_name='cAut')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpIntegra':
            tpIntegra_ = child_.text
            tpIntegra_ = self.gds_validate_string(tpIntegra_, node, 'tpIntegra')
            self.tpIntegra = tpIntegra_
            # validate type tpIntegraType
            self.validate_tpIntegraType(self.tpIntegra)
        elif nodeName_ == 'CNPJ':
            CNPJ_ = child_.text
            CNPJ_ = self.gds_validate_string(CNPJ_, node, 'CNPJ')
            self.CNPJ = CNPJ_
            # validate type TCnpj
            self.validate_TCnpj(self.CNPJ)
        elif nodeName_ == 'tBand':
            tBand_ = child_.text
            tBand_ = self.gds_validate_string(tBand_, node, 'tBand')
            self.tBand = tBand_
            # validate type tBandType
            self.validate_tBandType(self.tBand)
        elif nodeName_ == 'cAut':
            cAut_ = child_.text
            cAut_ = self.gds_validate_string(cAut_, node, 'cAut')
            self.cAut = cAut_
            # validate type cAutType
            self.validate_cAutType(self.cAut)
# end class cardType


class infAdicType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, infAdFisco=None, infCpl=None, obsCont=None, obsFisco=None, procRef=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.infAdFisco = infAdFisco
        self.validate_infAdFiscoType(self.infAdFisco)
        self.infCpl = infCpl
        self.validate_infCplType(self.infCpl)
        if obsCont is None:
            self.obsCont = []
        else:
            self.obsCont = obsCont
        if obsFisco is None:
            self.obsFisco = []
        else:
            self.obsFisco = obsFisco
        if procRef is None:
            self.procRef = []
        else:
            self.procRef = procRef
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infAdicType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infAdicType.subclass:
            return infAdicType.subclass(*args_, **kwargs_)
        else:
            return infAdicType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_infAdFisco(self):
        return self.infAdFisco
    def set_infAdFisco(self, infAdFisco):
        self.infAdFisco = infAdFisco
    def get_infCpl(self):
        return self.infCpl
    def set_infCpl(self, infCpl):
        self.infCpl = infCpl
    def get_obsCont(self):
        return self.obsCont
    def set_obsCont(self, obsCont):
        self.obsCont = obsCont
    def add_obsCont(self, value):
        self.obsCont.append(value)
    def add_obsCont(self, value):
        self.obsCont.append(value)
    def insert_obsCont_at(self, index, value):
        self.obsCont.insert(index, value)
    def replace_obsCont_at(self, index, value):
        self.obsCont[index] = value
    def get_obsFisco(self):
        return self.obsFisco
    def set_obsFisco(self, obsFisco):
        self.obsFisco = obsFisco
    def add_obsFisco(self, value):
        self.obsFisco.append(value)
    def add_obsFisco(self, value):
        self.obsFisco.append(value)
    def insert_obsFisco_at(self, index, value):
        self.obsFisco.insert(index, value)
    def replace_obsFisco_at(self, index, value):
        self.obsFisco[index] = value
    def get_procRef(self):
        return self.procRef
    def set_procRef(self, procRef):
        self.procRef = procRef
    def add_procRef(self, value):
        self.procRef.append(value)
    def add_procRef(self, value):
        self.procRef.append(value)
    def insert_procRef_at(self, index, value):
        self.procRef.insert(index, value)
    def replace_procRef_at(self, index, value):
        self.procRef[index] = value
    def validate_infAdFiscoType(self, value):
        # Validate type infAdFiscoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 2000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on infAdFiscoType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on infAdFiscoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_infAdFiscoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_infAdFiscoType_patterns_, ))
    validate_infAdFiscoType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_infCplType(self, value):
        # Validate type infCplType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 5000:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on infCplType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on infCplType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_infCplType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_infCplType_patterns_, ))
    validate_infCplType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.infAdFisco is not None or
            self.infCpl is not None or
            self.obsCont or
            self.obsFisco or
            self.procRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='infAdicType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infAdicType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infAdicType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infAdicType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infAdicType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='infAdicType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.infAdFisco is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinfAdFisco>%s</%sinfAdFisco>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.infAdFisco), input_name='infAdFisco')), namespaceprefix_ , eol_))
        if self.infCpl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sinfCpl>%s</%sinfCpl>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.infCpl), input_name='infCpl')), namespaceprefix_ , eol_))
        for obsCont_ in self.obsCont:
            obsCont_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='obsCont', pretty_print=pretty_print)
        for obsFisco_ in self.obsFisco:
            obsFisco_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='obsFisco', pretty_print=pretty_print)
        for procRef_ in self.procRef:
            procRef_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='procRef', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'infAdFisco':
            infAdFisco_ = child_.text
            infAdFisco_ = self.gds_validate_string(infAdFisco_, node, 'infAdFisco')
            self.infAdFisco = infAdFisco_
            # validate type infAdFiscoType
            self.validate_infAdFiscoType(self.infAdFisco)
        elif nodeName_ == 'infCpl':
            infCpl_ = child_.text
            infCpl_ = self.gds_validate_string(infCpl_, node, 'infCpl')
            self.infCpl = infCpl_
            # validate type infCplType
            self.validate_infCplType(self.infCpl)
        elif nodeName_ == 'obsCont':
            obj_ = obsContType.factory(parent_object_=self)
            obj_.build(child_)
            self.obsCont.append(obj_)
            obj_.original_tagname_ = 'obsCont'
        elif nodeName_ == 'obsFisco':
            obj_ = obsFiscoType.factory(parent_object_=self)
            obj_.build(child_)
            self.obsFisco.append(obj_)
            obj_.original_tagname_ = 'obsFisco'
        elif nodeName_ == 'procRef':
            obj_ = procRefType.factory(parent_object_=self)
            obj_.build(child_)
            self.procRef.append(obj_)
            obj_.original_tagname_ = 'procRef'
# end class infAdicType


class obsContType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, xCampo=None, xTexto=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.xCampo = _cast(None, xCampo)
        self.xTexto = xTexto
        self.validate_xTextoType(self.xTexto)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, obsContType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if obsContType.subclass:
            return obsContType.subclass(*args_, **kwargs_)
        else:
            return obsContType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xTexto(self):
        return self.xTexto
    def set_xTexto(self, xTexto):
        self.xTexto = xTexto
    def get_xCampo(self):
        return self.xCampo
    def set_xCampo(self, xCampo):
        self.xCampo = xCampo
    def validate_xTextoType(self, value):
        # Validate type xTextoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xTextoType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xTextoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xTextoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xTextoType_patterns_, ))
    validate_xTextoType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TString(self, value):
        # Validate type TString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TString_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TString_patterns_, ))
    validate_TString_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.xTexto is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='obsContType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('obsContType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='obsContType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='obsContType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='obsContType'):
        if self.xCampo is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            outfile.write(' xCampo=%s' % (quote_attrib(self.xCampo), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='obsContType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xTexto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxTexto>%s</%sxTexto>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xTexto), input_name='xTexto')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xCampo', node)
        if value is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            self.xCampo = value
            self.validate_TString(self.xCampo)    # validate type TString
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xTexto':
            xTexto_ = child_.text
            xTexto_ = self.gds_validate_string(xTexto_, node, 'xTexto')
            self.xTexto = xTexto_
            # validate type xTextoType
            self.validate_xTextoType(self.xTexto)
# end class obsContType


class obsFiscoType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, xCampo=None, xTexto=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.xCampo = _cast(None, xCampo)
        self.xTexto = xTexto
        self.validate_xTextoType51(self.xTexto)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, obsFiscoType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if obsFiscoType.subclass:
            return obsFiscoType.subclass(*args_, **kwargs_)
        else:
            return obsFiscoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xTexto(self):
        return self.xTexto
    def set_xTexto(self, xTexto):
        self.xTexto = xTexto
    def get_xCampo(self):
        return self.xCampo
    def set_xCampo(self, xCampo):
        self.xCampo = xCampo
    def validate_xTextoType51(self, value):
        # Validate type xTextoType51, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xTextoType51' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xTextoType51' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xTextoType51_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xTextoType51_patterns_, ))
    validate_xTextoType51_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TString(self, value):
        # Validate type TString, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TString_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TString_patterns_, ))
    validate_TString_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.xTexto is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='obsFiscoType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('obsFiscoType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='obsFiscoType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='obsFiscoType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='obsFiscoType'):
        if self.xCampo is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            outfile.write(' xCampo=%s' % (quote_attrib(self.xCampo), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='obsFiscoType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xTexto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxTexto>%s</%sxTexto>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xTexto), input_name='xTexto')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xCampo', node)
        if value is not None and 'xCampo' not in already_processed:
            already_processed.add('xCampo')
            self.xCampo = value
            self.validate_TString(self.xCampo)    # validate type TString
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xTexto':
            xTexto_ = child_.text
            xTexto_ = self.gds_validate_string(xTexto_, node, 'xTexto')
            self.xTexto = xTexto_
            # validate type xTextoType51
            self.validate_xTextoType51(self.xTexto)
# end class obsFiscoType


class procRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nProc=None, indProc=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.nProc = nProc
        self.validate_nProcType(self.nProc)
        self.indProc = indProc
        self.validate_indProcType(self.indProc)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, procRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if procRefType.subclass:
            return procRefType.subclass(*args_, **kwargs_)
        else:
            return procRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nProc(self):
        return self.nProc
    def set_nProc(self, nProc):
        self.nProc = nProc
    def get_indProc(self):
        return self.indProc
    def set_indProc(self, indProc):
        self.indProc = indProc
    def validate_nProcType(self, value):
        # Validate type nProcType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on nProcType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on nProcType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_nProcType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_nProcType_patterns_, ))
    validate_nProcType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_indProcType(self, value):
        # Validate type indProcType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['0', '1', '2', '3', '9']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on indProcType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.nProc is not None or
            self.indProc is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='procRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('procRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='procRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='procRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='procRefType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='procRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snProc>%s</%snProc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nProc), input_name='nProc')), namespaceprefix_ , eol_))
        if self.indProc is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sindProc>%s</%sindProc>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.indProc), input_name='indProc')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nProc':
            nProc_ = child_.text
            nProc_ = self.gds_validate_string(nProc_, node, 'nProc')
            self.nProc = nProc_
            # validate type nProcType
            self.validate_nProcType(self.nProc)
        elif nodeName_ == 'indProc':
            indProc_ = child_.text
            indProc_ = self.gds_validate_string(indProc_, node, 'indProc')
            self.indProc = indProc_
            # validate type indProcType
            self.validate_indProcType(self.indProc)
# end class procRefType


class exportaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, UFSaidaPais=None, xLocExporta=None, xLocDespacho=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.UFSaidaPais = UFSaidaPais
        self.validate_TUfEmi(self.UFSaidaPais)
        self.xLocExporta = xLocExporta
        self.validate_xLocExportaType(self.xLocExporta)
        self.xLocDespacho = xLocDespacho
        self.validate_xLocDespachoType(self.xLocDespacho)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, exportaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if exportaType.subclass:
            return exportaType.subclass(*args_, **kwargs_)
        else:
            return exportaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UFSaidaPais(self):
        return self.UFSaidaPais
    def set_UFSaidaPais(self, UFSaidaPais):
        self.UFSaidaPais = UFSaidaPais
    def get_xLocExporta(self):
        return self.xLocExporta
    def set_xLocExporta(self, xLocExporta):
        self.xLocExporta = xLocExporta
    def get_xLocDespacho(self):
        return self.xLocDespacho
    def set_xLocDespacho(self, xLocDespacho):
        self.xLocDespacho = xLocDespacho
    def validate_TUfEmi(self, value):
        # Validate type TUfEmi, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO', 'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR', 'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TUfEmi' % {"value" : value.encode("utf-8")} )
    def validate_xLocExportaType(self, value):
        # Validate type xLocExportaType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLocExportaType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLocExportaType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLocExportaType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLocExportaType_patterns_, ))
    validate_xLocExportaType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_xLocDespachoType(self, value):
        # Validate type xLocDespachoType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xLocDespachoType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xLocDespachoType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xLocDespachoType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xLocDespachoType_patterns_, ))
    validate_xLocDespachoType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.UFSaidaPais is not None or
            self.xLocExporta is not None or
            self.xLocDespacho is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='exportaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('exportaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='exportaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='exportaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='exportaType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='exportaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.UFSaidaPais is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUFSaidaPais>%s</%sUFSaidaPais>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.UFSaidaPais), input_name='UFSaidaPais')), namespaceprefix_ , eol_))
        if self.xLocExporta is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxLocExporta>%s</%sxLocExporta>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xLocExporta), input_name='xLocExporta')), namespaceprefix_ , eol_))
        if self.xLocDespacho is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxLocDespacho>%s</%sxLocDespacho>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xLocDespacho), input_name='xLocDespacho')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UFSaidaPais':
            UFSaidaPais_ = child_.text
            UFSaidaPais_ = self.gds_validate_string(UFSaidaPais_, node, 'UFSaidaPais')
            self.UFSaidaPais = UFSaidaPais_
            # validate type TUfEmi
            self.validate_TUfEmi(self.UFSaidaPais)
        elif nodeName_ == 'xLocExporta':
            xLocExporta_ = child_.text
            xLocExporta_ = self.gds_validate_string(xLocExporta_, node, 'xLocExporta')
            self.xLocExporta = xLocExporta_
            # validate type xLocExportaType
            self.validate_xLocExportaType(self.xLocExporta)
        elif nodeName_ == 'xLocDespacho':
            xLocDespacho_ = child_.text
            xLocDespacho_ = self.gds_validate_string(xLocDespacho_, node, 'xLocDespacho')
            self.xLocDespacho = xLocDespacho_
            # validate type xLocDespachoType
            self.validate_xLocDespachoType(self.xLocDespacho)
# end class exportaType


class compraType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, xNEmp=None, xPed=None, xCont=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.xNEmp = xNEmp
        self.validate_xNEmpType(self.xNEmp)
        self.xPed = xPed
        self.validate_xPedType52(self.xPed)
        self.xCont = xCont
        self.validate_xContType(self.xCont)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, compraType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if compraType.subclass:
            return compraType.subclass(*args_, **kwargs_)
        else:
            return compraType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xNEmp(self):
        return self.xNEmp
    def set_xNEmp(self, xNEmp):
        self.xNEmp = xNEmp
    def get_xPed(self):
        return self.xPed
    def set_xPed(self, xPed):
        self.xPed = xPed
    def get_xCont(self):
        return self.xCont
    def set_xCont(self, xCont):
        self.xCont = xCont
    def validate_xNEmpType(self, value):
        # Validate type xNEmpType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 22:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xNEmpType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xNEmpType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xNEmpType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xNEmpType_patterns_, ))
    validate_xNEmpType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_xPedType52(self, value):
        # Validate type xPedType52, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xPedType52' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xPedType52' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xPedType52_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xPedType52_patterns_, ))
    validate_xPedType52_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_xContType(self, value):
        # Validate type xContType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xContType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xContType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xContType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xContType_patterns_, ))
    validate_xContType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.xNEmp is not None or
            self.xPed is not None or
            self.xCont is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='compraType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('compraType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='compraType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='compraType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='compraType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='compraType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xNEmp is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxNEmp>%s</%sxNEmp>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xNEmp), input_name='xNEmp')), namespaceprefix_ , eol_))
        if self.xPed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxPed>%s</%sxPed>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xPed), input_name='xPed')), namespaceprefix_ , eol_))
        if self.xCont is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxCont>%s</%sxCont>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xCont), input_name='xCont')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xNEmp':
            xNEmp_ = child_.text
            xNEmp_ = self.gds_validate_string(xNEmp_, node, 'xNEmp')
            self.xNEmp = xNEmp_
            # validate type xNEmpType
            self.validate_xNEmpType(self.xNEmp)
        elif nodeName_ == 'xPed':
            xPed_ = child_.text
            xPed_ = self.gds_validate_string(xPed_, node, 'xPed')
            self.xPed = xPed_
            # validate type xPedType52
            self.validate_xPedType52(self.xPed)
        elif nodeName_ == 'xCont':
            xCont_ = child_.text
            xCont_ = self.gds_validate_string(xCont_, node, 'xCont')
            self.xCont = xCont_
            # validate type xContType
            self.validate_xContType(self.xCont)
# end class compraType


class canaType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, safra=None, ref=None, forDia=None, qTotMes=None, qTotAnt=None, qTotGer=None, deduc=None, vFor=None, vTotDed=None, vLiqFor=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.safra = safra
        self.validate_safraType(self.safra)
        self.ref = ref
        self.validate_refType(self.ref)
        if forDia is None:
            self.forDia = []
        else:
            self.forDia = forDia
        self.qTotMes = qTotMes
        self.validate_TDec_1110v(self.qTotMes)
        self.qTotAnt = qTotAnt
        self.validate_TDec_1110v(self.qTotAnt)
        self.qTotGer = qTotGer
        self.validate_TDec_1110v(self.qTotGer)
        if deduc is None:
            self.deduc = []
        else:
            self.deduc = deduc
        self.vFor = vFor
        self.validate_TDec_1302(self.vFor)
        self.vTotDed = vTotDed
        self.validate_TDec_1302(self.vTotDed)
        self.vLiqFor = vLiqFor
        self.validate_TDec_1302(self.vLiqFor)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, canaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if canaType.subclass:
            return canaType.subclass(*args_, **kwargs_)
        else:
            return canaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_safra(self):
        return self.safra
    def set_safra(self, safra):
        self.safra = safra
    def get_ref(self):
        return self.ref
    def set_ref(self, ref):
        self.ref = ref
    def get_forDia(self):
        return self.forDia
    def set_forDia(self, forDia):
        self.forDia = forDia
    def add_forDia(self, value):
        self.forDia.append(value)
    def add_forDia(self, value):
        self.forDia.append(value)
    def insert_forDia_at(self, index, value):
        self.forDia.insert(index, value)
    def replace_forDia_at(self, index, value):
        self.forDia[index] = value
    def get_qTotMes(self):
        return self.qTotMes
    def set_qTotMes(self, qTotMes):
        self.qTotMes = qTotMes
    def get_qTotAnt(self):
        return self.qTotAnt
    def set_qTotAnt(self, qTotAnt):
        self.qTotAnt = qTotAnt
    def get_qTotGer(self):
        return self.qTotGer
    def set_qTotGer(self, qTotGer):
        self.qTotGer = qTotGer
    def get_deduc(self):
        return self.deduc
    def set_deduc(self, deduc):
        self.deduc = deduc
    def add_deduc(self, value):
        self.deduc.append(value)
    def add_deduc(self, value):
        self.deduc.append(value)
    def insert_deduc_at(self, index, value):
        self.deduc.insert(index, value)
    def replace_deduc_at(self, index, value):
        self.deduc[index] = value
    def get_vFor(self):
        return self.vFor
    def set_vFor(self, vFor):
        self.vFor = vFor
    def get_vTotDed(self):
        return self.vTotDed
    def set_vTotDed(self, vTotDed):
        self.vTotDed = vTotDed
    def get_vLiqFor(self):
        return self.vLiqFor
    def set_vLiqFor(self, vLiqFor):
        self.vLiqFor = vLiqFor
    def validate_safraType(self, value):
        # Validate type safraType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 9:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on safraType' % {"value" : value} )
            if len(str(value)) < 4:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on safraType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_safraType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_safraType_patterns_, ))
    validate_safraType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_refType(self, value):
        # Validate type refType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_refType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_refType_patterns_, ))
    validate_refType_patterns_ = [[u'^(0[1-9]|1[0-2])([/][2][0-9][0-9][0-9])$']]
    def validate_TDec_1110v(self, value):
        # Validate type TDec_1110v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1110v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1110v_patterns_, ))
    validate_TDec_1110v_patterns_ = [[u'^0|0\\.[0-9]{1,10}|[1-9]{1}[0-9]{0,10}|[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,10})?$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.safra is not None or
            self.ref is not None or
            self.forDia or
            self.qTotMes is not None or
            self.qTotAnt is not None or
            self.qTotGer is not None or
            self.deduc or
            self.vFor is not None or
            self.vTotDed is not None or
            self.vLiqFor is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='canaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('canaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='canaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='canaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='canaType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='canaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.safra is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssafra>%s</%ssafra>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.safra), input_name='safra')), namespaceprefix_ , eol_))
        if self.ref is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sref>%s</%sref>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ref), input_name='ref')), namespaceprefix_ , eol_))
        for forDia_ in self.forDia:
            forDia_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='forDia', pretty_print=pretty_print)
        if self.qTotMes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqTotMes>%s</%sqTotMes>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qTotMes), input_name='qTotMes')), namespaceprefix_ , eol_))
        if self.qTotAnt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqTotAnt>%s</%sqTotAnt>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qTotAnt), input_name='qTotAnt')), namespaceprefix_ , eol_))
        if self.qTotGer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqTotGer>%s</%sqTotGer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qTotGer), input_name='qTotGer')), namespaceprefix_ , eol_))
        for deduc_ in self.deduc:
            deduc_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deduc', pretty_print=pretty_print)
        if self.vFor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svFor>%s</%svFor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vFor), input_name='vFor')), namespaceprefix_ , eol_))
        if self.vTotDed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svTotDed>%s</%svTotDed>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vTotDed), input_name='vTotDed')), namespaceprefix_ , eol_))
        if self.vLiqFor is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svLiqFor>%s</%svLiqFor>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vLiqFor), input_name='vLiqFor')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'safra':
            safra_ = child_.text
            safra_ = self.gds_validate_string(safra_, node, 'safra')
            self.safra = safra_
            # validate type safraType
            self.validate_safraType(self.safra)
        elif nodeName_ == 'ref':
            ref_ = child_.text
            ref_ = self.gds_validate_string(ref_, node, 'ref')
            self.ref = ref_
            # validate type refType
            self.validate_refType(self.ref)
        elif nodeName_ == 'forDia':
            obj_ = forDiaType.factory(parent_object_=self)
            obj_.build(child_)
            self.forDia.append(obj_)
            obj_.original_tagname_ = 'forDia'
        elif nodeName_ == 'qTotMes':
            qTotMes_ = child_.text
            qTotMes_ = self.gds_validate_string(qTotMes_, node, 'qTotMes')
            self.qTotMes = qTotMes_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.qTotMes)
        elif nodeName_ == 'qTotAnt':
            qTotAnt_ = child_.text
            qTotAnt_ = self.gds_validate_string(qTotAnt_, node, 'qTotAnt')
            self.qTotAnt = qTotAnt_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.qTotAnt)
        elif nodeName_ == 'qTotGer':
            qTotGer_ = child_.text
            qTotGer_ = self.gds_validate_string(qTotGer_, node, 'qTotGer')
            self.qTotGer = qTotGer_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.qTotGer)
        elif nodeName_ == 'deduc':
            obj_ = deducType.factory(parent_object_=self)
            obj_.build(child_)
            self.deduc.append(obj_)
            obj_.original_tagname_ = 'deduc'
        elif nodeName_ == 'vFor':
            vFor_ = child_.text
            vFor_ = self.gds_validate_string(vFor_, node, 'vFor')
            self.vFor = vFor_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vFor)
        elif nodeName_ == 'vTotDed':
            vTotDed_ = child_.text
            vTotDed_ = self.gds_validate_string(vTotDed_, node, 'vTotDed')
            self.vTotDed = vTotDed_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vTotDed)
        elif nodeName_ == 'vLiqFor':
            vLiqFor_ = child_.text
            vLiqFor_ = self.gds_validate_string(vLiqFor_, node, 'vLiqFor')
            self.vLiqFor = vLiqFor_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vLiqFor)
# end class canaType


class forDiaType(GeneratedsSuper):
    """Número do dia"""
    subclass = None
    superclass = None
    def __init__(self, dia=None, qtde=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.dia = _cast(None, dia)
        self.qtde = qtde
        self.validate_TDec_1110v(self.qtde)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, forDiaType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if forDiaType.subclass:
            return forDiaType.subclass(*args_, **kwargs_)
        else:
            return forDiaType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qtde(self):
        return self.qtde
    def set_qtde(self, qtde):
        self.qtde = qtde
    def get_dia(self):
        return self.dia
    def set_dia(self, dia):
        self.dia = dia
    def validate_TDec_1110v(self, value):
        # Validate type TDec_1110v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1110v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1110v_patterns_, ))
    validate_TDec_1110v_patterns_ = [[u'^0|0\\.[0-9]{1,10}|[1-9]{1}[0-9]{0,10}|[1-9]{1}[0-9]{0,10}(\\.[0-9]{1,10})?$']]
    def hasContent_(self):
        if (
            self.qtde is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='forDiaType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('forDiaType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='forDiaType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='forDiaType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='forDiaType'):
        if self.dia is not None and 'dia' not in already_processed:
            already_processed.add('dia')
            outfile.write(' dia=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.dia), input_name='dia')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='forDiaType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qtde is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqtde>%s</%sqtde>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qtde), input_name='qtde')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dia', node)
        if value is not None and 'dia' not in already_processed:
            already_processed.add('dia')
            self.dia = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qtde':
            qtde_ = child_.text
            qtde_ = self.gds_validate_string(qtde_, node, 'qtde')
            self.qtde = qtde_
            # validate type TDec_1110v
            self.validate_TDec_1110v(self.qtde)
# end class forDiaType


class deducType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, xDed=None, vDed=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.xDed = xDed
        self.validate_xDedType(self.xDed)
        self.vDed = vDed
        self.validate_TDec_1302(self.vDed)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, deducType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if deducType.subclass:
            return deducType.subclass(*args_, **kwargs_)
        else:
            return deducType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_xDed(self):
        return self.xDed
    def set_xDed(self, xDed):
        self.xDed = xDed
    def get_vDed(self):
        return self.vDed
    def set_vDed(self, vDed):
        self.vDed = vDed
    def validate_xDedType(self, value):
        # Validate type xDedType, a restriction on TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 60:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on xDedType' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on xDedType' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_xDedType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_xDedType_patterns_, ))
    validate_xDedType_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def hasContent_(self):
        if (
            self.xDed is not None or
            self.vDed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='deducType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('deducType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='deducType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='deducType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='deducType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='deducType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.xDed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxDed>%s</%sxDed>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xDed), input_name='xDed')), namespaceprefix_ , eol_))
        if self.vDed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svDed>%s</%svDed>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vDed), input_name='vDed')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'xDed':
            xDed_ = child_.text
            xDed_ = self.gds_validate_string(xDed_, node, 'xDed')
            self.xDed = xDed_
            # validate type xDedType
            self.validate_xDedType(self.xDed)
        elif nodeName_ == 'vDed':
            vDed_ = child_.text
            vDed_ = self.gds_validate_string(vDed_, node, 'vDed')
            self.vDed = vDed_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vDed)
# end class deducType


class infNFeSuplType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, qrCode=None, urlChave=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.qrCode = qrCode
        self.validate_qrCodeType(self.qrCode)
        self.urlChave = urlChave
        self.validate_urlChaveType(self.urlChave)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infNFeSuplType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infNFeSuplType.subclass:
            return infNFeSuplType.subclass(*args_, **kwargs_)
        else:
            return infNFeSuplType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_qrCode(self):
        return self.qrCode
    def set_qrCode(self, qrCode):
        self.qrCode = qrCode
    def get_urlChave(self):
        return self.urlChave
    def set_urlChave(self, urlChave):
        self.urlChave = urlChave
    def validate_qrCodeType(self, value):
        # Validate type qrCodeType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 600:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on qrCodeType' % {"value" : value.encode("utf-8")} )
            if len(value) < 100:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on qrCodeType' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_qrCodeType_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_qrCodeType_patterns_, ))
    validate_qrCodeType_patterns_ = [[u'^(((HTTPS?|https?)://.*\\?chNFe=[0-9]{44}&nVersao=100&tpAmb=[1-2](&cDest=([A-Za-z0-9.:+-/)(]{0}|[A-Za-z0-9.:+-/)(]{5,20})?)?&dhEmi=[A-Fa-f0-9]{50}&vNF=(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)&vICMS=(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)&digVal=[A-Fa-f0-9]{56}&cIdToken=[0-9]{6}&cHashQRCode=[A-Fa-f0-9]{40})|((HTTPS?|https?)://.*\\?p=([0-9]{34}(1|4)[0-9]{9})\\|[2]\\|[1-2]\\|(0|[1-9]{1}([0-9]{1,5})?)\\|[A-Fa-f0-9]{40})|((HTTPS?|https?)://.*\\?p=([0-9]{34}9[0-9]{9})\\|[2]\\|[1-2]\\|([0]{1}[1-9]{1}|[1-2]{1}[0-9]{1}|[3]{1}[0-1]{1})\\|(0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?)\\|[A-Fa-f0-9]{56}\\|(0|[1-9]{1}([0-9]{1,5})?)\\|[A-Fa-f0-9]{40}))$']]
    def validate_urlChaveType(self, value):
        # Validate type urlChaveType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 85:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on urlChaveType' % {"value" : value.encode("utf-8")} )
            if len(value) < 21:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on urlChaveType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.qrCode is not None or
            self.urlChave is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='infNFeSuplType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infNFeSuplType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infNFeSuplType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infNFeSuplType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infNFeSuplType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='infNFeSuplType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.qrCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqrCode>%s</%sqrCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qrCode), input_name='qrCode')), namespaceprefix_ , eol_))
        if self.urlChave is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%surlChave>%s</%surlChave>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.urlChave), input_name='urlChave')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'qrCode':
            qrCode_ = child_.text
            qrCode_ = self.gds_validate_string(qrCode_, node, 'qrCode')
            self.qrCode = qrCode_
            # validate type qrCodeType
            self.validate_qrCodeType(self.qrCode)
        elif nodeName_ == 'urlChave':
            urlChave_ = child_.text
            urlChave_ = self.gds_validate_string(urlChave_, node, 'urlChave')
            self.urlChave = urlChave_
            # validate type urlChaveType
            self.validate_urlChaveType(self.urlChave)
# end class infNFeSuplType


class infProtType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Id=None, tpAmb=None, verAplic=None, chNFe=None, dhRecbto=None, nProt=None, digVal=None, cStat=None, xMotivo=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.Id = _cast(None, Id)
        self.tpAmb = tpAmb
        self.validate_TAmb(self.tpAmb)
        self.verAplic = verAplic
        self.validate_TVerAplic(self.verAplic)
        self.chNFe = chNFe
        self.validate_TChNFe(self.chNFe)
        self.dhRecbto = dhRecbto
        self.validate_TDateTimeUTC(self.dhRecbto)
        self.nProt = nProt
        self.validate_TProt(self.nProt)
        self.digVal = digVal
        self.validate_DigestValueType(self.digVal)
        self.cStat = cStat
        self.validate_TStat(self.cStat)
        self.xMotivo = xMotivo
        self.validate_TMotivo(self.xMotivo)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infProtType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infProtType.subclass:
            return infProtType.subclass(*args_, **kwargs_)
        else:
            return infProtType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tpAmb(self):
        return self.tpAmb
    def set_tpAmb(self, tpAmb):
        self.tpAmb = tpAmb
    def get_verAplic(self):
        return self.verAplic
    def set_verAplic(self, verAplic):
        self.verAplic = verAplic
    def get_chNFe(self):
        return self.chNFe
    def set_chNFe(self, chNFe):
        self.chNFe = chNFe
    def get_dhRecbto(self):
        return self.dhRecbto
    def set_dhRecbto(self, dhRecbto):
        self.dhRecbto = dhRecbto
    def get_nProt(self):
        return self.nProt
    def set_nProt(self, nProt):
        self.nProt = nProt
    def get_digVal(self):
        return self.digVal
    def set_digVal(self, digVal):
        self.digVal = digVal
    def get_cStat(self):
        return self.cStat
    def set_cStat(self, cStat):
        self.cStat = cStat
    def get_xMotivo(self):
        return self.xMotivo
    def set_xMotivo(self, xMotivo):
        self.xMotivo = xMotivo
    def get_Id(self):
        return self.Id
    def set_Id(self, Id):
        self.Id = Id
    def validate_TAmb(self, value):
        # Validate type TAmb, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['1', '2']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on TAmb' % {"value" : value.encode("utf-8")} )
    def validate_TVerAplic(self, value):
        # Validate type TVerAplic, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 20:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TVerAplic' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TVerAplic' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TVerAplic_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TVerAplic_patterns_, ))
    validate_TVerAplic_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def validate_TChNFe(self, value):
        # Validate type TChNFe, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 44:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TChNFe' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TChNFe_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TChNFe_patterns_, ))
    validate_TChNFe_patterns_ = [[u'^[0-9]{44}$']]
    def validate_TDateTimeUTC(self, value):
        # Validate type TDateTimeUTC, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDateTimeUTC_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDateTimeUTC_patterns_, ))
    validate_TDateTimeUTC_patterns_ = [[u'^(((20(([02468][048])|([13579][26]))-02-29))|(20[0-9][0-9])-((((0[1-9])|(1[0-2]))-((0[1-9])|(1\\d)|(2[0-8])))|((((0[13578])|(1[02]))-31)|(((0[1,3-9])|(1[0-2]))-(29|30)))))T(20|21|22|23|[0-1]\\d):[0-5]\\d:[0-5]\\d([\\-,\\+](0[0-9]|10|11):00|([\\+](12):00))$']]
    def validate_TProt(self, value):
        # Validate type TProt, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TProt' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TProt_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TProt_patterns_, ))
    validate_TProt_patterns_ = [[u'^[0-9]{15}$']]
    def validate_DigestValueType(self, value):
        # Validate type DigestValueType, a restriction on base64Binary.
        if value is not None and Validate_simpletypes_:
            pass
    def validate_TStat(self, value):
        # Validate type TStat, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 3:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TStat' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TStat_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TStat_patterns_, ))
    validate_TStat_patterns_ = [[u'^[0-9]{3}$']]
    def validate_TMotivo(self, value):
        # Validate type TMotivo, a restriction on nfe:TString.
        if value is not None and Validate_simpletypes_:
            if len(str(value)) > 255:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TMotivo' % {"value" : value} )
            if len(str(value)) < 1:
                warnings_.warn('Value "%(value)s" does not match xsd minLength restriction on TMotivo' % {"value" : value} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TMotivo_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TMotivo_patterns_, ))
    validate_TMotivo_patterns_ = [[u'^[!-\xff]{1}[ -\xff]{0,}[!-\xff]{1}|[!-\xff]{1}$']]
    def hasContent_(self):
        if (
            self.tpAmb is not None or
            self.verAplic is not None or
            self.chNFe is not None or
            self.dhRecbto is not None or
            self.nProt is not None or
            self.digVal is not None or
            self.cStat is not None or
            self.xMotivo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='infProtType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infProtType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infProtType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infProtType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infProtType'):
        if self.Id is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            outfile.write(' Id=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.Id), input_name='Id')), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:ds="http://www.w3.org/2000/09/xmldsig#" ', name_='infProtType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.tpAmb is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stpAmb>%s</%stpAmb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tpAmb), input_name='tpAmb')), namespaceprefix_ , eol_))
        if self.verAplic is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sverAplic>%s</%sverAplic>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.verAplic), input_name='verAplic')), namespaceprefix_ , eol_))
        if self.chNFe is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%schNFe>%s</%schNFe>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.chNFe), input_name='chNFe')), namespaceprefix_ , eol_))
        if self.dhRecbto is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdhRecbto>%s</%sdhRecbto>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.dhRecbto), input_name='dhRecbto')), namespaceprefix_ , eol_))
        if self.nProt is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snProt>%s</%snProt>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nProt), input_name='nProt')), namespaceprefix_ , eol_))
        if self.digVal is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdigVal>%s</%sdigVal>%s' % (namespaceprefix_ , self.gds_format_base64(self.digVal, input_name='digVal'), namespaceprefix_ , eol_))
        if self.cStat is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scStat>%s</%scStat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.cStat), input_name='cStat')), namespaceprefix_ , eol_))
        if self.xMotivo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxMotivo>%s</%sxMotivo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.xMotivo), input_name='xMotivo')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Id', node)
        if value is not None and 'Id' not in already_processed:
            already_processed.add('Id')
            self.Id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'tpAmb':
            tpAmb_ = child_.text
            tpAmb_ = self.gds_validate_string(tpAmb_, node, 'tpAmb')
            self.tpAmb = tpAmb_
            # validate type TAmb
            self.validate_TAmb(self.tpAmb)
        elif nodeName_ == 'verAplic':
            verAplic_ = child_.text
            verAplic_ = self.gds_validate_string(verAplic_, node, 'verAplic')
            self.verAplic = verAplic_
            # validate type TVerAplic
            self.validate_TVerAplic(self.verAplic)
        elif nodeName_ == 'chNFe':
            chNFe_ = child_.text
            chNFe_ = self.gds_validate_string(chNFe_, node, 'chNFe')
            self.chNFe = chNFe_
            # validate type TChNFe
            self.validate_TChNFe(self.chNFe)
        elif nodeName_ == 'dhRecbto':
            dhRecbto_ = child_.text
            dhRecbto_ = self.gds_validate_string(dhRecbto_, node, 'dhRecbto')
            self.dhRecbto = dhRecbto_
            # validate type TDateTimeUTC
            self.validate_TDateTimeUTC(self.dhRecbto)
        elif nodeName_ == 'nProt':
            nProt_ = child_.text
            nProt_ = self.gds_validate_string(nProt_, node, 'nProt')
            self.nProt = nProt_
            # validate type TProt
            self.validate_TProt(self.nProt)
        elif nodeName_ == 'digVal':
            sval_ = child_.text
            if sval_ is not None:
                try:
                    bval_ = base64.b64decode(sval_)
                except (TypeError, ValueError) as exp:
                    raise_parse_error(child_, 'requires base64 encoded string: %s' % exp)
                bval_ = self.gds_validate_base64(bval_, node, 'digVal')
            else:
                bval_ = None
            self.digVal = bval_
            # validate type DigestValueType
            self.validate_DigestValueType(self.digVal)
        elif nodeName_ == 'cStat':
            cStat_ = child_.text
            cStat_ = self.gds_validate_string(cStat_, node, 'cStat')
            self.cStat = cStat_
            # validate type TStat
            self.validate_TStat(self.cStat)
        elif nodeName_ == 'xMotivo':
            xMotivo_ = child_.text
            xMotivo_ = self.gds_validate_string(xMotivo_, node, 'xMotivo')
            self.xMotivo = xMotivo_
            # validate type TMotivo
            self.validate_TMotivo(self.xMotivo)
# end class infProtType


class infRecType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, nRec=None, tMed=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.nRec = nRec
        self.validate_TRec(self.nRec)
        self.tMed = tMed
        self.validate_TMed(self.tMed)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, infRecType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if infRecType.subclass:
            return infRecType.subclass(*args_, **kwargs_)
        else:
            return infRecType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nRec(self):
        return self.nRec
    def set_nRec(self, nRec):
        self.nRec = nRec
    def get_tMed(self):
        return self.tMed
    def set_tMed(self, tMed):
        self.tMed = tMed
    def validate_TRec(self, value):
        # Validate type TRec, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if len(value) > 15:
                warnings_.warn('Value "%(value)s" does not match xsd maxLength restriction on TRec' % {"value" : value.encode("utf-8")} )
            if not self.gds_validate_simple_patterns(
                    self.validate_TRec_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TRec_patterns_, ))
    validate_TRec_patterns_ = [[u'^[0-9]{15}$']]
    def validate_TMed(self, value):
        # Validate type TMed, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TMed_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TMed_patterns_, ))
    validate_TMed_patterns_ = [[u'^[0-9]{1,4}$']]
    def hasContent_(self):
        if (
            self.nRec is not None or
            self.tMed is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='infRecType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('infRecType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='infRecType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='infRecType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='infRecType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='infRecType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.nRec is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snRec>%s</%snRec>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.nRec), input_name='nRec')), namespaceprefix_ , eol_))
        if self.tMed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stMed>%s</%stMed>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.tMed), input_name='tMed')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'nRec':
            nRec_ = child_.text
            nRec_ = self.gds_validate_string(nRec_, node, 'nRec')
            self.nRec = nRec_
            # validate type TRec
            self.validate_TRec(self.nRec)
        elif nodeName_ == 'tMed':
            tMed_ = child_.text
            tMed_ = self.gds_validate_string(tMed_, node, 'tMed')
            self.tMed = tMed_
            # validate type TMed
            self.validate_TMed(self.tMed)
# end class infRecType


class IPITribType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CST=None, vBC=None, pIPI=None, qUnid=None, vUnid=None, vIPI=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CST = CST
        self.validate_CSTType70(self.CST)
        self.vBC = vBC
        self.validate_TDec_1302(self.vBC)
        self.pIPI = pIPI
        self.validate_TDec_0302a04(self.pIPI)
        self.qUnid = qUnid
        self.validate_TDec_1204v(self.qUnid)
        self.vUnid = vUnid
        self.validate_TDec_1104(self.vUnid)
        self.vIPI = vIPI
        self.validate_TDec_1302(self.vIPI)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPITribType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPITribType.subclass:
            return IPITribType.subclass(*args_, **kwargs_)
        else:
            return IPITribType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def get_vBC(self):
        return self.vBC
    def set_vBC(self, vBC):
        self.vBC = vBC
    def get_pIPI(self):
        return self.pIPI
    def set_pIPI(self, pIPI):
        self.pIPI = pIPI
    def get_qUnid(self):
        return self.qUnid
    def set_qUnid(self, qUnid):
        self.qUnid = qUnid
    def get_vUnid(self):
        return self.vUnid
    def set_vUnid(self, vUnid):
        self.vUnid = vUnid
    def get_vIPI(self):
        return self.vIPI
    def set_vIPI(self, vIPI):
        self.vIPI = vIPI
    def validate_CSTType70(self, value):
        # Validate type CSTType70, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['00', '49', '50', '99']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType70' % {"value" : value.encode("utf-8")} )
    def validate_TDec_1302(self, value):
        # Validate type TDec_1302, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1302_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1302_patterns_, ))
    validate_TDec_1302_patterns_ = [[u'^0|0\\.[0-9]{2}|[1-9]{1}[0-9]{0,12}(\\.[0-9]{2})?$']]
    def validate_TDec_0302a04(self, value):
        # Validate type TDec_0302a04, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_0302a04_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_0302a04_patterns_, ))
    validate_TDec_0302a04_patterns_ = [[u'^0|0\\.[0-9]{2,4}|[1-9]{1}[0-9]{0,2}(\\.[0-9]{2,4})?$']]
    def validate_TDec_1204v(self, value):
        # Validate type TDec_1204v, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1204v_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1204v_patterns_, ))
    validate_TDec_1204v_patterns_ = [[u'^0|0\\.[0-9]{1,4}|[1-9]{1}[0-9]{0,11}|[1-9]{1}[0-9]{0,11}(\\.[0-9]{1,4})?$']]
    def validate_TDec_1104(self, value):
        # Validate type TDec_1104, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            if not self.gds_validate_simple_patterns(
                    self.validate_TDec_1104_patterns_, value):
                warnings_.warn('Value "%s" does not match xsd pattern restrictions: %s' % (value.encode('utf-8'), self.validate_TDec_1104_patterns_, ))
    validate_TDec_1104_patterns_ = [[u'^0|0\\.[0-9]{4}|[1-9]{1}[0-9]{0,10}(\\.[0-9]{4})?$']]
    def hasContent_(self):
        if (
            self.CST is not None or
            self.vBC is not None or
            self.pIPI is not None or
            self.qUnid is not None or
            self.vUnid is not None or
            self.vIPI is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IPITribType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IPITribType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IPITribType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IPITribType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IPITribType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IPITribType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
        if self.vBC is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svBC>%s</%svBC>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vBC), input_name='vBC')), namespaceprefix_ , eol_))
        if self.pIPI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spIPI>%s</%spIPI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.pIPI), input_name='pIPI')), namespaceprefix_ , eol_))
        if self.qUnid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sqUnid>%s</%sqUnid>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qUnid), input_name='qUnid')), namespaceprefix_ , eol_))
        if self.vUnid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svUnid>%s</%svUnid>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vUnid), input_name='vUnid')), namespaceprefix_ , eol_))
        if self.vIPI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svIPI>%s</%svIPI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.vIPI), input_name='vIPI')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType70
            self.validate_CSTType70(self.CST)
        elif nodeName_ == 'vBC':
            vBC_ = child_.text
            vBC_ = self.gds_validate_string(vBC_, node, 'vBC')
            self.vBC = vBC_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vBC)
        elif nodeName_ == 'pIPI':
            pIPI_ = child_.text
            pIPI_ = self.gds_validate_string(pIPI_, node, 'pIPI')
            self.pIPI = pIPI_
            # validate type TDec_0302a04
            self.validate_TDec_0302a04(self.pIPI)
        elif nodeName_ == 'qUnid':
            qUnid_ = child_.text
            qUnid_ = self.gds_validate_string(qUnid_, node, 'qUnid')
            self.qUnid = qUnid_
            # validate type TDec_1204v
            self.validate_TDec_1204v(self.qUnid)
        elif nodeName_ == 'vUnid':
            vUnid_ = child_.text
            vUnid_ = self.gds_validate_string(vUnid_, node, 'vUnid')
            self.vUnid = vUnid_
            # validate type TDec_1104
            self.validate_TDec_1104(self.vUnid)
        elif nodeName_ == 'vIPI':
            vIPI_ = child_.text
            vIPI_ = self.gds_validate_string(vIPI_, node, 'vIPI')
            self.vIPI = vIPI_
            # validate type TDec_1302
            self.validate_TDec_1302(self.vIPI)
# end class IPITribType


class IPINTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, CST=None, **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.CST = CST
        self.validate_CSTType71(self.CST)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPINTType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPINTType.subclass:
            return IPINTType.subclass(*args_, **kwargs_)
        else:
            return IPINTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CST(self):
        return self.CST
    def set_CST(self, CST):
        self.CST = CST
    def validate_CSTType71(self, value):
        # Validate type CSTType71, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['01', '02', '03', '04', '05', '51', '52', '53', '54', '55']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on CSTType71' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.CST is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IPINTType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IPINTType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IPINTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IPINTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IPINTType'):
        pass
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IPINTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CST is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCST>%s</%sCST>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.CST), input_name='CST')), namespaceprefix_ , eol_))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CST':
            CST_ = child_.text
            CST_ = self.gds_validate_string(CST_, node, 'CST')
            self.CST = CST_
            # validate type CSTType71
            self.validate_CSTType71(self.CST)
# end class IPINTType


class CanonicalizationMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm='http://www.w3.org/TR/2001/REC-xml-c14n-20010315', **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.Algorithm = _cast(None, Algorithm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CanonicalizationMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CanonicalizationMethodType.subclass:
            return CanonicalizationMethodType.subclass(*args_, **kwargs_)
        else:
            return CanonicalizationMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Algorithm(self):
        return self.Algorithm
    def set_Algorithm(self, Algorithm):
        self.Algorithm = Algorithm
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CanonicalizationMethodType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CanonicalizationMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CanonicalizationMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CanonicalizationMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CanonicalizationMethodType'):
        if self.Algorithm != "http://www.w3.org/TR/2001/REC-xml-c14n-20010315" and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CanonicalizationMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CanonicalizationMethodType


class SignatureMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm='http://www.w3.org/2000/09/xmldsig#rsa-sha1', **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.Algorithm = _cast(None, Algorithm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignatureMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignatureMethodType.subclass:
            return SignatureMethodType.subclass(*args_, **kwargs_)
        else:
            return SignatureMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Algorithm(self):
        return self.Algorithm
    def set_Algorithm(self, Algorithm):
        self.Algorithm = Algorithm
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SignatureMethodType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignatureMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignatureMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignatureMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SignatureMethodType'):
        if self.Algorithm != "http://www.w3.org/2000/09/xmldsig#rsa-sha1" and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SignatureMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SignatureMethodType


class DigestMethodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Algorithm='http://www.w3.org/2000/09/xmldsig#sha1', **kwargs_):
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.Algorithm = _cast(None, Algorithm)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DigestMethodType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DigestMethodType.subclass:
            return DigestMethodType.subclass(*args_, **kwargs_)
        else:
            return DigestMethodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Algorithm(self):
        return self.Algorithm
    def set_Algorithm(self, Algorithm):
        self.Algorithm = Algorithm
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DigestMethodType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DigestMethodType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DigestMethodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DigestMethodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DigestMethodType'):
        if self.Algorithm != "http://www.w3.org/2000/09/xmldsig#sha1" and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            outfile.write(' Algorithm=%s' % (quote_attrib(self.Algorithm), ))
    def exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DigestMethodType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('Algorithm', node)
        if value is not None and 'Algorithm' not in already_processed:
            already_processed.add('Algorithm')
            self.Algorithm = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DigestMethodType


GDSClassesMapping = {
    'NFe': TNFe,
    'Signature': SignatureType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TNFe'
        rootClass = TNFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TNFe'
        rootClass = TNFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TNFe'
        rootClass = TNFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'TNFe'
        rootClass = TNFe
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from pySchema import *\n\n')
        sys.stdout.write('import pySchema as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "CIDEType",
    "COFINSAliqType",
    "COFINSNTType",
    "COFINSOutrType",
    "COFINSQtdeType",
    "COFINSSTType",
    "COFINSType",
    "CanonicalizationMethodType",
    "DIType",
    "DigestMethodType",
    "ICMS00Type",
    "ICMS10Type",
    "ICMS20Type",
    "ICMS30Type",
    "ICMS40Type",
    "ICMS51Type",
    "ICMS60Type",
    "ICMS70Type",
    "ICMS90Type",
    "ICMSPartType",
    "ICMSSN101Type",
    "ICMSSN102Type",
    "ICMSSN201Type",
    "ICMSSN202Type",
    "ICMSSN500Type",
    "ICMSSN900Type",
    "ICMSSTType",
    "ICMSTotType",
    "ICMSType",
    "ICMSUFDestType",
    "IIType",
    "IPINTType",
    "IPITribType",
    "IPIType",
    "ISSQNType",
    "ISSQNtotType",
    "KeyInfoType",
    "NFrefType",
    "PISAliqType",
    "PISNTType",
    "PISOutrType",
    "PISQtdeType",
    "PISSTType",
    "PISType",
    "ReferenceType",
    "SignatureMethodType",
    "SignatureType",
    "SignatureValueType",
    "SignedInfoType",
    "TConsReciNFe",
    "TEnderEmi",
    "TEndereco",
    "TEnviNFe",
    "TIpi",
    "TLocal",
    "TNFe",
    "TNfeProc",
    "TProtNFe",
    "TRetConsReciNFe",
    "TRetEnviNFe",
    "TVeiculo",
    "TransformType",
    "TransformsType",
    "X509DataType",
    "adiType",
    "armaType",
    "autXMLType",
    "avulsaType",
    "canaType",
    "cardType",
    "cobrType",
    "combType",
    "compraType",
    "deducType",
    "destType",
    "detExportType",
    "detPagType",
    "detType",
    "dupType",
    "emitType",
    "encerranteType",
    "exportIndType",
    "exportaType",
    "fatType",
    "forDiaType",
    "ideType",
    "impostoDevolType",
    "impostoType",
    "infAdicType",
    "infNFeSuplType",
    "infNFeType",
    "infProtType",
    "infRecType",
    "lacresType",
    "medType",
    "obsContType",
    "obsFiscoType",
    "pagType",
    "procRefType",
    "prodType",
    "rastroType",
    "refECFType",
    "refNFPType",
    "refNFType",
    "retTranspType",
    "retTribType",
    "totalType",
    "transpType",
    "transportaType",
    "veicProdType",
    "volType"
]
